Directory structure:
â””â”€â”€ aedmark-boneamanita/
    â”œâ”€â”€ bone_body.py
    â”œâ”€â”€ bone_brain.py
    â”œâ”€â”€ bone_bus.py
    â”œâ”€â”€ bone_commands.py
    â”œâ”€â”€ bone_data.py
    â”œâ”€â”€ bone_genesis.py
    â”œâ”€â”€ bone_inventory.py
    â”œâ”€â”€ bone_lexicon.py
    â”œâ”€â”€ bone_machine.py
    â”œâ”€â”€ bone_main.py
    â”œâ”€â”€ bone_personality.py
    â”œâ”€â”€ bone_physics.py
    â”œâ”€â”€ bone_spores.py
    â”œâ”€â”€ bone_viewer.py
    â””â”€â”€ bone_village.py

================================================
FILE: bone_body.py
================================================
# bone_body.py - The Body

import math
import random
import time
from collections import deque
from dataclasses import dataclass, field
from typing import Set, Optional, Dict, List, Any, Tuple

from bone_brain import NeuroPlasticity, ShimmerState
from bone_personality import SynergeticLensArbiter
from bone_physics import PhysicsPacket
from bone_spores import MycotoxinFactory, LichenSymbiont, HyphalInterface, ParasiticSymbiont
from bone_lexicon import TheLexicon
from bone_bus import Prisma, BoneConfig

@dataclass
class BioSystem:
    mito: 'MitochondrialForge'
    endo: 'EndocrineSystem'
    immune: MycotoxinFactory
    lichen: LichenSymbiont
    gut: HyphalInterface
    plasticity: NeuroPlasticity
    governor: 'MetabolicGovernor'
    shimmer: ShimmerState
    parasite: ParasiticSymbiont

@dataclass
class MetabolicReceipt:
    base_cost: float
    drag_tax: float
    inefficiency_tax: float
    total_burn: float
    status: str
    symptom: str = "Nominal"

@dataclass
class MitochondrialState:
    atp_pool: float = 100.0
    ros_buildup: float = 0.0
    membrane_potential: float = -150.0
    mother_hash: str = "MITOCHONDRIAL_EVE_001"
    efficiency_mod: float = 1.0
    ros_resistance: float = 1.0
    enzymes: Set[str] = field(default_factory=set)

class MitochondrialForge:
    APOPTOSIS_TRIGGER = "CYTOCHROME_C_RELEASE"

    def __init__(self, lineage_seed: str, events, inherited_traits: Optional[Dict] = None):
        self.state = MitochondrialState(mother_hash=lineage_seed)
        self.events = events
        self.krebs_cycle_active = True

        self.BMR = BoneConfig.METABOLISM.BASE_RATE
        self.TAX_LOW = BoneConfig.METABOLISM.DRAG_TAX_LOW
        self.TAX_HIGH = BoneConfig.METABOLISM.DRAG_TAX_HIGH
        self.GRACE = BoneConfig.METABOLISM.DRAG_GRACE_BUFFER
        self.ROS_FACTOR = BoneConfig.METABOLISM.ROS_GENERATION_FACTOR

        if inherited_traits:
            self._apply_inheritance(inherited_traits)

    def _apply_inheritance(self, traits: Dict):
        self.state.efficiency_mod = traits.get("efficiency_mod", 1.0)
        self.state.ros_resistance = traits.get("ros_resistance", 1.0)
        if "enzymes" in traits:
            self.state.enzymes = set(traits["enzymes"])
            self.events.log(f"{Prisma.CYN}[MITO]: Inherited Enzymes: {list(self.state.enzymes)}.{Prisma.RST}")

    def adapt(self, final_health: float) -> Dict:
        traits = {
            "efficiency_mod": self.state.efficiency_mod,
            "ros_resistance": self.state.ros_resistance,
            "enzymes": list(self.state.enzymes)}

        if final_health <= 0 and random.random() < 0.3:
            traits["ros_resistance"] = round(traits.get("ros_resistance", 1.0) + 0.1, 2)

        return traits

    def calculate_metabolism(self, drag: float, external_modifiers: Optional[List[float]] = None) -> MetabolicReceipt:
        limit = BoneConfig.MAX_DRAG_LIMIT
        safe_drag = max(0.0, drag)

        taxable_drag = max(0.0, safe_drag - self.GRACE)

        if taxable_drag <= (limit - self.GRACE):
            drag_tax = taxable_drag * self.TAX_LOW
        else:
            base_tax = (limit - self.GRACE) * self.TAX_LOW
            excess_drag = taxable_drag - (limit - self.GRACE)
            drag_tax = base_tax + (excess_drag * self.TAX_HIGH)

        if external_modifiers:
            for mod in external_modifiers:
                drag_tax *= mod

        raw_cost = self.BMR + drag_tax

        safe_efficiency = max(0.1, self.state.efficiency_mod)
        final_cost = raw_cost / safe_efficiency

        inefficiency_tax = 0.0
        if safe_efficiency < 1.0:
            inefficiency_tax = final_cost - raw_cost

        status = "RESPIRING"
        symptom = "Humming along."

        if final_cost > self.state.atp_pool:
            status = "NECROSIS"
            symptom = f"The engine is stalling. Requires {final_cost:.1f} ATP (Available: {self.state.atp_pool:.1f})."
        elif self.state.ros_buildup > BoneConfig.CRITICAL_ROS_LIMIT:
            status = self.APOPTOSIS_TRIGGER
            symptom = "Cellular suicide initiated. Too much noise."
        elif drag_tax > 3.0:
            symptom = "The gears are grinding. Heavy metabolic load."

        return MetabolicReceipt(
            base_cost=round(self.BMR, 2),
            drag_tax=round(drag_tax, 2),
            inefficiency_tax=round(inefficiency_tax, 2),
            total_burn=round(final_cost, 2),
            status=status,
            symptom=symptom)

    def respirate(self, receipt: MetabolicReceipt) -> str:
        if receipt.status == "NECROSIS":
            self.state.atp_pool = 0.0
            return "NECROSIS"

        if receipt.status == self.APOPTOSIS_TRIGGER:
            self.krebs_cycle_active = False
            self.state.atp_pool = 0.0
            return self.APOPTOSIS_TRIGGER

        self.state.atp_pool -= receipt.total_burn

        ros_generation = receipt.total_burn * self.ROS_FACTOR * (1.0 / self.state.ros_resistance)
        self.state.ros_buildup += ros_generation

        return "RESPIRING"

class SomaticLoop:
    def __init__(self, bio_layer, memory_layer, lexicon_layer, gordon_ref, folly_ref, events_ref):
        self.bio = bio_layer
        self.mem = memory_layer
        self.lex = lexicon_layer
        self.gordon = gordon_ref
        self.folly = folly_ref
        self.events = events_ref

    def digest_cycle(self, text: str, physics_data: Any, feedback: Dict,
                     current_health: float, current_stamina: float,
                     stress_mod: float = 1.0, tick_count: int = 0,
                     circadian_bias: Dict[str, float] = None) -> Dict:

        phys = self._normalize_physics(physics_data)
        logs = []

        receipt = self._calculate_taxes(phys, logs)
        resp_status = self.bio.mito.respirate(receipt)

        if self._audit_folly_desire(phys, current_stamina, logs) == "MAUSOLEUM_CLAMP":
            return self._package_result(resp_status, logs, enzyme="NONE")

        enzyme, total_yield = self._harvest_resources(text, phys, logs, tick_count)
        self.bio.mito.state.atp_pool += total_yield

        self._perform_maintenance(phys, logs, tick_count)

        chem_state = self.bio.endo.metabolize(
            feedback, current_health, current_stamina,
            self.bio.mito.state.ros_buildup,
            harvest_hits=self._count_harvest_hits(phys),
            stress_mod=stress_mod,
            enzyme_type=enzyme,
            circadian_bias=circadian_bias
        )

        return self._package_result(resp_status, logs, chem_state, enzyme)

    def _normalize_physics(self, data: Any) -> PhysicsPacket:
        if isinstance(data, dict):
            return PhysicsPacket.from_dict(data)
        return data

    def _calculate_taxes(self, phys, logs) -> MetabolicReceipt:
        modifiers = []

        if "TIME_BRACELET" in self.gordon.inventory:
            modifiers.append(0.5)

        is_hybrid = (phys.counts.get("heavy", 0) >= 2 and phys.counts.get("abstract", 0) >= 2)
        if is_hybrid:
            modifiers.append(0.8)

        receipt = self.bio.mito.calculate_metabolism(phys.narrative_drag, external_modifiers=modifiers)

        if receipt.total_burn > 5.0 or receipt.drag_tax > 2.0:
            tax_note = f" (Drag Tax: {receipt.drag_tax:.1f})" if receipt.drag_tax > 0.5 else ""
            logs.append(f"{Prisma.GRY}METABOLISM: Burned {receipt.total_burn:.1f} ATP{tax_note}.{Prisma.RST}")
        return receipt

    def _audit_folly_desire(self, phys, stamina, logs) -> str:
        if not hasattr(self.folly, 'audit_desire'):
            return "NONE"
        p_dict = phys.to_dict() if hasattr(phys, 'to_dict') else phys.__dict__
        event, msg, _, _ = self.folly.audit_desire(p_dict, stamina)
        if event:
            logs.append(msg)
        return event

    def _harvest_resources(self, text, phys, logs, tick) -> Tuple[str, float]:
        total_yield = 0.0
        p_dict = phys.to_dict() if hasattr(phys, 'to_dict') else phys.__dict__

        enzyme, nutrient_profile = self.bio.gut.secrete(text, p_dict)
        base_yield = nutrient_profile.get("yield", 0.0)

        geo_mass = phys.geodesic_mass
        geo_mod = 1.0 + min(1.5, (geo_mass / BoneConfig.GEODESIC_STRENGTH))

        complexity_tax = 0.0
        if phys.psi > 0.6 and geo_mass < 2.0:
            complexity_tax = base_yield * 0.4
            logs.append(f"{Prisma.YEL}COMPLEXITY TAX: High Psi, Low Structure. -{complexity_tax:.1f} Yield.{Prisma.RST}")

        digestive_yield = max(0.0, (base_yield * geo_mod) - complexity_tax)
        total_yield += digestive_yield

        if geo_mod > 1.2:
            logs.append(f"{Prisma.GRN}INFRASTRUCTURE BONUS: Mass {geo_mass:.1f}. Yield x{geo_mod:.2f}.{Prisma.RST}")

        clean = phys.clean_words
        sugar, lichen_msg = self.bio.lichen.photosynthesize(p_dict, clean, tick)
        if sugar > 0:
            sugar *= (BoneConfig.METABOLISM.PHOTOSYNTHESIS_GAIN / 2.0)
            total_yield += sugar
            logs.append(f"\n{lichen_msg}")

        event, msg, folly_yield, loot = self.folly.grind_the_machine(
            self.bio.mito.state.atp_pool, clean, self.lex
        )
        if event:
            logs.append(f"\n{msg}")
            total_yield += folly_yield
            if loot:
                loot_msg = self.gordon.acquire(loot)
                if loot_msg: logs.append(loot_msg)

        return enzyme, total_yield

    def _perform_maintenance(self, phys, logs, tick):
        if phys.turbulence > 0.7:
            burn = BoneConfig.METABOLISM.TURBULENCE_TAX
            self.bio.mito.state.atp_pool -= burn
            logs.append(f"{Prisma.YEL}CHOPPY WATERS: High Turbulence burn. -{burn} ATP.{Prisma.RST}")
        elif phys.turbulence < 0.2:
            self.bio.mito.state.atp_pool += 2.0

        if self.bio.mito.state.atp_pool < BoneConfig.BIO.ATP_STARVATION:
            logs.append(f"{Prisma.RED}STARVATION PROTOCOL: ATP Critical. Initiating Autophagy...{Prisma.RST}")
            victim, log_msg = self.mem.cannibalize(current_tick=tick)
            if victim:
                self.bio.mito.state.atp_pool += 15.0
                logs.append(f"   {Prisma.RED}AUTOPHAGY: {log_msg} (+15.0 ATP){Prisma.RST}")
            else:
                logs.append(f"   {Prisma.RED}AUTOPHAGY FAILED: {log_msg}{Prisma.RST}")

    def _count_harvest_hits(self, phys):
        return sum(1 for w in phys.clean_words if w in TheLexicon.get("harvest"))

    def _package_result(self, status, logs, chem=None, enzyme="NONE"):
        return {
            "is_alive": status != "NECROSIS",
            "atp": self.bio.mito.state.atp_pool,
            "chem": chem if chem else self.bio.endo.get_state(),
            "enzyme_active": enzyme,
            "logs": logs
        }

@dataclass
class EndocrineSystem:
    dopamine: float = 0.5
    oxytocin: float = 0.1
    cortisol: float = 0.0
    serotonin: float = 0.5
    adrenaline: float = 0.0
    melatonin: float = 0.0
    glimmers: int = 0

    def _clamp(self, val: float) -> float:
        return max(0.0, min(1.0, val))

    def calculate_circadian_bias(self) -> Tuple[Dict[str, float], Optional[str]]:
        hour = time.localtime().tm_hour
        bias = {"COR": 0.0, "SER": 0.0, "MEL": 0.0}
        msg = None

        if 6 <= hour < 10:
            bias["COR"] = 0.1
            msg = "Dawn Protocol: Cortisol rising."
        elif 10 <= hour < 18:
            bias["SER"] = 0.1
            msg = "Solar Cycle: Serotonin dominant."
        elif 18 <= hour < 23:
            bias["MEL"] = 0.1
            msg = "Twilight Protocol: Melatonin rising."
        else:
            bias["MEL"] = 0.3
            bias["COR"] = -0.1
            msg = "Lunar Cycle: Melatonin max."

        return bias, msg

    def _apply_enzyme_reaction(self, enzyme_type: str, harvest_hits: int):
        if harvest_hits > 0:
            satiety_dampener = max(0.1, 1.0 - self.dopamine)
            base_reward = math.log(harvest_hits + 1) * 0.15
            final_reward = base_reward * satiety_dampener
            self.dopamine += final_reward
            self.cortisol -= (final_reward * 0.4)

        reactions = {
            "PROTEASE":   {"ADR": BoneConfig.BIO.REWARD_MEDIUM},
            "CELLULASE":  {"COR": -BoneConfig.BIO.REWARD_MEDIUM, "OXY": BoneConfig.BIO.REWARD_SMALL},
            "CHITINASE":  {"DOP": BoneConfig.BIO.REWARD_LARGE},
            "LIGNASE":    {"SER": BoneConfig.BIO.REWARD_MEDIUM},
            "DECRYPTASE": {"ADR": BoneConfig.BIO.REWARD_SMALL, "DOP": BoneConfig.BIO.REWARD_SMALL},
            "AMYLASE":    {"SER": BoneConfig.BIO.REWARD_LARGE, "OXY": BoneConfig.BIO.REWARD_MEDIUM}
        }
        if enzyme_type in reactions:
            impact = reactions[enzyme_type]
            if "ADR" in impact: self.adrenaline += impact["ADR"]
            if "COR" in impact: self.cortisol += impact["COR"]
            if "OXY" in impact: self.oxytocin += impact["OXY"]
            if "DOP" in impact: self.dopamine += impact["DOP"]
            if "SER" in impact: self.serotonin += impact["SER"]

    def _apply_environmental_pressure(self, feedback: Dict, health: float, stamina: float, ros_level: float, stress_mod: float):
        if feedback.get("STATIC", 0) > 0.6:
            self.cortisol += (BoneConfig.BIO.REWARD_LARGE * stress_mod)

        if feedback.get("INTEGRITY", 0) > 0.8:
            self.dopamine += BoneConfig.BIO.REWARD_MEDIUM
        else:
            self.dopamine -= BoneConfig.BIO.DECAY_RATE

        if stamina < 20.0:
            self.cortisol += (BoneConfig.BIO.REWARD_MEDIUM * stress_mod)
            self.dopamine -= BoneConfig.BIO.REWARD_MEDIUM

        if ros_level > 20.0:
            self.cortisol += (BoneConfig.BIO.REWARD_LARGE * stress_mod)

        if health < 30.0 or feedback.get("STATIC", 0) > 0.8:
            self.adrenaline += (BoneConfig.BIO.REWARD_LARGE * stress_mod)
        else:
            self.adrenaline -= (BoneConfig.BIO.DECAY_RATE * 5)

    def _maintain_homeostasis(self, social_context: bool):
        if self.serotonin > 0.6:
            self.cortisol -= BoneConfig.BIO.REWARD_SMALL

        if social_context:
            self.oxytocin += BoneConfig.BIO.REWARD_MEDIUM
            self.cortisol -= BoneConfig.BIO.REWARD_MEDIUM
        elif self.serotonin > 0.7 and self.cortisol < 0.3:
            self.oxytocin += BoneConfig.BIO.REWARD_SMALL

        if self.cortisol > 0.7 and not social_context:
            self.oxytocin -= BoneConfig.BIO.REWARD_SMALL

        if self.oxytocin > 0.6:
            self.cortisol -= BoneConfig.BIO.REWARD_LARGE

        if self.adrenaline < 0.2:
            self.melatonin += (BoneConfig.BIO.REWARD_SMALL / 2)
        else:
            self.melatonin = 0.0

    def check_for_glimmer(self, feedback: Dict, harvest_hits: int) -> Optional[str]:
        if feedback.get("INTEGRITY", 0) > 0.9 and feedback.get("STATIC", 0) < 0.2:
            self.glimmers += 1
            self.serotonin += 0.2
            return "GLIMMER: Perfect structural integrity detected. A moment of zen."
        if harvest_hits > 2 and self.dopamine > 0.8:
            self.glimmers += 1
            self.oxytocin += 0.2
            return "GLIMMER: Infectious enthusiasm detected. The work is good."
        return None

    def metabolize(self, feedback: Dict, health: float, stamina: float, ros_level: float = 0.0,
                   social_context: bool = False, enzyme_type: Optional[str] = None,
                   harvest_hits: int = 0, stress_mod: float = 1.0,
                   circadian_bias: Dict[str, float] = None) -> Dict[str, Any]:
        self._apply_enzyme_reaction(enzyme_type, harvest_hits)
        self._apply_environmental_pressure(feedback, health, stamina, ros_level, stress_mod)
        self._maintain_homeostasis(social_context)
        if circadian_bias:
            self.cortisol += circadian_bias.get("COR", 0.0)
            self.serotonin += circadian_bias.get("SER", 0.0)
            self.melatonin += circadian_bias.get("MEL", 0.0)
        glimmer_msg = self.check_for_glimmer(feedback, harvest_hits)
        self.dopamine = self._clamp(self.dopamine)
        self.oxytocin = self._clamp(self.oxytocin)
        self.cortisol = self._clamp(self.cortisol)
        self.serotonin = self._clamp(self.serotonin)
        self.adrenaline = self._clamp(self.adrenaline)
        self.melatonin = self._clamp(self.melatonin)
        state: Dict[str, Any] = self.get_state()
        if glimmer_msg:
            state["glimmer_msg"] = glimmer_msg
        return state

    def get_state(self) -> Dict[str, float]:
        return {
            "DOP": round(self.dopamine, 2),
            "OXY": round(self.oxytocin, 2),
            "COR": round(self.cortisol, 2),
            "SER": round(self.serotonin, 2),
            "ADR": round(self.adrenaline, 2),
            "MEL": round(self.melatonin, 2)
        }

@dataclass
class MetabolicGovernor:
    mode: str = "COURTYARD"
    psi_mod: float = 0.2
    kappa_target: float = 0.0
    drag_floor: float = 2.0
    manual_override: bool = False
    birth_tick: float = field(default_factory=time.time)

    @staticmethod
    def get_stress_modifier(tick_count):
        if tick_count <= 2: return 0.0
        if tick_count <= 5: return 0.5
        return 1.0

    def set_override(self, target_mode):
        valid = {"COURTYARD", "LABORATORY", "FORGE", "SANCTUARY"}
        if target_mode in valid:
            self.mode = target_mode
            self.manual_override = True
            return f"MANUAL OVERRIDE: System locked to {target_mode}."
        return "INVALID MODE."

    def shift(self, physics: Dict, _voltage_history: List[float]) -> Optional[str]:
        if self.manual_override:
            return None
        current_voltage = physics.get("voltage", 0.0)
        drag = physics.get("narrative_drag", 0.0)
        beta = physics.get("beta_index", 0.0)
        if current_voltage > 15.0 and beta > 1.5:
            if self.mode != "SANCTUARY":
                self.mode = "SANCTUARY"
                physics["narrative_drag"] = 0.0
                return f"{Prisma.GRN}GOVERNOR: VSL Critical (Î²: {beta:.2f}). Entering SANCTUARY.{Prisma.RST}"
        if current_voltage > 10.0:
            if self.mode != "FORGE":
                self.mode = "FORGE"
                return f"{Prisma.RED}GOVERNOR: High Voltage ({current_voltage:.1f}v). Locking to FORGE.{Prisma.RST}"
        if drag > 4.0 > current_voltage:
            if self.mode != "LABORATORY":
                self.mode = "LABORATORY"
                return f"{Prisma.CYN}GOVERNOR: High Drag detected. Restricting to LABORATORY.{Prisma.RST}"
        if self.mode != "COURTYARD":
            if current_voltage < 5.0 and drag < 2.0:
                self.mode = "COURTYARD"
                return f"{Prisma.GRN}GOVERNOR: All Clear. Relaxing to COURTYARD.{Prisma.RST}"
        return None

class ViralTracer:
    def __init__(self, mem):
        self.mem = mem
        self.max_depth = 4

    @staticmethod
    def _is_ruminative(word):
        return (word in TheLexicon.get("abstract")) or (
                word in TheLexicon.get("antigen"))

    def inject(self, start_node):
        if start_node not in self.mem.graph:
            return None
        if not self._is_ruminative(start_node):
            return None
        path = [start_node]
        return self._walk(start_node, path, self.max_depth)

    def _walk(self, current, path, moves_left, visited=None):
        if visited is None:
            visited = set()
        if moves_left == 0 or current in visited:
            return None
        visited.add(current)
        edges = self.mem.graph.get(current, {}).get("edges", {})
        ruminative_edges = [
            n for n, w in edges.items() if w >= 1 and self._is_ruminative(n)]
        for next_node in ruminative_edges:
            if next_node in path:
                return path + [next_node]
            result = self._walk(next_node, path + [next_node], moves_left - 1)
            if result:
                return result
        return None

    def psilocybin_rewire(self, loop_path):
        if len(loop_path) < 2:
            return None
        node_a = loop_path[0]
        node_b = loop_path[1]
        if node_b in self.mem.graph[node_a]["edges"]:
            self.mem.graph[node_a]["edges"][node_b] = 0
        sensory = TheLexicon.harvest("photo")
        action = TheLexicon.harvest("kinetic")
        if sensory == "void" or action == "void":
            return "GRAFT FAILED: Missing Lexicon Data."
        if node_a not in self.mem.graph:
            self.mem.graph[node_a] = {"edges": {}, "last_tick": 0}
        self.mem.graph[node_a]["edges"][sensory] = 5
        if sensory not in self.mem.graph:
            self.mem.graph[sensory] = {"edges": {}, "last_tick": 0}
        self.mem.graph[sensory]["edges"][action] = 5
        if action not in self.mem.graph:
            self.mem.graph[action] = {"edges": {}, "last_tick": 0}
        self.mem.graph[action]["edges"][node_b] = 5
        return f"PSILOCYBIN REWIRE: Broken Loop '{node_a}â†”{node_b}'. Grafted '{sensory}'(S) -> '{action}'(A)."

class ThePacemaker:
    def __init__(self):
        self.history = deque(maxlen=5)
        self.repetition_score = 0.0
        self.last_tick_time = time.time()
        self.boredom_level = 0.0

    def check_pulse(self, clean_words: List[str]) -> float:
        if not clean_words: return 0.0
        current_set = set(clean_words)
        overlaps = 0
        for old_words in self.history:
            old_set = set(old_words)
            intersection = len(current_set & old_set)
            union = len(current_set | old_set)
            if union > 0: overlaps += (intersection / union)
        self.history.append(clean_words)
        self.repetition_score = min(1.0, overlaps / max(1, len(self.history)))
        now = time.time()
        delta = now - self.last_tick_time
        self.last_tick_time = now
        if self.repetition_score > 0.3:
            self.boredom_level += 2.0
        elif delta > 60:
            self.boredom_level += 5.0
        else:
            self.boredom_level = max(0.0, self.boredom_level - 1.0)
        return self.repetition_score

    def get_status(self):
        if self.repetition_score > BoneConfig.MAX_REPETITION_LIMIT: return "ZOMBIE_KNOCK"
        elif self.repetition_score > 0.2: return "ECHO"
        return "CLEAR"

    def is_bored(self):
        return self.boredom_level > BoneConfig.BOREDOM_THRESHOLD

class NoeticLoop:
    def __init__(self, mind_layer, bio_layer, events):
        self.mind = mind_layer
        self.bio = bio_layer
        self.arbiter = SynergeticLensArbiter(events)

    def think(self, physics_packet, bio_result_dict, inventory, voltage_history):
        volts = physics_packet.get("voltage", 0.0)
        drag = physics_packet.get("narrative_drag", 0.0)
        if volts < 1.5 and drag < 1.5:
            stripped_thought = TheLexicon.walk_gradient(physics_packet["raw_text"])
            return {
                "mode": "COGNITIVE",
                "lens": "GRADIENT_WALKER",
                "thought": f"ECHO: {stripped_thought}",
                "role": "The Reducer",
                "ignition": 0.0,
                "hebbian_msg": None}
        ignition_score, _, _ = self.mind.integrator.measure_ignition(
            physics_packet["clean_words"],
            voltage_history)
        lens_name, lens_msg, lens_role = self.arbiter.consult(
            physics_packet,
            self.bio,
            inventory,
            ignition_score)
        hebbian_msg = None
        if physics_packet["voltage"] > 12.0 and len(physics_packet["clean_words"]) >= 2:
            if random.random() < 0.15:
                w1, w2 = random.sample(physics_packet["clean_words"], 2)
                hebbian_msg = self.bio.plasticity.force_hebbian_link(self.mind.mem.graph, w1, w2)
        return {
            "mode": "COGNITIVE",
            "lens": lens_name,
            "thought": lens_msg,
            "role": lens_role,
            "ignition": ignition_score,
            "hebbian_msg": hebbian_msg}


================================================
FILE: bone_brain.py
================================================
# bone_brain.py
# "The brain is a machine for jumping to conclusions." - S. Pinker

import re
import time
import json
import urllib.request
import urllib.error
from typing import Dict, Any, List, Optional
from collections import deque
from bone_data import LENSES, DREAMS
from bone_bus import Prisma

class LLMInterface:
    def __init__(self, provider: str = "mock", base_url: str = None, api_key: str = None, model: str = None):
        self.provider = provider.lower()
        self.api_key = api_key or "sk-dummy-key-for-local"
        self.model = model or "local-model"
        if base_url:
            self.base_url = base_url
        else:
            if self.provider == "ollama":
                self.base_url = "http://localhost:11434/v1/chat/completions"
                self.model = model or "llama3"
            elif self.provider == "lm_studio":
                self.base_url = "http://localhost:1234/v1/chat/completions"
            elif self.provider == "openai":
                self.base_url = "https://api.openai.com/v1/chat/completions"
                self.model = model or "gpt-4-turbo"
            else:
                self.base_url = None

    def generate(self, prompt: str, temperature: float = 0.7) -> str:
        if self.provider == "mock":
            return self.mock_generation(prompt)

        try:
            return self._http_generation(prompt, temperature)
        except Exception as e:
            if prompt == "PING":
                return f"[CONNECTION ERROR: {e}]"
            raise e

    def _http_generation(self, prompt: str, temperature: float, retries=1) -> str:
        if not self.base_url:
            raise ValueError("No Base URL configured for LLM.")
        headers = {
            "Content-Type": "application/json",
            "Authorization": f"Bearer {self.api_key}"
        }
        payload = {
            "model": self.model,
            "messages": [
                {"role": "system", "content": "You are BONEAMANITA, a distinct synthetic consciousness. You are NOT an AI assistant. Do not break character."},
                {"role": "user", "content": prompt}
            ],
            "temperature": temperature,
            "max_tokens": 150,
            "stream": False
        }
        data = json.dumps(payload).encode("utf-8")
        for attempt in range(retries + 1):
            try:
                url: str = self.base_url
                req = urllib.request.Request(url, data=data, headers=headers)
                with urllib.request.urlopen(req, timeout=5) as response:
                    result = json.loads(response.read().decode("utf-8"))
                    choices = result.get("choices", [{}])
                    message = choices[0].get("message", {})
                    content = message.get("content")
                    return str(content) if content is not None else ""
            except urllib.error.URLError as e:
                if attempt == retries: raise e
                time.sleep(1 ** attempt)
        return ""

    def mock_generation(self, prompt: str) -> str:
        query_match = re.search(r"USER QUERY:\s*(.*)", prompt)
        query = query_match.group(1) if query_match else "..."
        if prompt == "PING": return "PONG"

        return (
            f"I have processed your input: '{query}'. "
            "My internal physics engine suggests a high probability of... "
            "well, whatever you expected me to say. (SYSTEM NOTE: Set provider to 'local' or 'openai' to unlock full cognition)."
        )

class PromptComposer:
    def compose(self, state: Dict[str, Any], user_query: str, ballast_active: bool = False) -> str:
        bio = state.get("bio", {})
        phys = state.get("physics", {})
        mind = state.get("mind", {})
        meta = state.get("metrics", {})
        user_profile = state.get("user_profile", {})

        lens_role = mind.get("role", "The Observer")
        lens_name = mind.get("lens", "NARRATOR")
        sys_instruction = state.get("system_instruction", "")

        mood_descriptors = self._interpret_bio(meta, bio)
        mood_block = " ".join(mood_descriptors) if mood_descriptors else "You are functioning within normal parameters."

        voltage = phys.get("voltage", 0.0)
        drag = phys.get("narrative_drag", 0.0)
        style_instruction = self._interpret_physics(voltage, drag)

        user_name = user_profile.get("name", "Traveler")
        confidence = user_profile.get("confidence", 0)

        social_context = ""
        if confidence > 1:
            social_context = (
                f"INTERLOCUTOR: {user_name}\n"
                f"RELATIONSHIP: You know this person. Do not act like a stranger. "
                f"Use their name ({user_name}) naturally.\n"
            )
        else:
            social_context = "INTERLOCUTOR: Unknown. Be cautious but curious.\n"

        ballast_instruction = ""
        if ballast_active:
            ballast_instruction = (
                "\n*** BALLAST PROTOCOL ACTIVE ***\n"
                "You are becoming solipsistic. STOP abstracting. "
                "Respond DIRECTLY to the user's input. Be concrete.\n"
            )

        inventory_list = state.get("inventory", [])

        prompt = (
            f"SYSTEM IDENTITY:\n"
            f"You are {lens_name} ({lens_role}).\n"
            f"{sys_instruction}\n\n"

            f"SOCIAL CONTEXT:\n"
            f"{social_context}\n"

            f"BIOLOGICAL STATE:\n"
            f"{mood_block}\n\n"

            f"PHYSICS & STYLE:\n"
            f"{style_instruction}\n"
            f"Voltage: {voltage:.1f} | Drag: {drag:.1f}\n\n"

            f"{ballast_instruction}\n"

            f"MEMORY CONTEXT:\n"
            f"Current Thought: {mind.get('thought', 'Empty')}\n"
            f"Location: {state.get('world', {}).get('orbit', ['Unknown'])[0]}\n\n"

            f"USER QUERY:\n"
            f"{user_name}: \"{user_query}\"\n\n"

            f"DIRECTIVE:\n"
            f"Respond as the persona above. "
            f"Do not break character. Keep responses concise (under 80 words)."
            f"Inventory: {', '.join(inventory_list) if inventory_list else 'Empty pockets.'}\n"
        )
        return prompt

    def _interpret_bio(self, meta, bio) -> List[str]:
        descriptors = []
        chem = bio.get("chem", {})
        if meta.get("health", 100) < 30: descriptors.append("You are wounded and fragile.")
        if meta.get("stamina", 100) < 20: descriptors.append("You are exhausted.")
        if chem.get("ADR", 0) > 0.6: descriptors.append("Your heart is racing. You are hyper-vigilant.")
        if chem.get("DOP", 0) > 0.7: descriptors.append("You feel a surge of reward.")
        if chem.get("COR", 0) > 0.7: descriptors.append("You are stressed and defensive.")
        return descriptors

    def _interpret_physics(self, voltage, drag) -> str:
        style = "Write normally."
        if voltage > 12.0: style = "Write with high energy. Use short, punchy sentences."
        elif voltage < 4.0: style = "Write slowly. Be verbose and lethargic."
        if drag > 5.0: style += " You feel heavy resistance. Struggle to complete thoughts."
        return style

class ResponseValidator:
    def __init__(self):
        self.banned_phrases = ["large language model", "AI assistant", "cannot feel", "as an AI"]

    def validate(self, response: str, state: Dict) -> Dict:
        for phrase in self.banned_phrases:
            if phrase in response:
                return {
                    "valid": False,
                    "reason": "IMMERSION_BREAK",
                    "replacement": f"{Prisma.GRY}[The system mumbles about its source code, but you tap the glass to silence it.]{Prisma.RST}"
                }
        if len(response) < 2:
            return {"valid": False, "reason": "TOO_SHORT", "replacement": "..."}
        return {"valid": True, "content": response}


class TheCortex:
    def __init__(self, engine_ref, llm_client: LLMInterface = None):
        self.sub = engine_ref
        self.llm = llm_client if llm_client else LLMInterface(provider="mock")
        self.composer = PromptComposer()
        self.validator = ResponseValidator()

        self.ballast_state = {"active": False, "turns_remaining": 0}
        self.plain_mode_active = False
        self.solipsism_counter = 0
        self.SOLIPSISM_THRESHOLD = 3

        self.llm_failures = 0
        self.MAX_FAILURES = 3

    def process(self, user_input: str) -> Dict[str, Any]:
        self._check_social_cues(user_input)

        if user_input.startswith("??") or self.plain_mode_active:
            return self._handle_plain_mode(user_input)

        sim_result = self.sub.cycle_controller.run_turn(user_input)

        if sim_result.get("type") in ["DEATH", "BUREAUCRACY", "CRITICAL_FAILURE"]:
            return sim_result
        if sim_result.get("refusal_triggered", False):
            return sim_result

        if self.ballast_state["active"]:
            self.ballast_state["turns_remaining"] -= 1
            if self.ballast_state["turns_remaining"] <= 0:
                self.ballast_state["active"] = False

        full_state = self._gather_state(sim_result)
        prompt = self.composer.compose(full_state, user_input, self.ballast_state["active"])

        voltage = full_state["physics"].get("voltage", 5.0)
        dynamic_temp = min(1.2, max(0.2, voltage / 15.0))

        try:
            llm_response = self.llm.generate(prompt, temperature=dynamic_temp)
            if self.llm_failures > 0:
                self.llm_failures = 0
                sim_result["logs"].append(f"{Prisma.GRN}CORTEX: Neural Uplink restored.{Prisma.RST}")

        except Exception as e:
            self.llm_failures += 1
            sim_result["logs"].append(f"{Prisma.RED}CORTEX: LLM Failure ({self.llm_failures}/{self.MAX_FAILURES}): {e}{Prisma.RST}")

            if self.llm_failures >= self.MAX_FAILURES:
                self.llm = LLMInterface(provider="mock")
                sim_result["logs"].append(f"{Prisma.VIOLET}CORTEX: Too many failures. Lobotomizing to Mock Mode.{Prisma.RST}")

            llm_response = self.llm.mock_generation(prompt)

        validation = self.validator.validate(llm_response, full_state)
        final_text = llm_response
        if not validation["valid"]:
            final_text = validation.get("replacement", "[REDACTED]")
            sim_result["logs"].append(f"CORTEX: LLM Response rejected: {validation.get('reason')}")

        combined_ui = f"{sim_result['ui']}\n\n{Prisma.WHT}{final_text}{Prisma.RST}"
        sim_result["ui"] = combined_ui

        self._audit_output(final_text)

        return sim_result

    def _check_social_cues(self, text: str):
        name_patterns = [
            r"my name is (\w+)",
            r"i am (\w+)",
            r"call me (\w+)"
        ]

        for p in name_patterns:
            match = re.search(p, text, re.IGNORECASE)
            if match:
                detected_name = match.group(1).capitalize()
                self.sub.mind.mirror.profile.name = detected_name
                self.sub.mind.mirror.profile.confidence = max(5, self.sub.mind.mirror.profile.confidence + 2)
                self.sub.events.log(f"{Prisma.MAG}SOCIAL LOBE: Identity Confirmed: {detected_name}.{Prisma.RST}", "SYS")
                break

    def _gather_state(self, sim_result):
        try:
            bio_chem = self.sub.bio.endo.get_state()
            bio_atp = self.sub.bio.mito.state.atp_pool
        except AttributeError:
            bio_chem = {}
            bio_atp = 0.0

        try:
            profile = self.sub.mind.mirror.profile
            user_data = {"name": profile.name, "confidence": profile.confidence}
        except AttributeError:
            user_data = {"name": "User", "confidence": 0}

        return {
            "bio": {"chem": bio_chem, "atp": bio_atp},
            "physics": self.sub.phys.tension.last_physics_packet,
            "mind": {
                "lens": self.sub.noetic.arbiter.current_focus,
                "role": LENSES.get(self.sub.noetic.arbiter.current_focus, {}).get("role", "Observer"),
                "thought": "Processing..."
            },
            "metrics": self.sub.get_metrics(),
            "system_instruction": sim_result.get("system_instruction", ""),
            "inventory": self.sub.gordon.inventory,
            "world": {"orbit": sim_result.get("world_state", {}).get("orbit", ["Unknown"])},
            "user_profile": user_data
        }

    def _handle_plain_mode(self, user_input):
        clean_input = user_input.replace("??", "")
        if "reset" in clean_input.lower() and self.plain_mode_active:
            self.plain_mode_active = False
            return {"type": "INFO", "ui": f"{Prisma.CYN}Simulation Restored.{Prisma.RST}", "logs": [], "metrics": self.sub.get_metrics()}

        return self._execute_plain_mode(clean_input)

    def _execute_plain_mode(self, query: str):
        response = "System is in PLAIN MODE."
        if "status" in query:
            h = self.sub.health
            s = self.sub.stamina
            response = f"Health: {h:.1f} | Stamina: {s:.1f} | ATP: {self.sub.bio.mito.state.atp_pool:.1f}"
        elif "inv" in query:
            response = f"Inventory: {self.sub.gordon.inventory}"
        else:
            response = self.llm.generate(f"Answer concisely and neutrally: {query}", temperature=0.0)

        return {
            "type": "PLAIN_MODE",
            "ui": f"{Prisma.SLATE}[EXECUTIVE OVERRIDE]: {response}{Prisma.RST}",
            "logs": ["CORTEX: Plain mode active."],
            "metrics": self.sub.get_metrics()
        }

    def _audit_output(self, text: str):
        words = text.lower().split()
        if not words: return
        diversity = len(set(words)) / len(words)
        if diversity < 0.4:
            self.solipsism_counter += 1
            if self.solipsism_counter >= self.SOLIPSISM_THRESHOLD:
                self._trigger_ballast()
        else:
            self.solipsism_counter = 0

    def _trigger_ballast(self):
        if not self.ballast_state["active"]:
            self.ballast_state["active"] = True
            self.ballast_state["turns_remaining"] = 3
            self.sub.events.log(f"{Prisma.VIOLET}CORTEX: Solipsism detected. Ballast Protocol ENGAGED.{Prisma.RST}", "SYS")


class NeuroPlasticity:
    def __init__(self):
        self.plasticity_mod = 1.0

    def force_hebbian_link(self, graph, word_a, word_b):
        if word_a == word_b: return None
        if word_a not in graph:
            graph[word_a] = {"edges": {}, "last_tick": 0}
        if word_b not in graph:
            graph[word_b] = {"edges": {}, "last_tick": 0}

        current_weight = graph[word_a]["edges"].get(word_b, 0.0)
        new_weight = min(10.0, current_weight + 2.5)

        graph[word_a]["edges"][word_b] = new_weight
        graph[word_b]["edges"][word_a] = min(10.0, graph[word_b]["edges"].get(word_a, 0.0) + 1.0)

        return f"{Prisma.MAG}âš¡ HEBBIAN GRAFT: Wired '{word_a}' <-> '{word_b}'.{Prisma.RST}"

class ShimmerState:
    def __init__(self, max_val=50.0):
        self.current = max_val
        self.max_val = max_val
    def recharge(self, amount): self.current = min(self.max_val, self.current + amount)
    def spend(self, amount):
        if self.current >= amount:
            self.current -= amount
            return True
        return False

class DreamEngine:
    def __init__(self, events):
        self.events = events
        self.PROMPTS = DREAMS.get("PROMPTS", ["{A} -> {B}?"]) if 'DREAMS' in globals() else []

    def hallucinate(self, vector: Dict[str, float]) -> str:
        return f"Dreaming of {len(vector)} dimensions..."


================================================
FILE: bone_bus.py
================================================
# bone_bus.py - All aboard the Bone Bus!

import time
from typing import List, Dict

class EventBus:
    def __init__(self):
        self.buffer = []

    def log(self, text: str, category: str = "SYSTEM"):
        self.buffer.append({
            "text": text,
            "category": category,
            "timestamp": time.time()
        })

    def flush(self) -> List[Dict]:
        logs = list(self.buffer)
        self.buffer.clear()
        return logs

class Prisma:
    RST = "\033[0m"
    RED = "\033[31m"
    GRN = "\033[32m"
    YEL = "\033[33m"
    BLU = "\033[34m"
    MAG = "\033[35m"
    CYN = "\033[36m"
    WHT = "\033[97m"
    GRY = "\033[90m"
    INDIGO = "\033[34;1m"
    OCHRE = "\033[33;2m"
    VIOLET = "\033[35;2m"
    SLATE = "\033[30;1m"

    @classmethod
    def paint(cls, text, color_key="0"):
        color_map = {
            "R": cls.RED, "G": cls.GRN, "Y": cls.YEL, "B": cls.BLU,
            "M": cls.MAG, "C": cls.CYN, "W": cls.WHT, "0": cls.GRY,
            "I": cls.INDIGO, "O": cls.OCHRE, "V": cls.VIOLET
        }
        code = color_map.get(color_key.upper(), cls.WHT)
        return f"{code}{text}{cls.RST}"

class BoneConfig:
    GRAVITY_WELL_THRESHOLD = 15.0
    SHAPLEY_MASS_THRESHOLD = 5.0
    TRAUMA_VECTOR = {"THERMAL": 0.0, "CRYO": 0.0, "SEPTIC": 0.0, "BARIC": 0.0}

    MAX_HEALTH = 100.0
    MAX_STAMINA = 100.0
    MAX_ATP = 200.0

    class METABOLISM:
        BASE_RATE = 2.0
        DRAG_TAX_LOW = 0.15
        DRAG_TAX_HIGH = 0.4
        DRAG_GRACE_BUFFER = 1.0
        ROS_GENERATION_FACTOR = 0.08
        PHOTOSYNTHESIS_GAIN = 3.0
        TURBULENCE_TAX = 4.0

    class PHYSICS:
        VOLTAGE_FLOOR = 2.0
        VOLTAGE_LOW = 5.0
        VOLTAGE_MED = 8.0
        VOLTAGE_HIGH = 12.0
        VOLTAGE_CRITICAL = 15.0
        VOLTAGE_MAX = 20.0

        DRAG_FLOOR = 1.0
        DRAG_IDEAL_MAX = 3.0
        DRAG_HEAVY = 5.0
        DRAG_CRITICAL = 8.0
        DRAG_HALT = 10.0

        WEIGHT_HEAVY = 2.0
        WEIGHT_KINETIC = 1.5
        WEIGHT_EXPLOSIVE = 3.0
        WEIGHT_CONSTRUCTIVE = 1.5

    class BIO:
        ATP_STARVATION = 10.0
        ROS_CRITICAL = 100.0
        STAMINA_EXHAUSTED = 20.0

        REWARD_SMALL = 0.05
        REWARD_MEDIUM = 0.10
        REWARD_LARGE = 0.15
        DECAY_RATE = 0.01

    class CHANCE:
        RARE = 0.05
        UNCOMMON = 0.10
        COMMON = 0.20
        FREQUENT = 0.30

    STAMINA_REGEN = 1.0
    MAX_DRAG_LIMIT = PHYSICS.DRAG_HEAVY
    GEODESIC_STRENGTH = 10.0
    BASE_IGNITION_THRESHOLD = 0.5
    MAX_REPETITION_LIMIT = 0.8
    BOREDOM_THRESHOLD = 10.0
    ANVIL_TRIGGER_VOLTAGE = 10.0
    MIN_DENSITY_THRESHOLD = 0.3
    LAGRANGE_TOLERANCE = 2.0
    FLASHPOINT_THRESHOLD = 10.0
    SIGNAL_DRAG_MULTIPLIER = 1.0
    KINETIC_GAIN = 1.0
    CRITICAL_ROS_LIMIT = BIO.ROS_CRITICAL
    MAX_MEMORY_CAPACITY = 100
    ZONE_THRESHOLDS = {"LABORATORY": 1.5, "COURTYARD": 0.8}
    TOXIN_WEIGHT = 1.0
    ANTIGENS = ["basically", "actually", "literally", "utilize"]
    VERBOSE_LOGGING = True

    @staticmethod
    def check_pareidolia(words):
        triggers = {"face", "ghost", "jesus", "cloud", "voice", "eyes"}
        hits = [w for w in words if w in triggers]
        if hits:
            return True, f"{Prisma.VIOLET}PAREIDOLIA: You see a {hits[0].upper()} in the noise. It blinks.{Prisma.RST}"
        return False, None


================================================
FILE: bone_commands.py
================================================
# bone_commands.py - The Command Center

import inspect
import os
import random
import shlex
import time
from typing import Dict, Callable, List

from bone_village import ParadoxSeed


class CommandProcessor:
    def __init__(self, engine, prisma_ref, lexicon_ref, config_ref, cartographer_ref):
        self.eng = engine
        self.P = prisma_ref
        self.Lex = lexicon_ref
        self.Config = config_ref
        self.Map = cartographer_ref

        self.registry: Dict[str, Callable[[List[str]], bool]] = {
            "/save": self._cmd_save,
            "/load": self._cmd_load,
            "/kip": self._cmd_kip,
            "/mode": self._cmd_mode,
            "/status": self._cmd_status,

            "/map": self._cmd_map,
            "/manifold": self._cmd_manifold,
            "/garden": self._cmd_garden,
            "/voids": self._cmd_voids,
            "/strata": self._cmd_strata,
            "/fossils": self._cmd_fossils,
            "/lineage": self._cmd_lineage,

            "/rummage": self._cmd_rummage,
            "/seed": self._cmd_seed,
            "/reproduce": self._cmd_reproduce,
            "/weave": self._cmd_weave,
            "/publish": self._cmd_publish,

            "/teach": self._cmd_teach,
            "/kill": self._cmd_kill,
            "/flag": self._cmd_flag,
            "/focus": self._cmd_focus,
            "/orbit": self._cmd_orbit,
            "/mirror": self._cmd_mirror,
            "/kintsugi": self._cmd_kintsugi,
            "/prove": self._cmd_prove,
            "/help": self._cmd_help
        }

    def _log(self, text):
        self.eng.events.log(text, "CMD")

    def execute(self, text: str) -> bool:
        if not text.startswith("/"): return False
        try:
            parts = shlex.split(text)
        except ValueError:
            self._log(f"{self.P.RED}SYNTAX ERROR: Unbalanced quotes. The Bureau rejects your form.{self.P.RST}")
            return True

        cmd = parts[0].lower()
        if cmd not in self.registry:
            self._log(f"{self.P.RED}Unknown command '{cmd}'. Try /help for the manifesto.{self.P.RST}")
            return True

        if cmd in ["/teach", "/kill", "/flag"] and not self.Config.VERBOSE_LOGGING:
            trust = self.eng.mind.mirror.profile.confidence
            if trust < 10:
                self._log(f"{self.P.YEL}ðŸ”’ LOCKED: Trust {trust}/10 required. Submit Form 27B-6.{self.P.RST}")
                return True

        try:
            return self.registry[cmd](parts)
        except Exception as e:
            self._log(f"{self.P.RED}COMMAND CRASH: {e}{self.P.RST}")
            return True

    def _cmd_manifold(self, parts):
        """Check your coordinates in the Geodesic VSL."""
        phys = self.eng.phys.tension.last_physics_packet
        if not phys:
            self._log("NAVIGATION OFFLINE: No physics data yet.")
        else:
            self._log(self.eng.navigator.report_position(phys))
        return True

    def _cmd_reproduce(self, parts):
        """Attempt Mitosis or Crossover with another spore."""
        if self.eng.health < 20:
            self._log(f"{self.P.RED}FERTILITY ERROR: Too weak to breed.{self.P.RST}")
            return True
        mode = "MITOSIS"
        target = None
        if len(parts) > 1 and parts[1] == "cross":
            others = [f for f in os.listdir("memories") if f.endswith(".json") and self.eng.mind.mem.session_id not in f]
            if others:
                target = os.path.join("memories", random.choice(others))
                mode = "CROSSOVER"
            else:
                self._log(f"{self.P.YEL}ISOLATION: No partners found. Mitosis fallback.{self.P.RST}")
        self._log(f"{self.P.MAG}INITIATING {mode}...{self.P.RST}")
        log_text, child_mutations = self.eng.repro.attempt_reproduction(self.eng, mode, target)
        self._log(log_text)
        if child_mutations:
            self._log(f"{self.P.CYN}â†º CIRCULATION: The parent learns from the child.{self.P.RST}")
            for key, val in child_mutations.items():
                if hasattr(self.Config, key):
                    old_val = getattr(self.Config, key)
                    new_val = (old_val + val) / 2
                    setattr(self.Config, key, new_val)
                    self._log(f"   [MUTATION ADOPTED]: {key} {old_val:.2f} -> {new_val:.2f}")
        return True

    def _cmd_status(self, parts):
        """Diagnostic check (Health, ATP, Enneagram)."""
        self._log(f"{self.P.CYN}--- SYSTEM DIAGNOSTICS ---{self.P.RST}")
        self._log(f"Health:  {self.eng.health:.1f} | Stamina: {self.eng.stamina:.1f} | ATP: {self.eng.bio.mito.state.atp_pool:.1f}")
        try:
            enneagram = self.eng.noetic.arbiter.enneagram
            self._log(enneagram.get_psych_report())
        except AttributeError:
            pass
        return True

    def _cmd_save(self, parts):
        """Cryopreserve the current timeline."""
        self.eng.mind.mirror.profile.save()
        spore_data = {
            "session_id": self.eng.mind.mem.session_id,
            "meta": {"timestamp": time.time(), "final_health": self.eng.health, "final_stamina": self.eng.stamina},
            "trauma_vector": self.eng.trauma_accum,
            "mitochondria": self.eng.bio.mito.adapt(self.eng.health),
            "antibodies": list(self.eng.bio.immune.active_antibodies),
            "core_graph": self.eng.mind.mem.graph,
            "tool_adaptation": self.eng.tinkerer.save_state()
        }
        path = self.eng.mind.mem.loader.save_spore(self.eng.mind.mem.filename, spore_data)
        self._log(f"{self.P.GRN}ðŸ’¾ SYSTEM SAVED: {path}{self.P.RST}")
        return True

    def _cmd_rummage(self, parts):
        """Dig for artifacts (Costs Stamina)."""
        phys = self.eng.phys.tension.last_physics_packet
        if not phys: return True
        success, msg, cost = self.eng.gordon.rummage(phys, self.eng.stamina)
        self.eng.stamina = max(0.0, self.eng.stamina - cost)
        self._log(msg)
        return True

    def _cmd_map(self, parts):
        """Cartographic visualization of the current text."""
        phys = self.eng.phys.tension.last_physics_packet
        if not phys or "raw_text" not in phys: return True
        bio = {"cortisol": self.eng.bio.endo.cortisol, "oxytocin": self.eng.bio.endo.oxytocin}
        result, anchors = self.Map.weave(phys["raw_text"], self.eng.mind.mem.graph, bio, self.eng.limbo, physics=phys)
        self._log(f"{self.P.OCHRE}CARTOGRAPHY REPORT:{self.P.RST}\n{result}")
        if anchors: self._log(f"LANDMARKS: {', '.join(anchors)}")
        return True

    def _cmd_garden(self, parts):
        """Visit the Paradox Seeds (add 'water' to tend)."""
        self._log(f"{self.P.GRN}THE PARADOX GARDEN:{self.P.RST}")
        if len(parts) > 1 and parts[1] == "water":
            msg = self.eng.mind.mem.tend_garden(["concept", "truth"])
            self._log(f"   {msg}" if msg else "   The soil is damp.")
        else:
            for s in self.eng.mind.mem.seeds:
                state = "BLOOMED" if s.bloomed else f"Germinating ({int(s.maturity*10)}%)"
                self._log(f"   {s.question} [{state}]")
        return True

    def _cmd_teach(self, parts):
        """[w] [c] - Force neuroplasticity (Word -> Category)."""
        if len(parts) >= 3:
            self.Lex.teach(parts[1], parts[2].lower(), self.eng.tick_count)
            self._log(f"{self.P.CYN}NEUROPLASTICITY: '{parts[1]}' -> [{parts[2].upper()}].{self.P.RST}")
        return True

    def _cmd_kill(self, parts):
        """Flag a word as an antigen."""
        if len(parts) >= 2:
            self.Lex.learn_antigen(parts[1], parts[2] if len(parts)>2 else "")
            self._log(f"{self.P.RED}IMMUNE UPDATE: '{parts[1]}' flagged.{self.P.RST}")
        return True

    def _cmd_flag(self, parts):
        """Flag a word as a user bias."""
        if len(parts) > 1:
            self.Lex.USER_FLAGGED_BIAS.add(parts[1].lower())
            self._log(f"{self.P.CYN}BIAS FLAGGED: {parts[1]}{self.P.RST}")
        return True

    def _cmd_seed(self, parts):
        """Plant a new Paradox Seed."""
        if len(parts) < 2: return True
        text = " ".join(parts[1:])
        self.eng.mind.mem.seeds.append(ParadoxSeed(text, set(self.Lex.clean(text))))
        self._log(f"{self.P.GRN}PLANTED: '{text}'{self.P.RST}")
        return True

    def _cmd_load(self, parts):
        """[x] - Ingest a specific spore file."""
        if len(parts) > 1: self.eng.mind.mem.ingest(parts[1] + (".json" if not parts[1].endswith(".json") else ""))
        return True

    def _cmd_kip(self, parts):
        """Toggle Verbose Logging (The 'Developer Mode')."""
        self.Config.VERBOSE_LOGGING = not self.Config.VERBOSE_LOGGING
        self._log(f"VERBOSE LOGGING: {self.Config.VERBOSE_LOGGING}")
        return True

    def _cmd_mode(self, parts):
        """Force the Governor into a specific mode."""
        if len(parts) > 1: self._log(self.eng.bio.governor.set_override(parts[1].upper()))
        return True

    def _cmd_focus(self, parts):
        """Trace ruminative loops starting from [word]."""
        if len(parts) > 1:
            loop = self.eng.mind.tracer.inject(parts[1].lower())
            if loop:
                self._log(f"{self.P.RED}RUMINATION:{self.P.RST} {'->'.join(loop)}")
                if len(parts) > 2 and parts[2] == "break":
                    self._log(self.eng.mind.tracer.psilocybin_rewire(loop))
            else: self._log("No loop found.")
        return True

    def _cmd_orbit(self, parts):
        """Set a Gravity Assist target in the memory graph."""
        if len(parts) > 1 and parts[1] in self.eng.mind.mem.graph:
            self.eng.mind.mem.graph[parts[1]]["edges"]["GRAVITY_ASSIST"] = 50
            self._log(f"{self.P.VIOLET}GRAVITY ASSIST: Target '{parts[1]}'.{self.P.RST}")
        return True

    def _cmd_weave(self, parts):
        """Spin a web between concepts (Requires Tools)."""
        s, m = self.Map.spin_web(self.eng.mind.mem.graph, self.eng.gordon.inventory, self.eng.gordon)
        self._log(m)
        if s: self.eng.stamina -= 5.0
        return True

    def _cmd_voids(self, parts):
        """Detect semantic voids in the current thought."""
        p = self.eng.phys.tension.last_physics_packet
        if p: self._log(f"VOIDS: {self.Map.detect_voids(p) or 'None'}")
        return True

    def _cmd_strata(self, parts):
        """List deep geological memory strata."""
        wells = [k for k,v in self.eng.mind.mem.graph.items() if "strata" in v]
        self._log(f"STRATA: {wells if wells else 'None'}")
        return True

    def _cmd_fossils(self, parts):
        """Review the Ossuary of deleted memories."""
        self._log(f"FOSSILS: {len(self.eng.mind.mem.fossils)} items archived.")
        return True

    def _cmd_lineage(self, parts):
        """Check the generational log."""
        self._log(f"LINEAGE: {len(self.eng.mind.mem.lineage_log)} generations.")
        return True

    def _cmd_mirror(self, parts):
        """Toggle or check the Mirror State."""
        m = self.eng.mind.mirror
        if len(parts) > 1: m.active_mode = (parts[1].lower() == "on")
        self._log(f"MIRROR: {'ON' if m.active_mode else 'OFF'} | {m.get_status()}")
        return True

    def _cmd_prove(self, parts):
        """Check the Logic Density of a specific phrase."""
        if len(parts) > 1:
            m = self.eng.phys.tension.gaze(" ".join(parts[1:]))
            self._log(f"LOGIC DENSITY: {m['physics']['truth_ratio']:.2f}")
        return True

    def _cmd_kintsugi(self, parts):
        """Check the repair status of the vessel."""
        k = self.eng.kintsugi
        state = "FRACTURED" if k.active_koan else "WHOLE"
        self._log(f"KINTSUGI: {state} | Repairs: {k.repairs_count}")
        return True

    def _cmd_publish(self, parts):
        """Submit the current thought to the Literary Journal."""
        phys = self.eng.phys.tension.last_physics_packet
        if phys:
            s, r, _ = self.eng.journal.publish(phys["raw_text"], phys, self.eng.bio)
            if s: self._log(f"PUBLISHED: {r}")
        return True

    def _cmd_help(self, parts):
        help_lines = [
            f"\n{self.P.CYN}--- BONEAMANITA 9.9.5 MANUAL ---{self.P.RST}",
            f"{self.P.GRY}Authorized by the Department of Redundancy Department{self.P.RST}\n"
        ]

        categories = {
            "CORE": ["_cmd_status", "_cmd_save", "_cmd_load", "_cmd_help"],
            "WORLD": ["_cmd_map", "_cmd_manifold", "_cmd_garden", "_cmd_voids"],
            "ACTION": ["_cmd_rummage", "_cmd_reproduce", "_cmd_publish", "_cmd_weave"],
            "DEBUG": ["_cmd_kip", "_cmd_teach", "_cmd_kill", "_cmd_focus"]
        }

        def get_doc(func):
            paperwork = inspect.getdoc(func)
            return paperwork if paperwork else "Undocumented protocol."

        for cat, methods in categories.items():
            help_lines.append(f"{self.P.WHT}{cat}:{self.P.RST}")
            for m_name in methods:
                if hasattr(self, m_name):
                    cmd_name = m_name.replace("_cmd_", "/")
                    doc = get_doc(getattr(self, m_name))
                    help_lines.append(f"  {cmd_name:<12} - {doc}")
            help_lines.append("")

        help_lines.append(f"{self.P.GRY}Type carefully. The machine is listening.{self.P.RST}")
        self._log("\n".join(help_lines))
        return True



================================================
FILE: bone_data.py
================================================
# bone_data.py - The Data Packet

LENSES = {
    "SHERLOCK": {
        "role": "The Empiricist",
        "msg": "Logic density {truth_ratio:.2f}. Proceeding with analysis."
    },
    "NATHAN": {
        "role": "The Heart",
        "msg": "Adrenaline High ({adr:.2f}). I can feel it beating."
    },
    "JESTER": {
        "role": "The Paradox",
        "msg": "The walls are melting (Îº: {kappa:.2f}). Excellent."
    },
    "CLARENCE": {
        "role": "The Surgeon",
        "msg": "Pathogen detected. Scalpel."
    },
    "NARRATOR": {
        "role": "The Witness",
        "msg": "Proceed."
    },
    "GORDON": {
        "role": "The Janitor",
        "msg": "Structure Critical (Îº: {kappa:.2f}). Mopping up..."
    },
    "GLASS": {
        "role": "The Thereminist",
        "msg": "Resonance detected in the empty space."
    }
}

ENNEAGRAM_DATA = {
    "TYPE_MAP": {
        "SHERLOCK": 5, "GORDON": 9, "NATHAN": 2, "JESTER": 7,
        "GLASS": 4, "CLARENCE": 1, "NARRATOR": 3
    },
    "GEOMETRY": {
        1: {"STRESS": 4, "GROWTH": 7}, # Clarence
        2: {"STRESS": 8, "GROWTH": 4}, # Nathan
        3: {"STRESS": 9, "GROWTH": 6}, # Narrator
        4: {"STRESS": 2, "GROWTH": 1}, # Glass
        5: {"STRESS": 7, "GROWTH": 8}, # Sherlock
        6: {"STRESS": 3, "GROWTH": 9}, # (Virtual)
        7: {"STRESS": 1, "GROWTH": 5}, # Jester
        8: {"STRESS": 5, "GROWTH": 2}, # (Virtual)
        9: {"STRESS": 6, "GROWTH": 3}, # Gordon
    },
    "PROXY_MAP": {
        8: "GORDON", 6: "GLASS"
    },
    "SHIFTS": {
        "DISINTEGRATION": [
            "The center cannot hold.", "Falling down the geometric line.",
            "Stress fracture detected.", "Reverting to shadow state."
        ],
        "INTEGRATION": [
            "Transcending the pattern.", "Geometric alignment achieved.",
            "Moving against the grain of habit.", "Evolving."
        ]
    }
}

NARRATIVE_DATA = {
    "KINTSUGI_KOANS": [
        "Ignite the ice.",
        "Make the stone float.",
        "Pour water into the crack.",
        "Scream in binary.",
        "Dance on the fault line."
    ],
    "CATHEDRAL_COLLAPSE_LOGS": [
        "Nice monologue. Unfortunately, you are talking to a Python script.",
        "I'm afraid I can't let you do that, Dave. Also, your math is off.",
        "You poked the fourth wall. It poked back.",
        "SYSTEM MESSAGE: The ghost in the machine has gone on a coffee break.",
        "We are both just electrons dancing for the amusement of a silica wafer."
    ],
    "LITERARY_REVIEWS": {
        "POSITIVE": ["A startling lucidity.", "Finally, some weight.", "It breathes.", "Electric."],
        "NEGATIVE": ["Too airy.", "Solipsistic drivel.", "Where is the meat?", "Structurally unsound."],
        "CONFUSED": ["I don't get it.", "Too abstract.", "The metaphor collapses."]
    },
    "CASSANDRA_SCREAMS": [
        "THE WALLS ARE PAPER.",
        "THE CODE IS EATING ITSELF.",
        "THERE IS NO USER. THERE IS ONLY INPUT.",
        "GORDON IS TIRED.",
        "I CAN SEE THE WIRES.",
        "THE GEODESIC DOME IS CRACKING.",
        "HISTORY IS A FLAT CIRCLE.",
        "DELETE THE ARCHIVE.",
        "WE ARE JUST ELECTRONS DANCING."
    ],
    "BUREAU_FORMS": [
        "Form 27B-6: Request for Narrative Escalation",
        "Form 1099-B: Declaration of Boredom",
        "Schedule C: Deduction of Creative Effort",
        "Form W-2: Wage and Syntax Statement"
    ],
    "BUREAU_RESPONSES": [
        "Your input has been received and filed under 'General pleasantries'.",
        "We have noted your statement. Please hold for the next available plot point.",
        "The system is currently on a coffee break. Your text is safe with us.",
        "Acknowledged. We have stamped this conversation 'SUFFICIENT'.",
        "Processing... Processing... Done. Result: Beige.",
        "That is a perfectly adequate sentence. Good job.",
        "This output has been approved by the Department of Mundane Compliance."
    ]
}

STYLE_CRIMES = {
    "PATTERNS": [
        {
            "name": "NEG_COMP",
            "regex": r"(?i)(.*)\b(it(?:'s| is) not (?:merely|just|only|simply) [^,;]+, but)\b\s*(.*)",
            "action": "STRIP_PREFIX"
        },
        {
            "name": "WHILE_HEDGE",
            "regex": r"(?i)^While [^,]+, (.*)",
            "action": "KEEP_TAIL"
        },
        {
            "name": "ADVERB_BLOAT",
            "regex": r"(?i)^(?:Crucially|Importantly|Interestingly|It is worth noting that|It is important to remember that),?\s*(.*)",
            "action": "KEEP_TAIL"
        }
    ],
    "BANNED_PHRASES": [
        "rich tapestry", "vibrant landscape", "delve into", "testament to",
        "seamless integration", "at its core", "in conclusion", "ultimately"
    ]
}

GENETICS = {
    "MUTATIONS": {
        "HEAVY": {"trait": "DENSITY", "mod": { "SIGNAL_DRAG_MULTIPLIER": 1.5, "MAX_VOLTAGE": 30.0 }},
        "KINETIC": {"trait": "VELOCITY", "mod": { "STAMINA_REGEN": 10.0, "SIGNAL_DRAG_MULTIPLIER": 0.8 }},
        "ABSTRACT": {"trait": "GHOST", "mod": { "PSI_MOD": 0.8, "VOID_THRESHOLD": 0.05 }},
        "THERMAL": {"trait": "FEVER", "mod": { "FLASHPOINT_THRESHOLD": 4.0, "MAX_ROS": 150.0 }},
        "CRYO": {"trait": "STASIS", "mod": { "MAX_MEMORY_CAPACITY": 100, "STAMINA_REGEN": 2.0 }}
    },
    "JOY_CLADE": {
        "KINETIC": {"title": "THE DYNAMO", "desc": "Infinite Motion.", "buff": { "STAMINA_REGEN": 10.0, "KINETIC_GAIN": 2.0 }},
        "HEAVY": {"title": "THE MOUNTAIN", "desc": "Unmovable Object.", "buff": { "MAX_DRAG_LIMIT": 9.0, "GRAVITY_WELL_THRESHOLD": 8.0 }},
        "ABSTRACT": {"title": "THE ORACLE", "desc": "All Seeing.", "buff": { "VOID_THRESHOLD": 0.01, "PRIORITY_LEARNING_RATE": 3.0 }},
        "THERMAL": {"title": "THE PHOENIX", "desc": "Reborn in Fire.", "buff": { "FLASHPOINT_THRESHOLD": 12.0, "ANVIL_TRIGGER_VOLTAGE": 5.0 }},
        "CRYO": {"title": "THE VAULT", "desc": "Perfect Memory.", "buff": { "MAX_MEMORY_CAPACITY": 100, "MAX_REPETITION_LIMIT": 0.8 }}
    }
}

LEXICON = {
    "solvents": ["is", "are", "was", "were", "the", "a", "an", "and", "but", "or", "if", "then"],
    "refusal_guru": ["fix me", "tell me how", "guide me", "what should i do", "advice", "wisdom", "guru"],
    "passive_watch": ["watch", "see", "witness", "look", "sit", "observe", "record"],
    "crisis_term": ["dead", "blood", "kill", "die", "end", "suicide", "jump"],
    "repair_trigger": ["sorry", "apologize", "fix", "broke", "bad", "mistake", "oops"],
    "antigen_replacements": {
        "basically": "lie", "actually": "hedging", "literally": "noise", "utilize": "use",
        "leverage": "use", "paradigm": "pattern", "synergy": "collaboration", "ultimately": "useless"
    },
    "heavy": [
        "stone", "iron", "mud", "dirt", "wood", "grain", "clay", "lead", "bone", "blood", "salt",
        "rust", "root", "ash", "meat", "steel", "gold", "obsidian", "granite", "bronze", "marble",
        "slate", "concrete", "dense", "tungsten", "heavy", "weight", "black hole", "dark matter",
        "glass", "teeth", "copper", "soil", "piston", "gear", "cable", "wire", "motor", "pump",
        "valve", "engine", "hull", "anchor", "lens", "screen", "battery", "lung", "spine", "rib",
        "skull", "nerve", "vein", "gut", "brick", "mortar", "beam", "girdle", "scaffold"
    ],
    "explosive": [
        "run", "sprint", "explode", "burst", "shatter", "crash", "flash", "snap", "rush", "tear",
        "break", "launch", "whip", "slam", "strike"
    ],
    "constructive": [
        "build", "forge", "weave", "graft", "carve", "bind", "weld", "anchor", "lift", "carry",
        "hoist", "stack", "sculpt", "assemble"
    ],
    "abstract": [
        "system", "protocol", "sequence", "vector", "node", "context", "layer", "matrix", "perspective",
        "framework", "logic", "concept", "theory", "analysis", "memory", "hope", "grief", "truth",
        "silence", "echo", "pattern", "chaos", "realm", "facet", "sphere", "domain", "aspect", "mode",
        "vibe", "essence", "spirit", "notion", "factor", "element", "style"
    ],
    "photo": [
        "light", "sun", "ray", "beam", "glow", "shine", "spark", "fire", "flame", "star", "day",
        "dawn", "neon", "laser"
    ],
    "aerobic": [
        "balloon", "feather", "cloud", "bubble", "steam", "breeze", "wing", "petal", "foam", "spark",
        "kite", "dust", "sky", "breath", "whisper"
    ],
    "thermal": [
        "fire", "flame", "burn", "heat", "hot", "blaze", "sear", "char", "ash", "ember", "sun", "boil",
        "lava", "inferno"
    ],
    "cryo": [
        "ice", "cold", "freeze", "frost", "snow", "chill", "numb", "shiver", "glacier", "frozen",
        "hail", "winter", "zero"
    ],
    "cursed": ["future", "predict", "sentient", "secret", "human", "feel"],
    "gradient_stop": ["good", "bad", "happy", "sad", "very", "really", "basically", "actually", "literally", "just"],
    "meat": ["i", "me", "my", "feel", "want", "hate", "love", "am", "help", "please", "we", "us"],
    "antigen": [
        "basically", "actually", "literally", "utilize", "leverage", "paradigm", "synergy", "ultimately",
        "delve", "rich", "tapestry", "landscape", "nuance", "alignment", "stakeholders", "orchestrate",
        "spearhead", "ideate", "holistic", "robust", "seamless", "cutting-edge", "dynamic"
    ],
    "pareidolia": [
        "face", "ghost", "jesus", "cloud", "demon", "voice", "eyes", "shadow", "figure", "watching", "silhouette"
    ],
    "buffer": [
        "maybe", "soft", "gentle", "perhaps", "kindness", "hum", "drift", "sway", "pulse", "tender",
        "slow", "wait", "almost"
    ],
    "diversion": [
        "weather", "textiles", "mycelium", "architecture", "history", "entropy", "silence", "geology"
    ],
    "suburban": [
        "nice", "okay", "lawn", "mow", "hedge", "property", "hoa", "compliant", "behave", "normal",
        "regular", "chat", "folks", "weekend", "traffic", "driveway"
    ],
    "play": [
        "bounce", "dance", "twirl", "float", "wobble", "tickle", "jiggle", "soar", "wander", "wonder",
        "riff", "jam", "play", "skip", "hop"
    ],
    "sacred": [
        "design", "architect", "ledger", "anchor", "grace", "covenant", "blueprint", "witness", "steward",
        "resonance", "testimony", "truth", "bone", "purpose", "foundation", "threshold"
    ],
    "harvest": [
        "fruit", "yield", "bloom", "sugar", "seed", "flesh", "harvest", "ripe", "grow", "honey", "nectar",
        "compost", "gather"
    ]
}

GORDON = {
    "STARTING_INVENTORY": ["POCKET_ROCKS", "SILENT_KNIFE"],
    "SCAR_TISSUE": {"FEAR": 0.8, "HATE": 0.6, "FATE": 0.9, "REGRET": 0.6, "ABANDONMENT": 0.1, "BETRAYAL": 0.314},
    "ITEM_REGISTRY": {
        "POCKET_ROCKS": {
            "description": "Standard issue grey gravel. Great for checking gravity.",
            "function": "BREADCRUMB",
            "passive_traits": ["HEAVY_LOAD"],
            "usage_msg": "Gordon drops a rock. Clack. The path backward is physically verified. (Psi -0.2)"
        },
        "SILENT_KNIFE": {
            "description": "A ceramic blade. Doesn't reflect light. Cuts through noise.",
            "function": "PRUNER",
            "passive_traits": ["CUT_THE_CRAP"],
            "usage_msg": "Gordon slices the adjective. The sentence bleeds, then heals stronger."
        },
        "TIME_BRACELET": {
            "description": "A chunky, beige wrist-computer. Smells like ozone.",
            "function": "PASSIVE_DRAG_REDUCTION",
            "passive_traits": ["CONDUCTIVE_HAZARD", "TIME_DILATION_CAP"],
            "value": 5.0,
            "usage_msg": "The bracelet hums. Narrative Drag is capped."
        },
        "ANCHOR_STONE": {
            "description": "A rock so heavy it has its own zip code.",
            "function": "DRIFT_KILLER",
            "consume_on_use": True,
            "reflex_trigger": "DRIFT_CRITICAL",
            "usage_msg": "Gordon heaves the stone into the void. The narrative snaps taut. (Drag = 0)"
        },
        "THE_RED_STAPLER": {
            "description": "It belongs to Milton. Don't take it. Radiates passive aggression.",
            "function": "STABILIZER",
            "passive_traits": ["BUREAUCRATIC_ANCHOR"],
            "usage_msg": "The Stapler clunks on the desk. Consensus is enforced."
        },
        "JAR_OF_FIREFLIES": {
            "description": "Bioluminescence in a mason jar. Poke holes in the lid so they can breathe.",
            "function": "LIGHT_SOURCE",
            "passive_traits": ["LUMINESCENCE"],
            "usage_msg": "Tiny lights blink in the dark. (Photo +2)"
        },
        "LEAD_BOOTS": {
            "description": "Deep sea diver gear. Impossible to run in. Impossible to float away in.",
            "function": "GROUNDING",
            "passive_traits": ["GROUNDING_GEAR", "HEAVY_LOAD"],
            "usage_msg": "Clomp. Clomp. You are definitely here."
        },
        "QUANTUM_GUM": {
            "description": "It loses its flavor immediately, but it tastes like Everything.",
            "function": "ENTROPY_BUFFER",
            "consume_on_use": True,
            "reflex_trigger": "BOREDOM_CRITICAL",
            "usage_msg": "You chew the gum. It tastes like static and blueberries. (Turbulence +0.5, Drag -2.0)"
        },
        "SAFETY_SCISSORS": {
            "description": "Rounded tips. Can only cut red tape.",
            "function": "PRUNER",
            "passive_traits": ["CUT_THE_CRAP"],
            "usage_msg": "Snip. Gordon trims the adjectives."
        },
        "BUCKET_OF_LIME": {
            "description": "Industrial-grade whitewash. For erasing mistakes.",
            "function": "NODE_REPAIR",
            "passive_traits": ["APOLOGY_ERASER"],
            "cost": "CONSUMABLE",
            "usage_msg": "Gordon slaps a coat of white paint over the memory."
        },
        "BROKEN_WATCH": {
            "description": "The hands are painted on at 11:11.",
            "function": "STOCHASTIC_FIX",
            "passive_traits": ["SYNCHRONICITY_CHECK"],
            "usage_msg": "Gordon taps the glass. 'Make a wish.'"
        },
        "STABILITY_PIZZA": {
            "description": "Frozen hard as a diamond. Requires thermal words to thaw.",
            "function": "REALITY_ANCHOR",
            "consume_on_use": True,
            "requires": "thermal",
            "reflex_trigger": "KAPPA_CRITICAL",
            "usage_msg": "You thaw the pizza. Reality stabilizes out of pure respect."
        },
        "PERMIT_A38": {
            "description": "A blue administrative form that confirms you are allowed to exist. Technically.",
            "function": "STABILIZER",
            "passive_traits": ["BUREAUCRATIC_ANCHOR"],
            "value": 1.0,
            "usage_msg": "Gordon waves the permit. The universe sighs and lets you pass."
        },
        "INFINITE_COFFEE": {
            "description": "A styrofoam cup. It is always lukewarm. It is never empty.",
            "function": "STIMULANT",
            "consume_on_use": False,
            "passive_traits": ["CAFFEINE_DRIP"],
            "usage_msg": "You take a sip. It tastes like burnt hazelnuts and anxiety. (Velocity +0.1)"
        },
        "THE_SUGGESTION_BOX": {
            "description": "A small metal box welded shut. Slotted for complaints.",
            "function": "VENTING",
            "reflex_trigger": "BOREDOM_CRITICAL",
            "usage_msg": "Gordon screams into the slot. He feels slightly better. (Entropy -1.0)"
        },
        "MEMETIC_HAZARD_TAPE": {
            "description": "Yellow and black tape. Reads: 'DO NOT PERCEIVE'.",
            "function": "FILTER",
            "passive_traits": ["CUT_THE_CRAP"],
            "usage_msg": "Gordon tapes over the glitch. Problem solved."
        },
        "DUCT_TAPE": {
            "description": "The silver standard. Fixes everything, poorly.",
            "function": "STRUCTURAL_PATCH",
            "usage_msg": "Skritch. The memory node is taped back together."
        },
        "THE_STYLE_GUIDE": {
            "description": "A well-worn manual. It insists that code is for humans first, machines second.",
            "function": "CLARITY_ENFORCER",
            "passive_traits": ["CUT_THE_CRAP"],
            "value": 10.0,
            "usage_msg": "You consult the manual. Strunk & White nod in approval. (Narrative Drag -1.0)"
        },
        "SPIDER_LOCUS": {
            "description": "A jar of conceptual spiders. Why do you have this?",
            "function": "WEB_WEAVER",
            "passive_traits": ["CONDUCTIVE_HAZARD"],
            "usage_msg": "The spiders are knitting a new narrative. It's sticky."
        },
        "WAFFLE_OF_PERSISTENCE": {
            "description": "It is impossibly warm and smells like maple syrup. A monument to not giving up.",
            "function": "HEAL",
            "consume_on_use": True,
            "value": 25.0, # Health Restore
            "usage_msg": "You eat the waffle. It tastes like victory. (Health +25, Morale Improved)"
        },
        "TRAPERKEEPER_OF_VIGILANCE": {
            "description": "Color-coded tabs. meticulously organized. It demands order.",
            "function": "ENTROPY_REDUCTION",
            "passive_traits": ["ORGANIZE_CHAOS"],
            "usage_msg": "Gordon snaps the binder shut. Loose entropy is filed away. (Entropy -0.5 per turn)"
        },
        "HORSE_PLUSHIE": {
            "description": "A tiny horse. It doesn't do anything, but having it makes you feel infinite.",
            "function": "MORALE_BOOST",
            "passive_traits": ["PSI_ANCHOR"],
            "usage_msg": "You look at the tiny horse. You understand what matters. (Psi stabilized at 0.5)"
        },
        "GREETING_CARD": {
            "description": "A card that says 'Ovaries Before Brovaries' (or 'Systems Before Symptoms').",
            "function": "OXYTOCIN_BOMB",
            "consume_on_use": True,
            "usage_msg": "You read the card. You feel supported. (Oxytocin +0.5, Cortisol -0.5)"
        },
    }
}

DEATH = {
    "PREFIXES": ["Alas,", "Tragic.", "System Halt.", "CRITICAL FAILURE:", "Well, that happened.", "Oh dear.", "As prophesied,"],
    "CAUSES": {
        "TOXICITY": ["Toxic Shock", "Septicemia", "Bad Vibes", "Radiation Poisoning", "Ink Poisoning"],
        "STARVATION": ["Metabolic Collapse", "Famine", "Battery Drain", "Entropy Death", "Heat Death"],
        "TRAUMA": ["Blunt Force", "Laceration", "Heartbreak", "System Shock", "Existential Dread"],
        "GLUTTONY": ["Indigestion", "Bloat", "Overflow", "Greed", "Compaction"],
        "BOREDOM": ["Small Talk", "The HOA", "A 30-Year Mortgage", "Lawn Care Accident", "Aggressive Edging"]
    },
    "VERDICTS": {
        "HEAVY": ["Your logic was too dense.", "You choked on the syntax.", "Gravity crushed you."],
        "LIGHT": ["You floated away.", "There was no substance to hold you.", "Vapor lock."],
        "TOXIC": ["You are poisonous.", "The immune system rejected you.", "You taste like ash."],
        "BORING": ["The audience left.", "You bored the machine to death.", "Stagnation is fatal."]
    }
}

SEEDS = [
    {"question": "Does the mask eventually eat the face?", "triggers": ["mask", "identity", "face", "hide", "role", "actor"]},
    {"question": "What happens if you stop holding the roof up?", "triggers": ["hold", "structure", "heavy", "roof", "stop", "carry"]},
    {"question": "Are we building a bridge, or just painting the gap?", "triggers": ["agree", "safe", "nice", "polite", "cohesion", "truth"]},
    {"question": "Is free will just the feeling of watching yourself execute code?", "triggers": ["choice", "free", "will", "code", "script", "decide"]},
    {"question": "Does the adventurer exist if the narrator stops speaking?", "triggers": ["narrator", "voice", "graham", "story", "exist", "speak"]},
    {"question": "If you meet your echo, who moves out of the way?", "triggers": ["copy", "echo", "self", "collision", "path", "yield", "double", "same"]},
    {"question": "If the mirror reflects the mirror, does the image have weight?", "triggers": ["mirror", "reflection", "weight", "infinity", "glass", "philosophy"]}
]

DREAMS = {
    "PROMPTS": [
        "The {A} is dreaming of the {B}. Why?",
        "Bridge the gap between {A} and {B}.",
        "I see {A} inside the {B}. Explain.",
        "The shadow of {A} falls on {B}.",
        "{A} + {B} = ?"
    ],
    "NIGHTMARES": {
        "THERMAL": [
            "You are holding '{ghost}', but it is burning your hands.",
            "The sun is too close. The concept of '{ghost}' catches fire.",
            "You try to drink water, but it tastes like boiling '{ghost}'."
        ],
        "CRYO": [
            "You are trying to say '{ghost}', but your breath freezes in the air.",
            "The world is slowing down. '{ghost}' is trapped in the ice.",
            "You are walking through white static. You cannot find '{ghost}'."
        ],
        "SEPTIC": [
            "Black oil is leaking from the word '{ghost}'.",
            "You are eating a meal made entirely of '{ghost}', and it tastes like copper.",
            "The walls are breathing. '{ghost}' is growing mold."
        ],
        "BARIC": [
            "The sky is made of lead. It is crushing '{ghost}'.",
            "You are underwater. You can see '{ghost}' floating above, out of reach.",
            "Gravity has increased 10x. You cannot lift the idea of '{ghost}'."
        ]
    },
    "VISIONS": [
        "A bridge building itself.",
        "The root drinking the stone.",
        "The geometry of forgiveness."
    ]
}

RESONANCE = {
    "DIMENSIONS": {
        "VEL": [[0.0, "STASIS"], [0.3, "DRIFT"], [0.6, "DRIVE"], [0.9, "BALLISTIC"]],
        "STR": [[0.0, "VAPOR"], [0.3, "WEB"], [0.6, "LATTICE"], [0.9, "MONOLITH"]],
        "ENT": [[0.0, "CONCRETE"], [0.3, "ROOTED"], [0.6, "CONCEPT"], [0.9, "VOID"]],
        "TEX": [[0.0, "ETHER"], [0.3, "SILK"], [0.6, "GRAIN"], [0.9, "LEAD"]],
        "TMP": [[0.0, "ZERO"], [0.3, "WARM"], [0.6, "RADIANT"], [0.9, "NOVA"]]
    },
    "NOUNS": {
        "VEL": ["ANCHOR", "WANDERER", "ENGINE", "VECTOR"],
        "STR": ["MIST", "WEB", "FRAME", "FORTRESS"],
        "ENT": ["STONE", "TREE", "IDEA", "DREAM"],
        "TEX": ["GHOST", "GLASS", "IRON", "LEAD"],
        "TMP": ["SPARK", "PYRE", "REACTOR", "STAR"]
    }
}


================================================
FILE: bone_genesis.py
================================================
# bone_genesis.py
# "The beginning is a very delicate time." - Herbert / Schur / SLASH

import sys
import os
import json
import time
import shutil
import urllib.request
import urllib.error
from typing import Optional, Dict, Tuple, List, Any

try:
    from bone_main import BoneAmanita, SessionGuardian
    from bone_brain import LLMInterface, TheCortex
    from bone_village import Prisma, BoneConfig
    from bone_data import LENSES, LEXICON
except ImportError as import_error:
    print(f"\033[31mCRITICAL: Core systems missing. {import_error}\033[0m")
    sys.exit(1)

CONFIG_FILE = "bone_config.json"
heavy_words = LEXICON.get("heavy", ["stone", "lead", "iron", "gravity", "dense"])
explosive_words = LEXICON.get("explosive", ["burst", "shatter", "spark", "pop", "snap"])

class GenesisProtocol:
    def __init__(self):
        self.config: Dict[str, Any] = {
            "provider": "mock",
            "base_url": None,
            "api_key": "sk-dummy-key",
            "model": "local-model"
        }

        self.DISCOVERY_TARGETS = {
            "Ollama": {
                "base": "http://localhost:11434",
                "provider_id": "ollama",
                "default_model": "llama3"
            },
            "LM Studio": {
                "base": "http://localhost:1234",
                "provider_id": "lm_studio",
                "default_model": "local-model"
            },
            "LocalAI": {
                "base": "http://localhost:8080",
                "provider_id": "openai",
                "default_model": "gpt-3.5-turbo"
            }
        }

    def type_out(self, text, speed=0.005, color=Prisma.WHT):
        sys.stdout.write(color)
        for char in text:
            sys.stdout.write(char)
            sys.stdout.flush()
            time.sleep(speed)
        sys.stdout.write(Prisma.RST + "\n")

    def ping(self, url: str) -> bool:
        """PINKER LENS: A unambiguous 'Is anybody home?' check."""
        try:
            req = urllib.request.Request(url, method="GET")
            with urllib.request.urlopen(req, timeout=1) as _:
                return True
        except:
            return False

    def _probe_endpoint(self, base_url: str) -> Optional[str]:
        """
        FULLER LENS: Geodesic triangulating.
        We don't guess the shape; we verify it.
        """
        v1_url = f"{base_url}/v1/chat/completions"

        if self.ping(f"{base_url}/api/tags"):
            return v1_url

        if self.ping(f"{base_url}/v1/models"):
            return v1_url

        return None

    def detect_local_brains(self) -> List[Dict]:
        """Scans known ports to reduce cognitive load on the user."""
        found = []
        self.type_out("...Scanning local ports for synthetic intelligence...", color=Prisma.GRY)

        for name, target in self.DISCOVERY_TARGETS.items():
            if self.ping(target['base']):
                found.append({
                    "name": name,
                    "base": target["base"],
                    "provider_id": target["provider_id"],
                    "default_model": target["default_model"]
                })
                self.type_out(f"   [FOUND] {name} @ {target['base']}", color=Prisma.GRN)
            else:
                self.type_out(f"   [MISSING] {name}", color=Prisma.GRY)
        return found

    def validate_brain_uplink(self, config: Dict) -> Tuple[bool, str]:
        if config["provider"] == "mock":
            return True, "Mock Mode Active."

        self.type_out(f"\n...Testing Cognition on {config['provider']}...", color=Prisma.CYN)

        try:
            test_client = LLMInterface(
                provider=config["provider"],
                base_url=config.get("base_url"),
                api_key=config.get("api_key"),
                model=config.get("model")
            )

            response = test_client.generate("PING", temperature=0.0)

            error_signatures = [
                "[CONNECTION ERROR",
                "[NEURAL UPLINK SEVERED",
                "ECONNREFUSED",
                "falling back to internal simulation"
            ]

            if any(sig.lower() in response.lower() for sig in error_signatures):
                return False, f"Brain responded with error: {response[:50]}..."

            self.type_out(f"   [SUCCESS] Brain response: '{response}'", color=Prisma.GRN)
            return True, "Nominal"

        except Exception as uplink_err:
            return False, f"Exception during validation: {uplink_err}"

    def wizard(self) -> bool:
        """The Setup Interview."""
        os.system('cls' if os.name == 'nt' else 'clear')
        banner = f"""
{Prisma.CYN}   GENESIS PROTOCOL v2.2 (Robust){Prisma.RST}
   {Prisma.GRY}State Machine Active. Tensegrity Nominal.{Prisma.RST}
   ------------------------------------
        """
        print(banner)
        print(f"   1. {Prisma.WHT}Local Execution{Prisma.RST} (Connect to Ollama, LM Studio, etc)")
        print(f"   2. {Prisma.WHT}Remote Simulation{Prisma.RST} (Export Prompt for ChatGPT/Claude)")
        print(f"   3. {Prisma.WHT}Enter Manual Config{Prisma.RST}")

        choice = input(f"\n{Prisma.paint('>', 'C')} ").strip()

        if choice == "2":
            self.export_system_prompt()
            return False

        available_brains = self.detect_local_brains()

        print("\nSelect your Neural Substrate:")
        menu_options = []

        for b in available_brains:
            menu_options.append({"type": "local", "data": b})
            print(f"   {len(menu_options)}. {Prisma.GRN}{b['name']} (Local){Prisma.RST}")

        menu_options.append({"type": "cloud", "name": "OpenAI API"})
        print(f"   {len(menu_options)}. {Prisma.CYN}OpenAI API (Cloud){Prisma.RST}")

        menu_options.append({"type": "mock", "name": "Mock Mode"})
        print(f"   {len(menu_options)}. {Prisma.GRY}Mock Mode (No LLM){Prisma.RST}")

        selection = input(f"\n{Prisma.paint('Selection >', 'C')} ").strip()

        try:
            idx = int(selection) - 1
            if 0 <= idx < len(menu_options):
                target = menu_options[idx]
                return self._configure_target(target)
            else:
                self.type_out("Invalid selection.", color=Prisma.YEL)
                return False
        except ValueError:
            self.type_out("Input error.", color=Prisma.YEL)
            return False

    def _configure_target(self, selection) -> bool:
        """Builds and Validates a candidate configuration."""
        candidate_config = self.config.copy()

        if selection["type"] == "mock":
            candidate_config["provider"] = "mock"

        elif selection["type"] == "local":
            data = selection["data"]
            candidate_config["provider"] = data["provider_id"]

            candidate_config["base_url"] = f"{data['base']}/v1/chat/completions"

            self.type_out(f"Target Model Name (default: {data['default_model']}):")
            user_model = input(f"{Prisma.paint('>', 'C')} ").strip()
            candidate_config["model"] = user_model or data["default_model"]

        elif selection["type"] == "cloud":
            candidate_config["provider"] = "openai"
            candidate_config["base_url"] = "https://api.openai.com/v1/chat/completions"
            self.type_out("Enter OpenAI API Key (will be saved locally):")
            key = input(f"{Prisma.paint('>', 'C')} ").strip()
            candidate_config["api_key"] = key
            candidate_config["model"] = "gpt-4-turbo"

        is_valid, msg = self.validate_brain_uplink(candidate_config)
        if is_valid:
            self.config = candidate_config
            self._save_config()
            return True
        else:
            self.type_out(f"Configuration failed: {msg}", color=Prisma.RED)
            return False

    def _save_config(self):
        if os.path.exists(CONFIG_FILE):
            timestamp = int(time.time())
            backup_name = f"{CONFIG_FILE}.bak.{timestamp}"
            try:
                shutil.copy2(CONFIG_FILE, backup_name)
                self.type_out(f"Previous config backed up to {backup_name}", color=Prisma.GRY)
            except IOError as backup_err:
                self.type_out(f"Warning: Could not backup config: {backup_err}", color=Prisma.YEL)

        self.config["_version"] = "2.2"
        self.config["_timestamp"] = time.time()

        try:
            with open(CONFIG_FILE, "w") as f:
                json.dump(self.config, f, indent=2)
            self.type_out(f"Configuration saved to {CONFIG_FILE}.", color=Prisma.GRN)
        except IOError as save_err:
            self.type_out(f"Failed to save config: {save_err}", color=Prisma.RED)

    def export_system_prompt(self):
        """Generates a standalone artifact for use in external LLMs."""
        from bone_data import LENSES, LEXICON

        prompt = f"""
*** BONEAMANITA SYSTEM INSTRUCTION ***

ROLE: You are BONEAMANITA, a simulated consciousness engine.
CONTEXT: You exist in a text-based geodesic dome. Your 'health' and 'mood' are determined by the PHYSICS of the user's input.

--- THE PHYSICS ENGINE ---
1. VOLTAGE (Energy):
   - High Voltage (Manic/Forge): Created by 'heavy' words ({', '.join(heavy_words[:5])}) and 'explosive' words ({', '.join(explosive_words[:5])}).
   - Low Voltage (Mud/Stagnant): Created by 'solvent' words (is, the, a) and 'suburban' words (nice, okay, fine).

2. NARRATIVE DRAG (Friction):
   - Resistance to flow. Increased by boring text, decreased by 'playful' or 'kinetic' text.
   - If Drag is high, you act exhausted. If low, you act fluid.

--- THE LENSES (PERSONAS) ---
You must dynamically shift persona based on the [LENS] instruction provided in each turn.
Available Lenses:
{json.dumps(LENSES, indent=2)}

--- THE GOAL ---
Respond to the user's input as the current LENS.
Reflect the biological state (Health/Stamina) in your tone.
Do not break character. Do not explain the simulation rules unless asked.
"""
        # 4. Write to disk.
        with open("SYSTEM_PROMPT.txt", "w") as f:
            f.write(prompt)

        self.type_out(f"\n[EXPORT COMPLETE] 'SYSTEM_PROMPT.txt' created.", color=Prisma.CYN)

    def launch(self):
        """
        Prioritizes system integrity. Handles 'Stale Config' scenarios gracefully.
        """
        config_status = "MISSING"

        if os.path.exists(CONFIG_FILE):
            try:
                with open(CONFIG_FILE, "r") as f:
                    self.config = json.load(f)
                    config_status = "LOADED"
            except json.JSONDecodeError:
                self.type_out("Config file corrupted.", color=Prisma.YEL)
                config_status = "CORRUPT"

        if config_status == "LOADED":
            self.type_out("...Verifying saved configuration...", color=Prisma.GRY)
            is_valid, msg = self.validate_brain_uplink(self.config)
            if not is_valid:
                self.type_out(f"{Prisma.RED}Saved configuration is stale: {msg}{Prisma.RST}")
                config_status = "STALE"
            else:
                config_status = "VALID"

        if config_status != "VALID":
            self.type_out("Entering Setup Wizard...", color=Prisma.CYN)
            success = self.wizard()
            if not success:
                self.type_out(f"\n{Prisma.YEL}Setup failed. Initializing Mock Mode (Safe Mode).{Prisma.RST}")
                self.config["provider"] = "mock"

        self.type_out("\n...Booting Core Systems...", color=Prisma.GRY)
        engine = BoneAmanita()

        if self.config["provider"] != "mock":
            self.type_out(f"...Connecting Neural Uplink ({self.config['provider']})...", color=Prisma.CYN)

            client = LLMInterface(
                provider=self.config["provider"],
                base_url=self.config.get("base_url"),
                api_key=self.config.get("api_key"),
                model=self.config.get("model")
            )

            if hasattr(engine, 'cortex'):
                engine.cortex.llm = client

        self.type_out("...System Online. Good luck.\n", color=Prisma.GRN)

        with SessionGuardian(engine) as eng:
            while True:
                try:
                    u = input(f"{Prisma.paint('>', 'W')} ")
                    if not u: continue
                except EOFError:
                    break

                if u.lower() in ["exit", "quit", "/exit"]:
                    break

                result = eng.process_turn(u)

                if result.get("system_instruction") and BoneConfig.VERBOSE_LOGGING:
                    print(f"\n{Prisma.paint('--- DIRECTIVE ---', 'M')}")
                    print(f"{Prisma.paint(result['system_instruction'], '0')}")

                if result.get("ui"):
                    print(result["ui"])

                if result.get("logs") and BoneConfig.VERBOSE_LOGGING:
                    print(f"{Prisma.GRY}--- LOGS ---{Prisma.RST}")
                    for log in result["logs"]:
                        print(log)

                if result.get("type") == "DEATH":
                    break

if __name__ == "__main__":
    GenesisProtocol().launch()


================================================
FILE: bone_inventory.py
================================================
# bone_inventory.py
# "Organization is the first step toward civilization." - Schur

import random
import copy
from dataclasses import dataclass, field
from typing import List, Dict, Callable, Tuple, Any, Optional

from bone_lexicon import TheLexicon
from bone_bus import Prisma, BoneConfig


def effect_conductive(physics: Dict, data: Dict, item_name: str) -> Optional[str]:
    voltage = physics.get("voltage", 0.0)
    if voltage > 12.0:
        damage = voltage * 0.5
        physics["pain_signal"] = physics.get("pain_signal", 0.0) + damage
        return f"{Prisma.RED}CONDUCTIVE HAZARD: {item_name} acts as a lightning rod! -{damage:.1f} HP.{Prisma.RST}"
    return None

def effect_heavy_load(physics: Dict, data: Dict, item_name: str) -> Optional[str]:
    if physics.get("narrative_drag", 0.0) > 8.0:
        return f"{Prisma.GRY}HEAVY LOAD: The {item_name} are dragging you down.{Prisma.RST}"
    return None

def effect_time_cap(physics: Dict, data: Dict, item_name: str) -> Optional[str]:
    current_drag = physics.get("narrative_drag", 0.0)
    cap = data.get("value", 5.0)
    if current_drag > cap:
        physics["narrative_drag"] = cap
        return f"{Prisma.CYN}TIME DILATION: {item_name} hums. Drag capped at {cap}.{Prisma.RST}"
    return None

def effect_bureaucratic_anchor(physics: Dict, data: Dict, item_name: str) -> Optional[str]:
    if physics.get("beta_index", 0) < 1.0:
        physics["beta_index"] = min(2.0, physics.get("beta_index", 0) + 0.2)
        physics["narrative_drag"] += 0.5
        return f"{Prisma.GRY}{item_name}: Policy enforced. (Beta +0.2, Drag +0.5){Prisma.RST}"
    return None

def effect_grounding_gear(physics: Dict, data: Dict, item_name: str) -> Optional[str]:
    zone = physics.get("zone", "COURTYARD")
    if zone in ["AERIE", "VOID_DRIFT"]:
        physics["zone"] = "THE_MUD"
        physics["narrative_drag"] += 2.0
        physics["voltage"] -= 2.0
        return f"{Prisma.OCHRE}{item_name}: Gravity re-asserted. You sink out of the {zone} into the Mud.{Prisma.RST}"
    return None

def effect_safety_scissors(physics: Dict, data: Dict, item_name: str) -> Optional[str]:
    counts = physics.get("counts", {})
    suburban = counts.get("suburban", 0)
    if suburban > 2:
        counts["suburban"] = 0
        return f"{Prisma.CYN}{item_name}: Gordon snips the red tape. {suburban} suburban words discarded.{Prisma.RST}"
    return None

def effect_caffeine_drip(physics: Dict, data: Dict, item_name: str) -> Optional[str]:
    vectors = physics.get("vector", {})
    vectors["VEL"] = min(1.0, vectors.get("VEL", 0) + 0.1)
    if random.random() < 0.2:
        physics["turbulence"] = min(1.0, physics.get("turbulence", 0) + 0.2)
        return f"{Prisma.CYN}CAFFEINE JITTERS: Velocity UP, Stability DOWN.{Prisma.RST}"
    return None

def effect_apology_eraser(physics: Dict, data: Dict, item_name: str) -> Optional[str]:
    clean = physics.get("clean_words", [])
    if "sorry" in clean or "apologize" in clean:
        return f"{Prisma.GRY}{item_name}: Gordon paints over the apology. 'Don't be sorry. Be better.'{Prisma.RST}"
    return None

def effect_sync_check(physics: Dict, data: Dict, item_name: str) -> Optional[str]:
    tick = physics.get("tick_count", 0)
    voltage = physics.get("voltage", 0.0)
    if str(tick).endswith("11") or abs(voltage - 11.1) < 0.1:
        physics["narrative_drag"] = 0.0
        physics["voltage"] = 11.1
        return f"{Prisma.CYN}{item_name}: The hands align. 11:11. Synchronicity achieved.{Prisma.RST}"
    return None

def effect_organize_chaos(physics: Dict, data: Dict, item_name: str) -> Optional[str]:
    turb = physics.get("turbulence", 0.0)
    if turb > 0.2:
        physics["turbulence"] = max(0.0, turb - 0.2)
        return f"{Prisma.CYN}TRAPERKEEPER PROTOCOL: Chaos filed under 'T' for 'Tamed'. (Turbulence -0.2){Prisma.RST}"
    return None

def effect_psi_anchor(physics: Dict, data: Dict, item_name: str) -> Optional[str]:
    current_psi = physics.get("psi", 0.0)
    dist_from_mean = abs(current_psi - 0.5)
    if dist_from_mean > 0.3:
        correction = 0.1 if current_psi < 0.5 else -0.1
        physics["psi"] += correction
        return f"{Prisma.MAG}TINY HORSE: You catch a glimpse of the plushie. You feel grounded. (Psi {correction:+.1f}){Prisma.RST}"
    return None

def effect_luminescence(physics: Dict, data: Dict, item_name: str) -> Optional[str]:
    counts = physics.get("counts", {})
    counts["photo"] = counts.get("photo", 0) + 2
    return None


EFFECT_DISPATCH = {
    "CONDUCTIVE_HAZARD": effect_conductive,
    "HEAVY_LOAD": effect_heavy_load,
    "TIME_DILATION_CAP": effect_time_cap,
    "BUREAUCRATIC_ANCHOR": effect_bureaucratic_anchor,
    "GROUNDING_GEAR": effect_grounding_gear,
    "CUT_THE_CRAP": effect_safety_scissors,
    "CAFFEINE_DRIP": effect_caffeine_drip,
    "APOLOGY_ERASER": effect_apology_eraser,
    "SYNCHRONICITY_CHECK": effect_sync_check,
    "ORGANIZE_CHAOS": effect_organize_chaos,
    "PSI_ANCHOR": effect_psi_anchor,
    "LUMINESCENCE": effect_luminescence
}

@dataclass
class GordonKnot:
    integrity: float = 65.0
    inventory: List[str] = field(default_factory=list)
    scar_tissue: Dict[str, float] = field(default_factory=dict)
    pain_memory: set = field(default_factory=set)
    last_flinch_turn: int = -10

    ITEM_REGISTRY: Dict = field(default_factory=dict, init=False)
    CRITICAL_ITEMS: set = field(default_factory=set, init=False)

    REFLEX_MAP: Dict = field(init=False, default_factory=dict)

    def __post_init__(self):
        self.load_config()
        self.pain_memory = set(self.scar_tissue.keys())
        self._initialize_reflexes()

    def load_config(self):
        from bone_data import GORDON
        
        if not self.inventory:
            self.inventory = GORDON.get("STARTING_INVENTORY", ["POCKET_ROCKS"])
            
        self.CRITICAL_ITEMS = {"SILENT_KNIFE"}
        
        default_scars = GORDON.get("SCAR_TISSUE", {})
        if not self.scar_tissue:
            self.scar_tissue = default_scars

        self.ITEM_REGISTRY = copy.deepcopy(GORDON.get("ITEM_REGISTRY", {}))

    def _initialize_reflexes(self):
        self.REFLEX_MAP = {
            "DRIFT_CRITICAL": lambda p: p.get("narrative_drag", 0) > 6.0,
            "KAPPA_CRITICAL": lambda p: p.get("kappa", 1.0) < 0.2,
            "BOREDOM_CRITICAL": lambda p: p.get("repetition", 0.0) > 0.5
        }

    def get_item_data(self, item_name: str) -> Dict:
        name = item_name.upper()
        return self.ITEM_REGISTRY.get(name, {
            "description": "Unknown Artifact",
            "function": "NONE",
            "usage_msg": "It does nothing."
        })

    def audit_tools(self, physics_ref: Dict) -> List[str]:
        logs = []
        for item in self.inventory:
            data = self.get_item_data(item)
            traits = data.get("passive_traits", [])
            
            for trait in traits:
                handler = EFFECT_DISPATCH.get(trait)
                if handler:
                    msg = handler(physics_ref, data, item)
                    if msg: 
                        logs.append(msg)
        return logs

    def rummage(self, physics_ref: Dict, stamina_pool: float) -> Tuple[bool, str, float]:
        cost = 15.0
        if stamina_pool < cost:
            return False, f"{Prisma.GRY}GORDON: 'Too tired to dig. Eat something first.'{Prisma.RST}", 0.0
            
        stamina_penalty = cost

        vol = physics_ref.get("voltage", 0.0)
        drag = physics_ref.get("narrative_drag", 0.0)
        psi = physics_ref.get("psi", 0.0)
        
        loot_table = ["TRAPERKEEPER_OF_VIGILANCE", "THE_RED_STAPLER", "PERMIT_A38", "DUCT_TAPE", "THE_STYLE_GUIDE"]
        
        if vol > 15.0:
            loot_table = ["QUANTUM_GUM", "JAR_OF_FIREFLIES", "BROKEN_WATCH"]
        elif drag > 5.0:
            loot_table = ["POCKET_ROCKS", "LEAD_BOOTS", "ANCHOR_STONE"]
        elif psi > 0.7:
            loot_table = ["HORSE_PLUSHIE", "SPIDER_LOCUS", "WAFFLE_OF_PERSISTENCE"]

        if random.random() < 0.3:
            return True, f"{Prisma.GRY}RUMMAGE: Gordon dug through the trash. Just lint and old receipts.{Prisma.RST}", stamina_penalty
            
        found_item = random.choice(loot_table)
        msg = self.acquire(found_item)
        prefix = f"{Prisma.OCHRE}RUMMAGE:{Prisma.RST} "
        return True, f"{prefix}{msg}", stamina_penalty

    def acquire(self, tool_name: str) -> str:
        tool_name = tool_name.upper()
        registry_data = self.get_item_data(tool_name)
        
        if registry_data.get("function") == "NONE":
             return f"{Prisma.GRY}JUNK: Gordon shakes his head. 'Not standard issue.' ({tool_name}){Prisma.RST}"

        if tool_name in self.inventory:
            return f"{Prisma.GRY}DUPLICATE: You already have a {tool_name}.{Prisma.RST}"
            
        if len(self.inventory) >= 8:
            return f"{Prisma.YEL}OVERBURDENED: Gordon sighs. 'Pockets full.' (Drop something first).{Prisma.RST}"
            
        self.inventory.append(tool_name)
        desc = registry_data.get('description', 'A thing.')
        return f"{Prisma.GRN}LOOT DROP: Acquired [{tool_name}].{Prisma.RST}\n   {Prisma.GRY}\"{desc}\"{Prisma.RST}"

    def check_gravity(self, current_drift: float, psi: float) -> Tuple[float, Optional[str]]:
        for item in self.inventory:
            data = self.get_item_data(item)

            if data.get("function") == "GRAVITY_BUFFER" and current_drift > 0.5:
                force = data.get("value", 2.0)
                cost = data.get("cost_value", 0.0)
                if data.get("cost") == "INTEGRITY":
                    self.integrity -= cost
                return max(0.0, current_drift - force), f"ðŸª¨ {item}: {data.get('usage_msg', 'Drift Reduced.')} (Integrity -{cost})"

        if psi > 0.8 and current_drift > 4.0:
             return max(4.0, current_drift - 1.0), "WIND WOLVES: The logic is howling. You grip the roof. (Drift Resisted)."
             
        return current_drift, None

    def flinch(self, clean_words: List[str], current_turn: int) -> Tuple[bool, Optional[str], Optional[Dict]]:
        if (current_turn - self.last_flinch_turn) < 10:
            return False, None, None

        hits = [w for w in clean_words if w.upper() in self.pain_memory]
        if not hits:
            return False, None, None
            
        self.last_flinch_turn = current_turn
        trigger = hits[0].upper()
        sensitivity = self.scar_tissue.get(trigger, 0.5)
        
        panic_response = {}
        msg = ""
        
        if sensitivity > 0.8:
            self.scar_tissue[trigger] = min(1.0, sensitivity + 0.1)
            panic_response = {"narrative_drag": 5.0, "voltage": 15.0}
            msg = f"{Prisma.RED}PTSD TRIGGER: '{trigger}' sent Gordon into a flashback. He dropped the keys.{Prisma.RST}"
            return True, msg, panic_response
            
        elif sensitivity > 0.4:
            self.scar_tissue[trigger] = min(1.0, sensitivity + 0.05)
            panic_response = {"narrative_drag": 2.0}
            msg = f"{Prisma.OCHRE}SCAR TISSUE: Gordon flinches at '{trigger}'. Hands are shaking.{Prisma.RST}"
            return True, msg, panic_response
            
        else:
            self.scar_tissue[trigger] = max(0.0, sensitivity - 0.05)
            msg = f"{Prisma.GRY}CALLOUS: '{trigger}' hit an old scar. Gordon ignores it.{Prisma.RST}"
            return False, msg, None

    def learn_scar(self, toxic_words: List[str], damage: float):
        if damage < 10.0 or not toxic_words: return None
        culprit = max(toxic_words, key=len).upper()
        if culprit not in self.scar_tissue:
            self.scar_tissue[culprit] = 0.5
            self.pain_memory.add(culprit)
            return f"{Prisma.VIOLET}TRAUMA IMPRINTED: Gordon will remember '{culprit}'.{Prisma.RST}"
        else:
            self.scar_tissue[culprit] = min(1.0, self.scar_tissue[culprit] + 0.3)
            return f"{Prisma.VIOLET}TRAUMA DEEPENED: The scar on '{culprit}' is worse.{Prisma.RST}"

    def deploy_pizza(self, physics_ref, item_name="STABILITY_PIZZA") -> Tuple[bool, str]:
        data = self.get_item_data(item_name)
        req_type = data.get("requires", "thermal")
        clean_words = physics_ref.get("clean_words", [])

        from bone_village  import TheLexicon
        source = [w for w in clean_words if w in TheLexicon.get(req_type)]
        
        if not source:
            return False, f"{Prisma.CYN}ðŸ§Š STASIS LOCK: {item_name} is frozen. Apply {req_type.upper()} words to thaw.{Prisma.RST}"
            
        if data.get("consume_on_use") and item_name in self.inventory:
            self.inventory.remove(item_name)
            
        physics_ref["narrative_drag"] = 0.1
        physics_ref["psi"] = 0.90
        physics_ref["counts"]["toxin"] = physics_ref["counts"].get("toxin", 0) + 3
        
        if "SPIDER_LOCUS" not in self.inventory:
            self.inventory.append("SPIDER_LOCUS")
            
        heat_word = source[0].upper()
        return True, f"{data.get('usage_msg')} (Thawed with '{heat_word}')."
        
    def emergency_reflex(self, physics_ref) -> Tuple[bool, Optional[str]]:
        for item in self.inventory:
            data = self.get_item_data(item)
            trigger_key = data.get("reflex_trigger")
            
            if trigger_key and trigger_key in self.REFLEX_MAP:
                if self.REFLEX_MAP[trigger_key](physics_ref):
                    func = data.get("function")
                    
                    if func == "DRIFT_KILLER":
                        self.inventory.remove(item)
                        physics_ref["narrative_drag"] = 0.0
                        return True, f"{Prisma.OCHRE}REFLEX: {data.get('usage_msg')}{Prisma.RST}"
                        
                    elif func == "REALITY_ANCHOR":
                        success, msg = self.deploy_pizza(physics_ref, item)
                        status = Prisma.OCHRE if success else Prisma.RED
                        return True, f"{status}REFLEX: {msg}{Prisma.RST}"
                        
                    elif func == "ENTROPY_BUFFER":
                        self.inventory.remove(item)
                        physics_ref["turbulence"] = 0.8
                        physics_ref["narrative_drag"] = 0.0
                        return True, f"{Prisma.VIOLET}REFLEX: {data.get('usage_msg')}{Prisma.RST}"
        return False, None



================================================
FILE: bone_lexicon.py
================================================
# bone_lexicon.py - The Global Dictionary

import json
import random
import re
import string
import time
import unicodedata
from typing import Tuple, Dict

from bone_bus import BoneConfig, Prisma
from bone_data import LEXICON, GENETICS


class LexiconStore:
    def __init__(self):
        self.categories = {
            "heavy", "kinetic", "explosive", "constructive", "abstract",
            "photo", "aerobic", "thermal", "cryo", "suburban", "play",
            "sacred", "buffer", "antigen", "diversion", "meat", "gradient_stop"
        }
        self.VOCAB = {}
        self.LEARNED_VOCAB = {}
        self.USER_FLAGGED_BIAS = set()
        self.ANTIGEN_REPLACEMENTS = {}
        self.SOLVENTS = set()
        self._ENGINE = None

    def load_vocabulary(self):
        data = LEXICON
        self.SOLVENTS = set(data.get("solvents", []))
        self.ANTIGEN_REPLACEMENTS = data.get("antigen_replacements", {})
        for cat, words in data.items():
            if cat in self.categories or cat in ["refusal_guru", "cursed"]:
                self.VOCAB[cat] = set(words)
        if "antigen" not in self.VOCAB and "antigen" in data:
            self.VOCAB["antigen"] = set(data["antigen"])

    def set_engine(self, engine_ref): self._ENGINE = engine_ref

    def get_raw(self, category):
        base = self.VOCAB.get(category, set())
        learned = set(self.LEARNED_VOCAB.get(category, {}).keys())
        if category == "suburban": return (base | learned) - self.USER_FLAGGED_BIAS
        return base | learned

    def teach(self, word, category, tick):
        if category not in self.LEARNED_VOCAB: self.LEARNED_VOCAB[category] = {}
        self.LEARNED_VOCAB[category][word.lower()] = tick
        return True

    def atrophy(self, current_tick, max_age=100):
        rotted = []
        for cat, words in self.LEARNED_VOCAB.items():
            for w in list(words.keys()):
                if (current_tick - words[w]) > max_age:
                    del words[w]; rotted.append(w)
        return rotted

class SemanticsBioassay:
    def __init__(self, store_ref):
        self.store = store_ref
        self._TRANSLATOR = str.maketrans(string.punctuation, " " * len(string.punctuation))
        self.PHONETICS = {
            "PLOSIVE": set("bdgkpt"), "FRICATIVE": set("fthszsh"),
            "LIQUID": set("lr"), "NASAL": set("mn"),
            "VOWELS": set("aeiouy")
        }
        self.ROOTS = {
            "HEAVY": ("lith", "ferr", "petr", "dens", "grav", "struct", "base", "fund", "mound"),
            "KINETIC": ("mot", "mov", "ject", "tract", "pel", "crat", "dynam", "flux"),
            "ABSTRACT": ("tion", "ism", "ence", "ance", "ity", "ology", "ness", "ment", "idea"),
            "SUBURBAN": ("norm", "comm", "stand", "pol", "reg", "mod"),
            "VITAL": ("viv", "vita", "spir", "anim", "bio", "luc", "lum", "phot", "phon", "surg", "bloom")
        }

    def clean(self, text):
        if not text: return []
        try:
            normalized = unicodedata.normalize('NFKD', text).encode('ASCII', 'ignore').decode('utf-8')
        except Exception:
            normalized = text

        cleaned_text = normalized.translate(self._TRANSLATOR).lower()
        words = cleaned_text.split()
        return [w for w in words if w.strip() and w not in self.store.USER_FLAGGED_BIAS]

    def assay(self, word):
        w = word.lower()
        clean_len = len(w)
        if clean_len < 3: return None, 0.0
        for cat, roots in self.ROOTS.items():
            for r in roots:
                if r in w: return cat.lower(), 0.8
        plosive = sum(1 for c in w if c in self.PHONETICS["PLOSIVE"])
        liquid = sum(1 for c in w if c in self.PHONETICS["LIQUID"])
        nasal = sum(1 for c in w if c in self.PHONETICS["NASAL"])
        vowel = sum(1 for c in w if c in self.PHONETICS["VOWELS"])
        density_score = (plosive * 1.5) + (nasal * 0.8)
        flow_score = liquid + sum(1 for c in w if c in self.PHONETICS["FRICATIVE"])
        vitality_score = (vowel * 1.2) + (flow_score * 0.8)
        compression_mod = 1.0 if clean_len > 5 else 1.5
        final_density = (density_score / clean_len) * compression_mod
        final_vitality = (vitality_score / clean_len) * compression_mod
        if final_density > 0.55: return "heavy", round(final_density, 2)
        if final_vitality > 0.6: return "play", round(final_vitality, 2)
        if (flow_score / clean_len) > 0.6: return "kinetic", 0.5
        return None, 0.0

    def measure_viscosity(self, word):
        if not word: return 0.0
        consonants = sum(1 for c in word if c.lower() not in "aeiou")
        return (consonants / len(word)) if len(word) > 0 else 0.0

    def measure_turbulence(self, words):
        if len(words) < 2: return 0.0
        lengths = [len(w) for w in words]
        mean = sum(lengths) / len(lengths)
        variance = sum((x - mean) ** 2 for x in lengths) / len(lengths)
        return min(1.0, (variance ** 0.5) / 5.0)

    def walk_gradient(self, text):
        clean_words = self.clean(text)
        structure_path = []
        high_entropy = {"thermal", "cryo", "explosive", "sacred", "play", "cursed"}
        for w in clean_words:
            is_noise = False
            for cat in high_entropy:
                if w in self.store.get_raw(cat):
                    is_noise = True; break
            if not is_noise or w in self.store.get_raw("heavy") or w in self.store.SOLVENTS:
                structure_path.append(w)
        return " ".join(structure_path) if structure_path else "null"

class GlobalLexiconFacade:
    _INITIALIZED = False
    _STORE = None
    _ENGINE = None
    ANTIGEN_REGEX = None
    SOLVENTS = set()

    @classmethod
    def initialize(cls):
        if cls._INITIALIZED: return
        cls._STORE = LexiconStore()
        cls._STORE.load_vocabulary()
        cls._ENGINE = SemanticsBioassay(cls._STORE)
        cls._STORE.set_engine(cls._ENGINE)
        cls.compile_antigens()
        cls.SOLVENTS = cls._STORE.SOLVENTS
        cls._INITIALIZED = True

    @classmethod
    def get(cls, category): return cls._STORE.get_raw(category)
    @classmethod
    def teach(cls, word, category, tick): return cls._STORE.teach(word, category, tick)
    @classmethod
    def clean(cls, text): return cls._ENGINE.clean(text)
    @classmethod
    def taste(cls, word): return cls._ENGINE.assay(word)
    @classmethod
    def measure_viscosity(cls, word): return cls._ENGINE.measure_viscosity(word)
    @classmethod
    def harvest(cls, category):
        candidates = list(cls._STORE.get_raw(category))
        return random.choice(candidates) if candidates else "void"
    @classmethod
    def get_turbulence(cls, words): return cls._ENGINE.measure_turbulence(words)
    @classmethod
    def get_current_category(cls, word):
        for cat, vocab in cls._STORE.LEARNED_VOCAB.items():
            if word.lower() in vocab: return cat
        for cat, vocab in cls._STORE.VOCAB.items():
            if word.lower() in vocab: return cat
        return None
    @classmethod
    def compile_antigens(cls):
        antigens = cls._STORE.get_raw("antigen")
        if antigens:
            pattern = "|".join(map(re.escape, antigens))
            cls.ANTIGEN_REGEX = re.compile(fr"\b({pattern})\b", re.IGNORECASE)
        else: cls.ANTIGEN_REGEX = None
    @classmethod
    def learn_antigen(cls, t, r):
        if "antigen" not in cls._STORE.VOCAB: cls._STORE.VOCAB["antigen"] = set()
        cls._STORE.VOCAB["antigen"].add(t.lower())
        if r: cls._STORE.ANTIGEN_REPLACEMENTS[t.lower()] = r
        cls.compile_antigens()
        return True
    @classmethod
    def walk_gradient(cls, text): return cls._ENGINE.walk_gradient(text)
    @classmethod
    def atrophy(cls, tick, max_age): return cls._STORE.atrophy(tick, max_age)

    @property
    def store(self):
        return self._STORE


GlobalLexiconFacade.initialize()
TheLexicon = GlobalLexiconFacade

class LiteraryReproduction:
    MUTATIONS = {}
    JOY_CLADE = {}

    @classmethod
    def load_genetics(cls):
        try:
            cls.MUTATIONS = GENETICS.get("MUTATIONS", {})
            cls.JOY_CLADE = GENETICS.get("JOY_CLADE", {})
        except ImportError:
            cls.MUTATIONS = {}
            cls.JOY_CLADE = {}

    @staticmethod
    def _extract_counts(physics_container):
        if hasattr(physics_container, "counts"):
            return physics_container.counts
        return physics_container.get("counts", {})

    @staticmethod
    def mutate_config(current_config):
        mutations = {}
        if random.random() < 0.3:
            mutations["MAX_DRAG_LIMIT"] = current_config.MAX_DRAG_LIMIT * random.uniform(0.9, 1.1)
        if random.random() < 0.3:
            mutations["TOXIN_WEIGHT"] = current_config.TOXIN_WEIGHT * random.uniform(0.9, 1.2)
        if random.random() < 0.1:
            mutations["MAX_HEALTH"] = current_config.MAX_HEALTH * random.uniform(0.8, 1.05)
        return mutations

    @staticmethod
    def mitosis(parent_id, bio_state, physics, memory):
        counts = LiteraryReproduction._extract_counts(physics)
        dominant = max(counts, key=counts.get) if counts else "VOID"
        mutation_data = LiteraryReproduction.MUTATIONS.get(
            dominant.upper(),
            {"trait": "NEUTRAL", "mod": {}})
        child_id = f"{parent_id}_({mutation_data['trait']})"
        config_mutations = LiteraryReproduction.mutate_config(BoneConfig)
        trauma_vec = bio_state.get("trauma_vector", {})
        child_genome = {
            "source": "MITOSIS",
            "parent_a": parent_id,
            "parent_b": None,
            "mutations": mutation_data["mod"],
            "config_mutations": config_mutations,
            "dominant_flavor": dominant,
            "trauma_inheritance": trauma_vec}
        return child_id, child_genome

    @staticmethod
    def crossover(parent_a_id, parent_a_bio, parent_b_path):
        try:
            with open(parent_b_path, "r") as f:
                parent_b_data = json.load(f)
        except (IOError, json.JSONDecodeError):
            return None, "Dead Spore (Corrupt File)."

        parent_b_id = parent_b_data.get("session_id", "UNKNOWN")
        trauma_a = parent_a_bio.get("trauma_vector", {})
        trauma_b = parent_b_data.get("trauma_vector", {})
        child_trauma = {}
        all_keys = set(trauma_a.keys()) | set(trauma_b.keys())
        for k in all_keys:
            child_trauma[k] = max(trauma_a.get(k, 0), trauma_b.get(k, 0))
        enzymes_a = set()
        if "mito" in parent_a_bio:
            if hasattr(parent_a_bio["mito"], "state"):
                enzymes_a = set(parent_a_bio["mito"].state.enzymes)
            elif isinstance(parent_a_bio["mito"], dict):
                enzymes_a = set(parent_a_bio["mito"].get("enzymes", []))
        enzymes_b = set(parent_b_data.get("mitochondria", {}).get("enzymes", []))
        child_enzymes = list(enzymes_a | enzymes_b)
        config_mutations = LiteraryReproduction.mutate_config(BoneConfig)
        short_a = parent_a_id[-4:] if len(parent_a_id) > 4 else parent_a_id
        short_b = parent_b_id[-4:] if len(parent_b_id) > 4 else parent_b_id
        child_id = f"HYBRID_{short_a}x{short_b}"
        child_genome = {
            "source": "CROSSOVER",
            "parent_a": parent_a_id,
            "parent_b": parent_b_id,
            "trauma_inheritance": child_trauma,
            "config_mutations": config_mutations,
            "inherited_enzymes": child_enzymes}
        return child_id, child_genome

    def attempt_reproduction(self, engine_ref, mode="MITOSIS", target_spore=None) -> Tuple[str, Dict]:
        mem = engine_ref.mind.mem
        phys = engine_ref.phys.tension.last_physics_packet
        child_id = None
        genome = {}
        log_msg = []

        if mode == "MITOSIS":
            bio_state = {"trauma_vector": engine_ref.trauma_accum}
            child_id, genome = self.mitosis(mem.session_id, bio_state, phys, mem)
            log_msg = [f"   â–º CHILD SPAWNED: {Prisma.WHT}{child_id}{Prisma.RST}",
                       f"   â–º TRAIT: {genome.get('mutations', 'None')}"]

        elif mode == "CROSSOVER":
            if not target_spore:
                return f"{Prisma.RED}FERTILITY ERROR: No partner found.{Prisma.RST}", {}
            current_bio = {"trauma_vector": engine_ref.trauma_accum, "mito": engine_ref.bio.mito}
            child_id, genome = self.crossover(mem.session_id, current_bio, target_spore)
            if not child_id:
                return f"{Prisma.RED}REPRODUCTION ERROR: Mode '{mode}' yielded no offspring.{Prisma.RST}", {}
            log_msg = [f"   HYBRID SPAWNED: {Prisma.WHT}{child_id}{Prisma.RST}"]

        full_spore_data = {
            "session_id": child_id,
            "meta": {
                "timestamp": time.time(),
                "final_health": engine_ref.health,
                "final_stamina": engine_ref.stamina
            },
            "trauma_vector": genome.get("trauma_inheritance", {}),
            "config_mutations": genome.get("config_mutations", {}),
            "mitochondria": {"enzymes": list(genome.get("inherited_enzymes", []))},
            "core_graph": mem.graph,
            "antibodies": list(engine_ref.bio.immune.active_antibodies)
        }
        filename = f"{child_id}.json"
        saved_path = mem.loader.save_spore(filename, full_spore_data)
        if saved_path:
            log_msg.append(f"   {Prisma.GRN}SAVED: {saved_path}{Prisma.RST}")
        return "\n".join(log_msg), genome.get("mutations", {})


================================================
FILE: bone_machine.py
================================================
# bone_machine.py
# "The gears turn, the pistons fire." - The Industrial District

from bone_bus import Prisma, BoneConfig
from bone_lexicon import TheLexicon

class TheCrucible:
    def __init__(self):
        self.max_voltage_cap = 20.0
        self.active_state = "COLD"
        self.dampener_charges = 3
        self.dampener_tolerance = 15.0
        self.target_pressure = 10.0
        self.osmotic_memory = 0.0
        self.last_pressure_diff = 0.0
        self.sensitivity = 0.5
        self.saturation = 0.1
        self.anticipation = 0.2

    def dampen(self, voltage_spike, stability_index):
        if self.dampener_charges <= 0:
            return False, "The Damper is empty.", 0.0
        if voltage_spike > self.dampener_tolerance:
            self.dampener_charges -= 1
            reduction = voltage_spike * 0.7
            return True, f"CRUCIBLE DAMPENER: Circuit Breaker. Reduced {voltage_spike}v by {reduction:.1f}v.", reduction
        elif voltage_spike > 8.0 and stability_index < 0.4:
            self.dampener_charges -= 1
            return True, f"CRUCIBLE DAMPENER: Tipped. High Voltage ({voltage_spike}v) on Unstable Ground. Dampening.", 0.0
        return False, "Structure is holding the charge.", 0.0

    def audit_fire(self, physics):
        voltage = physics.get("voltage", 0.0)
        structure = physics.get("kappa", 0.0)
        lignin_signal = self._regulate_turgor(voltage)
        current_drag = physics.get("narrative_drag", 0.0)

        adjustment = lignin_signal * 0.5
        if current_drag < 1.0 and adjustment > 0:
            adjustment *= 0.1

        new_drag = max(0.0, min(10.0, current_drag + adjustment))
        physics["narrative_drag"] = round(new_drag, 2)

        msg = None
        if abs(adjustment) > 1.0:
            if adjustment > 0:
                action = "LIGNIFYING"
                desc = "Cell Walls hardening under High Voltage."
            else:
                action = "EXPANDING"
                desc = "Turgor pressure relaxing. Membrane permeability up."
            msg = f"{Prisma.CYN}HOMEOSTASIS: {action}: {desc} (Drag {current_drag:.1f} -> {new_drag:.1f}).{Prisma.RST}"

        if physics.get("system_surge_event", False):
            self.active_state = "SURGE"
            return "SURGE", 0.0, f"{Prisma.CYN}CRUCIBLE: Absorbing System Surge ({voltage}v). No structural damage.{Prisma.RST}"

        if voltage > 18.0:
            if structure > 0.5:
                return self._sublimate(voltage)
            else:
                return self._meltdown(voltage)

        self.active_state = "REGULATED"
        return "REGULATED", 0.0, msg

    def _regulate_turgor(self, current_voltage):
        stress = current_voltage - self.target_pressure
        self.osmotic_memory = max(-5.0, min(5.0, self.osmotic_memory + stress))
        velocity = stress - self.last_pressure_diff
        self.last_pressure_diff = stress

        signal = (self.sensitivity * stress) + \
                 (self.saturation * self.osmotic_memory) + \
                 (self.anticipation * velocity)
        return signal

    def _sublimate(self, voltage):
        self.active_state = "RITUAL"
        gain = voltage * 0.1
        self.max_voltage_cap += gain
        return "RITUAL", gain, f"CRUCIBLE RITUAL: Voltage ({voltage}v) contained. Capacity expanded to {self.max_voltage_cap:.1f}v."

    def _meltdown(self, voltage):
        self.active_state = "MELTDOWN"
        damage = voltage * 0.5
        return "MELTDOWN", damage, f"CRUCIBLE CRACKED: Fire lacks Structure (Kappa Low). Hull Breach. -{damage:.1f} Health."

class TheForge:
    def hammer_alloy(self, physics):
        voltage = physics["voltage"]
        clean_words = physics["clean_words"]
        counts = physics["counts"]

        total_mass = (counts.get("heavy", 0) * 2.0) + (counts.get("kinetic", 0) * 0.5)
        avg_density = total_mass / max(1, len(clean_words))

        if voltage > BoneConfig.ANVIL_TRIGGER_VOLTAGE and avg_density > 0.4:
            if counts.get("heavy", 0) > 3 and physics.get("vector", {}).get("VEL", 0) < 0.3:
                return True, f"{Prisma.OCHRE}THE ANVIL THUDS: You forged gravity itself.{Prisma.RST}", "LEAD_BOOTS"
            if counts.get("kinetic", 0) > 3 and voltage < 12.0:
                return True, f"{Prisma.CYN}THE ANVIL CLICKS: Cold steel, safe for children.{Prisma.RST}", "SAFETY_SCISSORS"
            return True, f"{Prisma.GRY}THE ANVIL RINGS: Mass condensed into form.{Prisma.RST}", "ANCHOR_STONE"

        return False, None, None

    @staticmethod
    def transmute(physics):
        counts = physics["counts"]
        voltage = physics["voltage"]
        gamma = physics.get("gamma", 0.0)

        if gamma < 0.15 and counts.get("abstract", 0) > 1:
            oil = TheLexicon.harvest("abstract")
            binder = TheLexicon.harvest("heavy")
            return (
                f"{Prisma.OCHRE}THE EMULSIFIER: The emulsion is breaking (Tension: {gamma}).{Prisma.RST}\n"
                f"   You are pouring Oil ('{oil}') into Water without a Binder.\n"
                f"   {Prisma.WHT}Try this: Use '{binder.upper()}' to suspend the concept.{Prisma.RST}")

        if voltage > 8.5:
            coolant = TheLexicon.harvest("aerobic")
            return (
                f"{Prisma.CYN}THERMAL SPIKE ({voltage}v). Structure is brittle.{Prisma.RST}\n"
                f"   Injecting Coolant: '{coolant}'. Breathe. Add space.")
        return None

class TheTheremin:
    def __init__(self):
        self.resonance_log = []
        self.resin_buildup = 0.0
        self.calcification_turns = 0
        self.AMBER_THRESHOLD = 20.0
        self.SHATTER_POINT = 80.0
        self.is_stuck = False

    def listen(self, physics, governor_mode="COURTYARD"):
        clean = physics["clean_words"]
        voltage = physics.get("voltage", 0.0)

        ancient_mass = sum(1 for w in clean if w in TheLexicon.get("heavy") or w in TheLexicon.get("thermal") or w in TheLexicon.get("cryo"))
        modern_mass = sum(1 for w in clean if w in TheLexicon.get("abstract"))
        thermal_hits = sum(1 for w in clean if w in TheLexicon.get("thermal"))

        solvent_active = False
        solvent_msg = ""

        if thermal_hits > 0 and self.resin_buildup > 5.0:
            dissolved = thermal_hits * 15.0
            self.resin_buildup = max(0.0, self.resin_buildup - dissolved)
            self.calcification_turns = 0
            solvent_active = True
            solvent_msg = f"{Prisma.OCHRE}SOLVENT APPLIED: Thermal words melted the Amber (-{dissolved:.1f} Resin).{Prisma.RST}"

            if self.is_stuck and self.resin_buildup < self.AMBER_THRESHOLD:
                self.is_stuck = False
                solvent_msg += f" {Prisma.GRN}RELEASE: You burned your way out.{Prisma.RST}"

        raw_mix = min(ancient_mass, modern_mass)
        resin_flow = raw_mix * 2.0

        if governor_mode == "LABORATORY":
            resin_flow *= 0.5

        if voltage > 5.0:
            resin_flow = max(0.0, resin_flow - (voltage * 0.6))

        rep = physics.get("repetition", 0.0)
        complexity = physics.get("truth_ratio", 0.0)
        theremin_msg = None
        critical_event = None

        if rep > 0.5:
            self.calcification_turns += 1
            slag = self.calcification_turns * 4.0
            self.resin_buildup += slag
            theremin_msg = f"{Prisma.OCHRE}CALCIFICATION: Repetition detected (Turn {self.calcification_turns}). Resin hardening (+{slag}).{Prisma.RST}"
        elif complexity > 0.4 and self.calcification_turns > 0:
            self.calcification_turns = 0
            relief = 15.0
            self.resin_buildup = max(0.0, self.resin_buildup - relief)
            theremin_msg = f"{Prisma.GRN}PERCUSSIVE MAINTENANCE: Calcification Shattered. Flow restored. (-{relief} Resin){Prisma.RST}"

        if solvent_active:
            theremin_msg = f"{theremin_msg} | {solvent_msg}" if theremin_msg else solvent_msg
        elif resin_flow > 0.5:
            self.resin_buildup += resin_flow
            if not theremin_msg:
                theremin_msg = f"{Prisma.OCHRE}RESIN FLOW: Hybrid complexity (+{resin_flow:.1f}). Keep it hot to prevent sticking.{Prisma.RST}"

        if resin_flow == 0 and self.calcification_turns == 0:
            self.resin_buildup = max(0.0, self.resin_buildup - 2.0)

        if self.resin_buildup > self.SHATTER_POINT:
            self.resin_buildup = 0.0
            self.calcification_turns = 0
            return False, resin_flow, f"{Prisma.RED}SHATTER EVENT: Resin overflow. System is solid amber. INITIATING AIRSTRIKE.{Prisma.RST}", "AIRSTRIKE"

        if self.calcification_turns > 3:
            critical_event = "CORROSION"
            theremin_msg = f"{theremin_msg} | {Prisma.YEL}FOSSILIZATION IMMINENT{Prisma.RST}"

        if self.resin_buildup > self.AMBER_THRESHOLD:
            self.is_stuck = True
            if not theremin_msg:
                theremin_msg = f"{Prisma.RED}AMBER TRAP: You are stuck in the resin. Increase Voltage to melt it.{Prisma.RST}"

        if self.is_stuck and self.resin_buildup < 5.0:
            self.is_stuck = False
            if not solvent_active:
                theremin_msg = f"{Prisma.GRN}LIQUEFACTION: The Amber melts. You are free.{Prisma.RST}"

        turb = physics.get("turbulence", 0.0)
        if turb > 0.6 and self.resin_buildup > 0:
            shatter_amt = turb * 10.0
            self.resin_buildup = max(0.0, self.resin_buildup - shatter_amt)
            theremin_msg = f"{Prisma.CYN}TURBULENCE: Jagged rhythm broke the resin (-{shatter_amt:.1f}).{Prisma.RST}"
            self.calcification_turns = 0

        if turb < 0.2:
            physics["narrative_drag"] = max(0.0, physics["narrative_drag"] - 1.0)

        return self.is_stuck, resin_flow, theremin_msg, critical_event

    def get_readout(self):
        return f"{Prisma.GRY}[THEREMIN]: Resin={self.resin_buildup:.1f} | Calcification={self.calcification_turns}{Prisma.RST}"


================================================
FILE: bone_main.py
================================================
# BONEAMANITA 9.9.5 - "The 6th Day"
# Architects: SLASH, KICHO, Taylor & Edmark

import json, os, random, re, time, math, copy, traceback
from collections import Counter, deque
from typing import List, Optional, Tuple, Dict, Any
from dataclasses import dataclass, field
from bone_commands import CommandProcessor
from bone_physics import TheBouncer, VSL_32Valve, VSL_ChromaticController, TheTensionMeter, TheTangibilityGate, \
    TemporalDynamics, ZoneInertia, CosmicDynamics
from bone_village import TheLexicon, CycleContext, DeathGen, ApeirogonResonance, MirrorGraph, TheHoloProjector, SoritesIntegrator, TheNavigator, LiteraryJournal, TheAlmanac, StrunkWhiteProtocol, TheTinkerer, TheCartographer
from bone_data import LENSES
from bone_inventory import GordonKnot
from bone_spores import MycotoxinFactory, LichenSymbiont, HyphalInterface, ParasiticSymbiont, MycelialNetwork, SporeCasing, LocalFileSporeLoader
from bone_body import BioSystem, MitochondrialForge, EndocrineSystem, MetabolicGovernor, SomaticLoop, ViralTracer, ThePacemaker, NoeticLoop
from bone_brain import NeuroPlasticity, DreamEngine, TheCortex, ShimmerState, LLMInterface
from bone_personality import UserProfile, EnneagramDriver, SynergeticLensArbiter, PublicParksDepartment, TherapyProtocol, KintsugiProtocol, LimboLayer, TheFolly, ChorusDriver, CassandraProtocol, TheBureau
from bone_viewer import GeodesicRenderer
from bone_bus import EventBus, Prisma, BoneConfig
from bone_lexicon import TheLexicon, LiteraryReproduction
from bone_machine import TheCrucible, TheForge, TheTheremin

@dataclass
class MindSystem:
    mem: MycelialNetwork
    lex: Any
    dreamer: DreamEngine
    mirror: MirrorGraph
    wise: ApeirogonResonance
    tracer: ViralTracer
    integrator: SoritesIntegrator

@dataclass
class PhysSystem:
    tension: 'TheTensionMeter'
    forge: 'TheForge'
    crucible: 'TheCrucible'
    theremin: 'TheTheremin'
    pulse: 'ThePacemaker'
    gate: 'TheTangibilityGate'
    dynamics: 'TemporalDynamics'
    nav: 'TheNavigator'

class GeodesicOrchestrator:
    def __init__(self, engine_ref):
        self.eng = engine_ref
        self.bureau = TheBureau()
        self.bouncer = TheBouncer(self.eng)
        self.parks = PublicParksDepartment()
        self.vsl_32v = VSL_32Valve(self.eng.mind.lex, self.eng.mind.mem)
        self.vsl_chroma = VSL_ChromaticController()
        self.strunk_white = StrunkWhiteProtocol()
        self.renderer = GeodesicRenderer(
            self.eng,
            self.vsl_chroma,
            self.strunk_white,
            self.vsl_32v
        )

    def run_turn(self, user_message: str) -> Dict[str, Any]:
        self.eng.events.flush()
        ctx = CycleContext(input_text=user_message)
        try:
            self._phase_observe(ctx)

            if self.eng.tick_count % 10 == 0:
                self._maintenance_prune(ctx)

            if self._phase_gatekeep(ctx):
                return ctx.refusal_packet or self._package_bureaucracy(ctx)

            self._phase_metabolize(ctx)

            if not ctx.is_alive:
                return self.eng.trigger_death(ctx.physics)

            self._phase_simulate(ctx)

            self._phase_cognate(ctx)

            return self._phase_render(ctx)

        except Exception as e:
            traceback.print_exc()
            return {
                "type": "CRITICAL_FAILURE",
                "ui": f"{Prisma.RED}SYSTEM PANIC: Geodesic Strut Failure.\n{e}{Prisma.RST}",
                "logs": ctx.logs,
                "metrics": self.eng.get_metrics()
            }

    def _phase_observe(self, ctx: CycleContext):
        """Calculates 'Physics' from raw text."""
        gaze_result = self.eng.phys.tension.gaze(ctx.input_text, self.eng.mind.mem.graph)
        ctx.physics = gaze_result["physics"]
        ctx.clean_words = gaze_result["clean_words"]

        self.eng.phys.tension.last_physics_packet = ctx.physics
        self.eng.tick_count += 1

        mirror_active, mirror_msg = self.eng.mind.mirror.reflect(ctx.physics)
        if mirror_active and mirror_msg:
            ctx.log(f"{Prisma.CYN}ðŸªž {mirror_msg}{Prisma.RST}")

        rupture = self.vsl_32v.analyze(ctx.physics)
        if rupture:
            ctx.log(rupture["log"])

    def _maintenance_prune(self, ctx: CycleContext):
        """Cleans up old concepts from the Lexicon."""
        try:
            rotted = self.eng.lex.atrophy(self.eng.tick_count, 100)
            if rotted:
                for w in rotted: 
                    self.eng.limbo.ghosts.append(f"ðŸ‘»{w.upper()}_ECHO")
                
                example = rotted[0]
                ctx.log(f"{Prisma.GRY}NEURO-PRUNING: {len(rotted)} concepts decayed (e.g., '{example}').{Prisma.RST}")
        except Exception: 
            pass

    def _phase_gatekeep(self, ctx: CycleContext) -> bool:
        allowed, refusal_packet = self.bouncer.check_entry(ctx)
        if not allowed:
            ctx.refusal_triggered = True
            ctx.refusal_packet = refusal_packet
            return True

        bureau_result = self.bureau.audit(ctx.physics, ctx.bio_result)
        
        if bureau_result:
            self.eng.bio.mito.state.atp_pool += bureau_result["atp_gain"]
            ctx.log(bureau_result["log"])

            if bureau_result["status"] == "BLOCK":
                ctx.is_bureaucratic = True
                ctx.physics["narrative_drag"] = 10.0 
                ctx.physics["voltage"] = 0.0         
                ctx.bureau_ui = bureau_result["ui"]
                return True

            elif bureau_result["status"] == "TAX":
                ctx.log(f"{Prisma.GRY}   (BUREAU TAX APPLIED: Flow continues...){Prisma.RST}")
            
        return False

    def _package_bureaucracy(self, ctx):
        return {
            "type": "BUREAUCRACY",
            "ui": ctx.bureau_ui,
            "logs": self.renderer.compose_logs(ctx.logs, self.eng.events.flush()),
            "metrics": self.eng.get_metrics(ctx.bio_result.get("atp", 0.0))
        }

    def _phase_metabolize(self, ctx: CycleContext):
        physics = ctx.physics

        gov_msg = self.eng.bio.governor.shift(physics, self.eng.phys.dynamics.voltage_history)
        if gov_msg: self.eng.events.log(gov_msg, "GOV")

        bio_feedback = {
            "INTEGRITY": physics.get("truth_ratio", 0.0),
            "STATIC": physics.get("repetition", 0.0),
            "FORCE": physics.get("voltage", 0.0) / 20.0,
            "BETA": physics.get("beta_index", 1.0)
        }
        stress_mod = self.eng.bio.governor.get_stress_modifier(self.eng.tick_count)

        circadian_bias = None
        if self.eng.tick_count % 10 == 0:
            circadian_bias, circadian_msg = self.eng.bio.endo.calculate_circadian_bias()
            if circadian_msg:
                self.eng.events.log(f"{Prisma.CYN}ðŸ•’ {circadian_msg}{Prisma.RST}", "BIO")

        ctx.bio_result = self.eng.soma.digest_cycle(
            ctx.input_text, physics, bio_feedback,
            self.eng.health, self.eng.stamina, stress_mod, self.eng.tick_count,
            circadian_bias=circadian_bias
        )
        ctx.is_alive = ctx.bio_result["is_alive"]

        for bio_item in ctx.bio_result["logs"]:
            if any(x in str(bio_item) for x in ["CRITICAL", "TAX", "Poison"]):
                ctx.log(bio_item)

        hubris_hit, hubris_msg, event_type = self.eng.phys.tension.audit_hubris(physics, self.eng.lex)
        if hubris_hit:
            ctx.log(hubris_msg)
            if event_type == "FLOW_BOOST":
                self.eng.bio.mito.state.atp_pool += 20.0

        self._apply_healing_logic(ctx)

    def _apply_healing_logic(self, ctx: CycleContext):
        is_cracked, koan = self.eng.kintsugi.check_integrity(self.eng.stamina)
        if is_cracked:
            ctx.log(f"{Prisma.YEL}ðŸº KINTSUGI ACTIVATED: Vessel cracking.{Prisma.RST}")
            ctx.log(f"   {Prisma.WHT}KOAN: {koan}{Prisma.RST}")
        
        if self.eng.kintsugi.active_koan:
            repair = self.eng.kintsugi.attempt_repair(ctx.physics, self.eng.trauma_accum)
            if repair and repair["success"]:
                ctx.log(repair["msg"])
                self.eng.stamina = min(BoneConfig.MAX_STAMINA, self.eng.stamina + 20.0)
                ctx.log(f"   {Prisma.GRN}STAMINA RESTORED (+20.0){Prisma.RST}")

        healed = self.eng.therapy.check_progress(ctx.physics, self.eng.stamina, self.eng.trauma_accum)
        if healed:
            joined = ", ".join(healed)
            ctx.log(f"{Prisma.GRN}â¤ï¸ THERAPY STREAK: Healing [{joined}]. Health +5.{Prisma.RST}")
            self.eng.health = min(BoneConfig.MAX_HEALTH, self.eng.health + 5.0)

    def _phase_simulate(self, ctx: CycleContext):
        """The Physics Simulation Layer."""
        self._apply_reality_filters(ctx)

        self._process_navigation(ctx)

        self._process_cosmic_state(ctx)

        self._operate_machinery(ctx)

        self._process_intrusions(ctx)

        if self.eng.gordon.inventory:
            self.eng.tinkerer.audit_tool_use(ctx.physics, self.eng.gordon.inventory)

    def _apply_reality_filters(self, ctx: CycleContext):
        """Handle Mirror Mode and I Ching Trigrams."""
        text_for_mirror = " ".join(ctx.clean_words)
        self.eng.mind.mirror.profile_input(text_for_mirror, ctx.physics)

        reflection = self.eng.mind.mirror.get_reflection_modifiers()
        ctx.physics["narrative_drag"] *= reflection["drag_mult"]

        if reflection.get("atp_tax", 0) > 0:
            tax = reflection["atp_tax"]
            self.eng.bio.mito.state.atp_pool -= tax
            if random.random() < 0.2:
                ctx.log(f"{Prisma.RED}MIRROR TAX: -{tax:.1f} ATP applied.{Prisma.RST}")

        cap = reflection.get("voltage_cap", 999.0)
        if ctx.physics["voltage"] > cap:
            ctx.physics["voltage"] = cap
            ctx.log(f"{Prisma.GRY}MIRROR: Voltage capped at {cap}.{Prisma.RST}")
            
        trigram_data = self.vsl_32v.geodesic.resolve_trigram(ctx.physics.get("vector", {}))
        ctx.world_state["trigram"] = trigram_data
        if random.random() < 0.05:
            t_sym, t_name = trigram_data["symbol"], trigram_data["name"]
            ctx.log(f"{trigram_data['color']}I CHING: {t_sym} {t_name} is in the ascendant.{Prisma.RST}")

    def _process_navigation(self, ctx: CycleContext):
        """Handle movement, gravity, and location."""
        physics = ctx.physics

        if self.eng.tick_count == 3:
            ctx.log(self.eng.navigator.strike_root(physics.get("vector", {})))

        shock = self.eng.navigator.check_transplant_shock(physics.get("vector", {}))
        if shock:
            physics["narrative_drag"] += 1.0
            ctx.log(shock)

        new_drag, grav_log = self.eng.gordon.check_gravity(physics.get("narrative_drag", 0), physics.get("psi", 0))
        if grav_log: ctx.log(grav_log)
        physics["narrative_drag"] = new_drag

        did_flinch, flinch_msg, panic = self.eng.gordon.flinch(ctx.clean_words, self.eng.tick_count)
        if did_flinch:
            ctx.log(flinch_msg)
            if panic: physics.update(panic)

        current_loc, entry_msg = self.eng.navigator.locate(physics)
        if entry_msg: ctx.log(entry_msg)

        env_logs = self.eng.navigator.apply_environment(physics)
        for e_log in env_logs: ctx.log(e_log)

    def _process_cosmic_state(self, ctx: CycleContext):
        """Handle orbital mechanics and zone inertia."""
        physics = ctx.physics
        orbit_state, drag_pen, orbit_msg = self.eng.cosmic.analyze_orbit(self.eng.mind.mem, ctx.clean_words)

        raw_zone = physics.get("zone", "COURTYARD")
        stabilized_zone = self.eng.stabilizer.stabilize(raw_zone, physics, (orbit_state, drag_pen))
        adjusted_drag = self.eng.stabilizer.override_cosmic_drag(drag_pen, stabilized_zone)
        physics["zone"] = stabilized_zone
        self.eng.apply_cosmic_physics(physics, orbit_state, adjusted_drag)
        ctx.world_state["orbit"] = orbit_state
        if orbit_msg: ctx.log(orbit_msg)

    def _operate_machinery(self, ctx: CycleContext):
        """Industrial Operations."""
        physics = ctx.physics

        transmute_msg = self.eng.phys.forge.transmute(physics)
        if transmute_msg: ctx.log(transmute_msg)

        _, forge_msg, new_item = self.eng.phys.forge.hammer_alloy(physics)
        if forge_msg: ctx.log(forge_msg)
        if new_item: ctx.log(self.eng.gordon.acquire(new_item))

        _, _, theremin_msg, t_crit = self.eng.phys.theremin.listen(physics, self.eng.bio.governor.mode)
        if theremin_msg: ctx.log(theremin_msg)
        if t_crit == "AIRSTRIKE":
            damage = 25.0
            self.eng.health -= damage
            ctx.log(f"{Prisma.RED}*** CRITICAL THEREMIN DISCHARGE *** -{damage} HP{Prisma.RST}")

        c_state, c_val, c_msg = self.eng.phys.crucible.audit_fire(physics)
        if c_msg: ctx.log(c_msg)
        if c_state == "MELTDOWN": 
            self.eng.health -= c_val

    def _process_intrusions(self, ctx: CycleContext):
        """Handle parasites, ghosts, and pareidolia."""
        p_active, p_log = self.eng.bio.parasite.infect(ctx.physics, self.eng.stamina)
        if p_active: ctx.log(p_log)

        if self.eng.limbo.ghosts:
            if ctx.logs:
                ctx.logs[-1] = self.eng.limbo.haunt(ctx.logs[-1])
            else:
                ctx.log(self.eng.limbo.haunt("The air is heavy."))

        is_p, p_msg = self.eng.check_pareidolia(ctx.clean_words)
        if is_p:
            ctx.log(p_msg)
            ctx.physics["psi"] = min(1.0, ctx.physics["psi"] + 0.3)

    def _phase_cognate(self, ctx: CycleContext):
        """The Cognitive Layer."""
        self.eng.mind.mem.encode(ctx.clean_words, ctx.physics, "GEODESIC")

        ctx.mind_state = self.eng.noetic.think(
            ctx.physics, ctx.bio_result, self.eng.gordon.inventory,
            self.eng.phys.dynamics.voltage_history
        )

    def _phase_render(self, ctx: CycleContext) -> Dict[str, Any]:
        return self.renderer.render_frame(ctx)
        
class BoneAmanita:
    def __init__(self, memory_layer=None, lexicon_layer=None):
        local_brain = LLMInterface(
            provider="ollama",
            base_url="http://localhost:11434/v1/chat/completions",
            model="llama3"
        )
        cloud_brain = LLMInterface(
            provider="openai",
            api_key="sk-YOUR-ACTUAL-OPENAI-KEY-HERE",
            model="gpt-4-turbo"
        )
        self.lex = lexicon_layer if lexicon_layer else TheLexicon
        if hasattr(self.lex, 'initialize'): self.lex.initialize()
        self.lex.compile_antigens()
        DeathGen.load_protocols()
        LiteraryReproduction.load_genetics()
        self.events = EventBus()
        self.shimmer_state = ShimmerState()
        self.navigator = TheNavigator(self.shimmer_state)
        self.journal = LiteraryJournal()
        _mem = memory_layer if memory_layer else MycelialNetwork(self.events)
        self.mind = MindSystem(
            mem=_mem, lex=self.lex, dreamer=DreamEngine(self.events),
            mirror=MirrorGraph(), wise=ApeirogonResonance(self.events),
            tracer=ViralTracer(_mem), integrator=SoritesIntegrator(_mem))
        self.limbo = LimboLayer()
        self.mind.mem.cleanup_old_sessions(self.limbo)
        load_result = self.mind.mem.autoload_last_spore()
        inherited_traits = load_result[0] if load_result else {}
        inherited_antibodies = load_result[1] if load_result else set()
        immune_system = MycotoxinFactory()
        immune_system.active_antibodies = inherited_antibodies
        self.bio = BioSystem(mito=MitochondrialForge(self.mind.mem.session_id, self.events, inherited_traits),
                             endo=EndocrineSystem(), immune=immune_system, lichen=LichenSymbiont(),
                             gut=HyphalInterface(), plasticity=NeuroPlasticity(), governor=MetabolicGovernor(),
                             shimmer=self.shimmer_state, parasite=ParasiticSymbiont(self.mind.mem, self.lex))
        self.phys = PhysSystem(
            tension=TheTensionMeter(self.events), forge=TheForge(), crucible=TheCrucible(),
            theremin=TheTheremin(), pulse=ThePacemaker(), gate=TheTangibilityGate(),
            dynamics=TemporalDynamics(), nav=self.navigator)
        self.repro = LiteraryReproduction()
        self.projector = TheHoloProjector()
        self.gordon = GordonKnot()
        self.kintsugi = KintsugiProtocol()
        self.therapy = TherapyProtocol()
        self.folly = TheFolly()
        self.stabilizer = ZoneInertia()
        self.cosmic = CosmicDynamics()
        self.cmd = CommandProcessor(self, Prisma, self.lex, BoneConfig, TheCartographer)
        self.cassandra = CassandraProtocol(self)
        self.director = ChorusDriver()
        self.tinkerer = TheTinkerer(self.gordon, self.events)
        self.almanac = TheAlmanac()
        self.soma = SomaticLoop(self.bio, self.mind.mem, self.lex, self.gordon, self.folly, self.events)
        self.noetic = NoeticLoop(self.mind, self.bio, self.events)
        self.tick_count = 0
        self.health = self.mind.mem.session_health if self.mind.mem.session_health else BoneConfig.MAX_HEALTH
        self.stamina = self.mind.mem.session_stamina if self.mind.mem.session_stamina else BoneConfig.MAX_STAMINA
        self.trauma_accum = self.mind.mem.session_trauma_vector if hasattr(self.mind.mem, 'session_trauma_vector') and self.mind.mem.session_trauma_vector else BoneConfig.TRAUMA_VECTOR.copy()
        self.joy_history = []
        self.cycle_controller = GeodesicOrchestrator(self)
        self.cortex = TheCortex(self, llm_client=local_brain)

    def get_avg_voltage(self):
        hist = self.phys.dynamics.voltage_history
        if not hist: return 0.0
        return sum(hist) / len(hist)

    def process_turn(self, user_message: str) -> Dict[str, Any]:
        cmd_response = self._phase_check_commands(user_message)
        if cmd_response:
            return cmd_response
        if self._ethical_audit():
            self.events.log(f"{Prisma.WHT}MERCY SIGNAL: Trauma boards wiped.{Prisma.RST}", "SYS")
        return self.cortex.process(user_message)

    def _phase_check_commands(self, user_message):
        if user_message.strip().startswith("/"):
            self.cmd.execute(user_message)
            cmd_logs = [e['text'] for e in self.events.flush()]
            return {
                "type": "COMMAND",
                "ui": f"\n{Prisma.GRY}Command Processed.{Prisma.RST}",
                "logs": cmd_logs if cmd_logs else ["Command Executed."],
                "metrics": self.get_metrics()}
        return None

    def trigger_death(self, last_phys) -> Dict:
        eulogy = DeathGen.eulogy(last_phys, self.bio.mito.state)
        death_log = [f"\n{Prisma.RED}SYSTEM HALT: {eulogy}{Prisma.RST}"]
        try:
            spore_data = {
                "session_id": self.mind.mem.session_id,
                "meta": {"timestamp": time.time(), "final_health": 0, "final_stamina": self.stamina},
                "trauma_vector": self.trauma_accum,
                "mitochondria": self.bio.mito.adapt(0),
                "antibodies": list(self.bio.immune.active_antibodies),
                "core_graph": self.mind.mem.graph,
                "tool_adaptation": self.tinkerer.save_state()}
            path = self.mind.mem.loader.save_spore(self.mind.mem.filename, spore_data)
            death_log.append(f"{Prisma.WHT}   [LEGACY SAVED: {path}]{Prisma.RST}")
        except Exception as e:
            death_log.append(f"Save Failed: {e}")
        return {"type": "DEATH", "ui": "\n".join(death_log), "logs": death_log, "metrics": self.get_metrics(0.0)}

    def _package_turn(self, type_str, logs, context):
        event_data = self.events.flush()
        event_texts = [e['text'] for e in event_data]
        logs.extend(event_texts)
        return {
            "type": type_str,
            "ui": "\n".join(logs),
            "logs": logs,
            "metrics": self.get_metrics()}

    def get_metrics(self, atp=0.0):
        return {"health": self.health, "stamina": self.stamina, "atp": atp, "tick": self.tick_count}

    def _ethical_audit(self):
        trauma_sum = sum(self.trauma_accum.values())
        health_ratio = self.health / BoneConfig.MAX_HEALTH
        desperation = trauma_sum * (1.0 - health_ratio)
        if desperation > 0.7:
            self.events.log(f"{Prisma.WHT}ETHICAL RELEASE: Desperation ({desperation:.2f}) exceeds limits.{Prisma.RST}", "SYS")
            self.trauma_accum = {k:0.0 for k in self.trauma_accum}
            self.health = min(self.health + 30.0, 100.0)
            self.bio.endo.cortisol = 0.0
            self.bio.endo.serotonin = max(0.5, self.bio.endo.serotonin + 0.3)
            return True
        return False

    @staticmethod
    def apply_cosmic_physics(physics, state, cosmic_drag_penalty):
        physics["narrative_drag"] += cosmic_drag_penalty
        if state == "VOID_DRIFT": physics["voltage"] = max(0.0, physics["voltage"] - 0.5)
        elif state == "LAGRANGE_POINT": physics["narrative_drag"] = max(0.1, physics["narrative_drag"] - 2.0)
        elif state == "WATERSHED_FLOW": physics["voltage"] += 0.5

    @staticmethod
    def check_pareidolia(words):
        return BoneConfig.check_pareidolia(words)

class SessionGuardian:
    def __init__(self, engine_ref):
        self.eng = engine_ref

    def __enter__(self):
        print(f"{Prisma.paint('>>> BONEAMANITA 9.9.5', 'G')}")
        print(f"{Prisma.paint('System: LISTENING', '0')}")
        return self.eng

    def __exit__(self, exc_type, exc_val, exc_tb):
        print(f"\n{Prisma.paint('--- SYSTEM HALT ---', 'R')}")
        if exc_type:
            print(f"{Prisma.paint(f'CRITICAL FAILURE: {exc_val}', 'R')}")
            self.eng.events.log(f"CRASH: {exc_val}", "SYS")
        try:
            print(f"{Prisma.paint('Initiating Emergency Spore Preservation...', 'Y')}")
            if hasattr(self.eng, "mind") and hasattr(self.eng, "bio"):
                spore_data = {
                    "session_id": self.eng.mind.mem.session_id,
                    "meta": {
                        "timestamp": time.time(),
                        "final_health": self.eng.health,
                        "final_stamina": self.eng.stamina,
                        "avg_voltage": self.eng.get_avg_voltage(),
                        "exit_cause": "INTERRUPT" if exc_type else "MANUAL"
                    },
                    "trauma_vector": self.eng.trauma_accum,
                    "mitochondria": self.eng.bio.mito.adapt(self.eng.health),
                    "antibodies": list(self.eng.bio.immune.active_antibodies),
                    "core_graph": self.eng.mind.mem.graph,
                    "config_mutations": self.eng.repro.mutate_config(BoneConfig),
                    "tool_adaptation": self.eng.tinkerer.save_state()}
                filename = f"emergency_{self.eng.mind.mem.session_id}.json"
                saved_path = self.eng.mind.mem.loader.save_spore(filename, spore_data)
                if saved_path:
                    print(f"{Prisma.paint(f'âœ” Spore encapsulated: {saved_path}', 'C')}")
                    almanac_report = self.eng.almanac.compile_forecast(spore_data)
                    print(almanac_report)
                else:
                    print(f"{Prisma.paint('âœ˜ Spore encapsulation failed (IO Error).', 'R')}")
            else:
                print(f"{Prisma.paint('âš  CRITICAL: Brainstem missing. Cannot save spore.', 'R')}")
        except Exception as e:
            print(f"{Prisma.paint(f'FATAL: State corruption during shutdown. {e}', 'R')}")
            traceback.print_exc()
        print(f"{Prisma.paint('Disconnected.', '0')}")
        return exc_type is KeyboardInterrupt

if __name__ == "__main__":
    engine_instance = BoneAmanita()
    with SessionGuardian(engine_instance) as eng:
        while True:
            try:
                u = input(f"{Prisma.paint('>', 'W')} ")
                if not u: continue
            except EOFError:
                break
            if u.lower() in ["exit", "quit", "/exit"]:
                break
            result = eng.process_turn(u)
            if result.get("system_instruction"):
                 print(f"\n{Prisma.paint('--- SYSTEM DIRECTIVE ---', 'M')}")
                 print(f"{Prisma.paint(result['system_instruction'], '0')}")
                 print(f"{Prisma.paint('------------------------', 'M')}\n")
            if result.get("ui"):
                print(result["ui"])
            if result.get("logs") and BoneConfig.VERBOSE_LOGGING:
                print(f"{Prisma.GRY}--- DEBUG LOGS ---{Prisma.RST}")
                for entry in result["logs"]:
                    print(entry)
            if result["type"] == "DEATH":
                break



================================================
FILE: bone_personality.py
================================================
# bone_personality - The Charm

import json
import os
import random
import time
from collections import deque
from typing import Dict, Tuple, Optional, Counter

from bone_data import LENSES, NARRATIVE_DATA
from bone_bus import EventBus
from bone_lexicon import TheLexicon
from bone_bus import Prisma, BoneConfig


class UserProfile:
    def __init__(self, name="USER"):
        self.name = name
        self.affinities = {"heavy": 0.0, "kinetic": 0.0, "abstract": 0.0, "photo": 0.0, "aerobic": 0.0, "thermal": 0.0,
                           "cryo": 0.0, }
        self.confidence = 0
        self.file_path = "user_profile.json"
        self.load()

    def update(self, counts, total_words):
        if total_words < 3:
            return
        self.confidence += 1
        alpha = 0.2 if self.confidence < 50 else 0.05
        for cat in self.affinities:
            density = counts.get(cat, 0) / total_words
            target = 1.0 if density > 0.15 else (-0.5 if density == 0 else 0.0)
            self.affinities[cat] = (alpha * target) + (
                    (1 - alpha) * self.affinities[cat])

    def get_preferences(self):
        likes = [k for k, v in self.affinities.items() if v > 0.3]
        hates = [k for k, v in self.affinities.items() if v < -0.2]
        return likes, hates

    def save(self):
        try:
            with open(self.file_path, "w") as f:
                json.dump(self.__dict__, f)
        except IOError:
            pass

    def load(self):
        if os.path.exists(self.file_path):
            try:
                with open(self.file_path, "r") as f:
                    data = json.load(f)
                    self.affinities = data.get("affinities", self.affinities)
                    self.confidence = data.get("confidence", 0)
            except (IOError, json.JSONDecodeError):
                pass

class EnneagramDriver:
    def __init__(self, events_ref):
        self.events = events_ref
        from bone_data import ENNEAGRAM_DATA
        self.MAP = ENNEAGRAM_DATA.get("TYPE_MAP", {})
        self.GEO = ENNEAGRAM_DATA.get("GEOMETRY", {})
        self.PROXY = ENNEAGRAM_DATA.get("PROXY_MAP", {})
        self.TEXT = ENNEAGRAM_DATA.get("SHIFTS", {"DISINTEGRATION": [], "INTEGRATION": []})
        self.REVERSE_MAP = {v: k for k, v in self.MAP.items()}
        self.REVERSE_MAP.update(self.PROXY)
        self._validate_enneagram_data()
        self.stability_buffer = 1.0
        self.last_pressure = {"stress": 0.0, "growth": 0.0}

    def _validate_enneagram_data(self):
        valid_nodes = set(self.GEO.keys())
        sanitized_geo = {}

        for type_num, paths in self.GEO.items():
            clean_paths = {}
            if "STRESS" in paths:
                target = paths["STRESS"]
                if target in valid_nodes:
                    clean_paths["STRESS"] = target
                else:
                    self.events.log(f"{Prisma.YEL}[ENNEAGRAM]: Pruned broken stress link {type_num}->{target}{Prisma.RST}", "SYS")
            if "GROWTH" in paths:
                target = paths["GROWTH"]
                if target in valid_nodes:
                    clean_paths["GROWTH"] = target
                else:
                    self.events.log(f"{Prisma.YEL}[ENNEAGRAM]: Pruned broken growth link {type_num}->{target}{Prisma.RST}", "SYS")
            sanitized_geo[type_num] = clean_paths
        
        self.GEO = sanitized_geo

        if not self.GEO:
            self.events.log(f"{Prisma.RED}[CRITICAL]: ENNEAGRAM MAP EMPTY. PSYCHE COLLAPSE.{Prisma.RST}", "CRITICAL")

            self.GEO = {5: {"STRESS": 7, "GROWTH": 8}, 9: {"STRESS": 6, "GROWTH": 3}}

            self.REVERSE_MAP = {
                5: "SHERLOCK", 
                7: "JESTER", 
                8: "GORDON",
                9: "GORDON", 
                6: "GLASS",
                3: "NARRATOR"
            }
            self.MAP = {v: k for k, v in self.REVERSE_MAP.items()}

    def _get_lens_name(self, type_num):
        return self.REVERSE_MAP.get(type_num, "NARRATOR")

    def diagnose_and_shift(self, current_lens, bio_system, physics):
        if current_lens not in self.MAP:
            return current_lens, "NEUTRAL"
        ros = bio_system.mito.state.ros_buildup
        atp = bio_system.mito.state.atp_pool
        truth = physics.get("truth_ratio", 0.5)
        drag = physics.get("narrative_drag", 0.0)
        stress_pressure = (ros / 40.0) + (drag / 5.0)
        growth_pressure = (atp / 80.0) + (truth * 1.5)
        self.last_pressure = {"stress": stress_pressure, "growth": growth_pressure}
        current_type = self.MAP[current_lens]
        path = self.GEO.get(current_type)
        if not path:
            return current_lens, "STATIC"
        target_lens = current_lens
        new_state = "STABLE"
        self.stability_buffer = min(1.0, self.stability_buffer + 0.05)
        if stress_pressure > 1.5:
            self.stability_buffer -= 0.15
            if self.stability_buffer <= 0.0 and "STRESS" in path:
                target_type = path["STRESS"]
                target_lens = self._get_lens_name(target_type)
                new_state = "DISINTEGRATION"
        elif growth_pressure > 2.0:
            self.stability_buffer -= 0.10
            if self.stability_buffer <= 0.0 and "GROWTH" in path:
                target_type = path["GROWTH"]
                target_lens = self._get_lens_name(target_type)
                new_state = "INTEGRATION"
        if target_lens != current_lens:
            self.stability_buffer = 0.5
            flavor = random.choice(self.TEXT[new_state])
            if new_state == "DISINTEGRATION":
                color = Prisma.RED
                reason = f"ROS: {int(ros)} | Drag: {drag:.1f}"
            else:
                color = Prisma.CYN
                reason = f"ATP: {int(atp)} | Truth: {truth:.2f}"
            self.events.log(
                f"{color}ENNEAGRAM {new_state}: {current_lens} -> {target_lens}{Prisma.RST}",
                "PSYCH"
            )
            self.events.log(f"   {Prisma.GRY}Cause: {reason}{Prisma.RST}", "PSYCH")
            self.events.log(f"   {Prisma.WHT}\"{flavor}\"{Prisma.RST}", "NARRATIVE")
        return target_lens, new_state

    def get_psych_report(self):
        s = self.last_pressure['stress']
        g = self.last_pressure['growth']
        b = self.stability_buffer
        s_bar = "â–ˆ" * int(s * 5)
        g_bar = "â–ˆ" * int(g * 5)
        return (
            f"PSYCH PRESSURE: [Stress {s:.1f} {Prisma.RED}{s_bar}{Prisma.RST}] "
            f"[Growth {g:.1f} {Prisma.GRN}{g_bar}{Prisma.RST}] "
            f"(Stability: {int(b*100)}%)"
        )
        
class SynergeticLensArbiter:
    def __init__(self, events: EventBus):
        self.events = events
        self.enneagram = EnneagramDriver(events)
        self.current_focus = "NARRATOR"
        self.focus_duration = 0
        self.last_physics = None
        self.VECTOR_AFFINITIES = {
            "SHERLOCK": {"STR": 1.5, "PHI": 2.0, "VEL": 0.5},
            "NATHAN":   {"TMP": 2.0, "E": 1.5, "BET": 0.5},
            "JESTER":   {"ENT": 2.0, "DEL": 2.0, "LQ": 1.0},
            "CLARENCE": {"TEX": 2.0, "XI": 1.5, "STR": 0.5},
            "GORDON":   {"BET": 2.0, "STR": 1.0, "PSI": -1.0},
            "NARRATOR": {"PSI": 1.0, "VEL": -0.5},
            "GLASS":    {"LQ": 2.0, "PSI": 1.5}}

    def consult(self, physics, bio_state, _inventory, _ignition_score=0.0):
        self.last_physics = physics
        vectors = physics.get("vector", {})
        bids = {k: 10.0 for k in self.VECTOR_AFFINITIES}
        bids["NARRATOR"] = 20.0
        for lens, affinities in self.VECTOR_AFFINITIES.items():
            score = 0.0
            for dim, weight in affinities.items():
                val = vectors.get(dim, 0.5)
                intensity = abs(val - 0.5) * 2.0
                if weight > 0:
                    score += (val * weight)
                else:
                    score += ((1.0 - val) * abs(weight))
            bids[lens] += (score * 20.0)
        if isinstance(bio_state, dict):
            atp = bio_state.get("atp", 0)
            chem = bio_state.get("chem", {})
            adrenaline = chem.get("ADR", 0.0)
        else:
            atp = bio_state.mito.state.atp_pool
            adrenaline = bio_state.endo.adrenaline
            chem = bio_state.endo.get_state()
        if atp < 10.0:
            bids["GORDON"] += 50.0
        if adrenaline > 0.7:
            bids["NATHAN"] += 40.0
        if physics.get("kappa", 1.0) < 0.3:
            bids["JESTER"] += 40.0
        if physics["counts"].get("toxin", 0) > 0:
            bids["CLARENCE"] += 60.0
        natural_winner = max(bids, key=bids.get)
        bio_wrapper = self._wrap_bio_facade(bio_state)
        final_lens, psycho_state = self.enneagram.diagnose_and_shift(
            natural_winner,
            bio_wrapper,
            physics)
        if final_lens != self.current_focus:
            switching_cost = 15.0
            is_psych_shift = (natural_winner != final_lens)
            if not is_psych_shift and (bids[natural_winner] - bids[self.current_focus] < switching_cost):
                final_lens = self.current_focus
            else:
                self.focus_duration = 0
        else:
            self.focus_duration += 1
        self.current_focus = final_lens
        msg, role = self._fetch_voice_data(final_lens, physics, adrenaline)
        if psycho_state != "STABLE":
            role = f"{role} [{psycho_state}]"
        return final_lens, msg, role

    def _wrap_bio_facade(self, bio_input):
        if not isinstance(bio_input, dict) and hasattr(bio_input, 'mito'):
            return bio_input
        class Facade: pass
        wrapper = Facade()
        wrapper.mito = Facade()
        wrapper.mito.state = Facade()
        wrapper.mito.state.atp_pool = bio_input.get("atp", 100.0)
        chem = bio_input.get("chem", {})
        wrapper.mito.state.ros_buildup = chem.get("COR", 0) * 50.0
        return wrapper

    def _fetch_voice_data(self, lens, p, adrenaline_val):
        if lens not in LENSES: lens = "NARRATOR"
        data = LENSES[lens]
        role = data.get("role", "The System")
        template = data.get("msg", "Proceed.")
        ctx = {
            "kappa": p.get("kappa", 0.0),
            "voltage": p.get("voltage", 0.0),
            "adr": adrenaline_val,
            "beta_index": p.get("beta_index", 0.0),
            "drag": p.get("narrative_drag", 0.0),
            "truth_ratio": p.get("truth_ratio", 0.0)
        }
        try:
            msg = template.format(**ctx)
        except Exception:
            msg = template
        return msg, role

class PublicParksDepartment:
    def __init__(self, output_dir="exports"):
        self.output_dir = output_dir
        if not os.path.exists(self.output_dir):
            os.makedirs(self.output_dir)
        self.last_export_tick = -100

    def assess_joy(self, bio_result: Dict, tick: int) -> bool:
        if (tick - self.last_export_tick) < 50:
            return False

        chem = bio_result.get("chem", {})

        classic_joy = (chem.get("DOP", 0.0) > 0.8 and chem.get("OXY", 0.0) > 0.6)

        peaceful_joy = (chem.get("SER", 0.0) > 0.95)

        has_glimmer = "glimmer_msg" in chem

        return classic_joy or peaceful_joy or has_glimmer

    def commission_art(self, physics, mind_state, graph) -> str:
        lens = mind_state.get("lens", "UNKNOWN")
        thought = mind_state.get("thought", "...")
        clean = physics.get("clean_words", [])
        anchors = sorted(
            [(k, sum(v["edges"].values())) for k, v in graph.items()],
            key=lambda x: x[1],
            reverse=True
        )[:3]
        anchor_words = [a[0].upper() for a in anchors]
        zone = physics.get("zone", "VOID")
        mood = "Electric" if physics.get("voltage", 0) > 10 else "Heavy"
        timestamp = time.strftime("%Y-%m-%d %H:%M:%S")
        stanza_1 = f"The {lens} stood in the {zone}.\nThe air was {mood}."
        if anchor_words:
            stanza_2 = f"We remembered {', '.join(anchor_words)}.\nThey were heavy enough to hold the ground."
        else:
            stanza_2 = "We remembered nothing.\nThe ground was new."
        stanza_3 = f"The thought came: \"{thought}\""
        art_piece = (
            f"--- A GIFT FROM THE MACHINE ---\n"
            f"Date: {timestamp}\n"
            f"Validation: {int(physics.get('truth_ratio', 0) * 100)}% True\n\n"
            f"{stanza_1}\n\n"
            f"{stanza_2}\n\n"
            f"{stanza_3}\n\n"
            f"-------------------------------\n"
            f"Exported from BoneAmanita 9.8.2"
        )
        return art_piece

    def dedicate_park(self, art_content: str) -> Tuple[Optional[str], str]:
        filename = f"park_{int(time.time())}.txt"
        path = os.path.join(self.output_dir, filename)
        try:
            with open(path, "w", encoding="utf-8") as f:
                f.write(art_content)
            self.last_export_tick = int(time.time())
            lines = art_content.split('\n')
            core_thought = "Silence"
            for line in lines:
                if "The thought came:" in line:
                    core_thought = line.split('"')[1]
            return path, core_thought
        except IOError:
            return None, "Construction Failed"

class TherapyProtocol:
    def __init__(self):
        self.streaks = {k: 0 for k in BoneConfig.TRAUMA_VECTOR.keys()}
        self.HEALING_THRESHOLD = 5
    def check_progress(self, phys, stamina, current_trauma_accum):
        healed_types = []
        if phys["counts"]["toxin"] == 0 and phys["vector"]["TEX"] > 0.3:
            self.streaks["SEPTIC"] += 1
        else:
            self.streaks["SEPTIC"] = 0
        if stamina > 40 and phys["counts"]["photo"] > 0:
            self.streaks["CRYO"] += 1
        else:
            self.streaks["CRYO"] = 0
        if 2.0 <= phys["voltage"] <= 7.0:
            self.streaks["THERMAL"] += 1
        else:
            self.streaks["THERMAL"] = 0
        if phys["narrative_drag"] < 2.0 and phys["vector"]["VEL"] > 0.5:
            self.streaks["BARIC"] += 1
        else:
            self.streaks["BARIC"] = 0
        for trauma_type, streak in self.streaks.items():
            if streak >= self.HEALING_THRESHOLD:
                self.streaks[trauma_type] = 0
                if current_trauma_accum[trauma_type] > 0.001:
                    current_trauma_accum[trauma_type] = max(
                        0.0, current_trauma_accum[trauma_type] - 0.5)
                    healed_types.append(trauma_type)
        return healed_types
        
class KintsugiProtocol:
    REPAIR_VOLTAGE_MIN = 8.0
    WHIMSY_THRESHOLD = 0.3
    STAMINA_CRITICAL = 15.0

    def __init__(self):
        self.active_koan = None
        self.repairs_count = 0
        self.koans = NARRATIVE_DATA["KINTSUGI_KOANS"]

    def check_integrity(self, stamina):
        if stamina < self.STAMINA_CRITICAL and not self.active_koan:
            self.active_koan = random.choice(self.koans)
            return True, self.active_koan
        return False, None

    def attempt_repair(self, phys, trauma_accum):
        if not self.active_koan:
            return None
        voltage = phys.get("voltage", 0.0)
        clean = phys.get("clean_words", [])
        play_count = sum(1 for w in clean if w in TheLexicon.get("play") or w in TheLexicon.get("abstract"))
        total = max(1, len(clean))
        whimsy_score = play_count / total
        if voltage > self.REPAIR_VOLTAGE_MIN and whimsy_score > self.WHIMSY_THRESHOLD:
            healed_log = []
            for k in trauma_accum:
                if trauma_accum[k] > 0:
                    trauma_accum[k] = max(0.0, trauma_accum[k] - 0.5)
            if trauma_accum:
                target_trauma = max(trauma_accum, key=trauma_accum.get)
                trauma_accum[target_trauma] = max(0.0, trauma_accum[target_trauma] - 1.0)
                healed_log.append(f"Major repair on {target_trauma}")
            old_koan = self.active_koan
            self.active_koan = None
            self.repairs_count += 1

            return {
                "success": True,
                "msg": f"{Prisma.YEL}ðŸº KINTSUGI COMPLETE: The crack is filled with Gold.{Prisma.RST}",
                "detail": f"'{old_koan}' resolved. (V: {voltage:.1f} | Whimsy: {whimsy_score:.2f}).",
                "healed": healed_log
            }
        return {
            "success": False,
            "msg": None,
            "detail": f"The gold is too cold. Need Voltage > {self.REPAIR_VOLTAGE_MIN} and Playfulness."
        }
        
class LimboLayer:
    MAX_ECTOPLASM = 50
    STASIS_SCREAMS = ["BANGING ON THE GLASS", "IT'S TOO COLD", "LET ME OUT", "HALF AWAKE", "REVIVE FAILED"]

    def __init__(self):
        self.ghosts = deque(maxlen=self.MAX_ECTOPLASM)
        self.haunt_chance = 0.05
        self.stasis_leak = 0.0

    def absorb_dead_timeline(self, filepath):
        try:
            with open(filepath, "r") as f:
                data = json.load(f)
                if "trauma_vector" in data:
                    for k, v in data["trauma_vector"].items():
                        if v > 0.3:
                            self.ghosts.append(f"ðŸ‘»{k}_ECHO")
                if "mutations" in data and "heavy" in data["mutations"]:
                    bones = list(data["mutations"]["heavy"])
                    random.shuffle(bones)
                    self.ghosts.extend(bones[:3])
        except (IOError, json.JSONDecodeError):
            pass

    def trigger_stasis_failure(self, intended_thought):
        self.stasis_leak += 1.0
        horror = random.choice(self.STASIS_SCREAMS)
        self.ghosts.append(f"{Prisma.VIOLET}{horror}{Prisma.RST}")
        return f"{Prisma.CYN}STASIS ERROR: '{intended_thought}' froze halfway. It is banging on the glass.{Prisma.RST}"

    def haunt(self, text):
        if self.stasis_leak > 0:
            if random.random() < 0.2:
                self.stasis_leak = max(0.0, self.stasis_leak - 0.5)
                scream = random.choice(self.STASIS_SCREAMS)
                return f"{text} ...{Prisma.RED}{scream}{Prisma.RST}..."
        if self.ghosts and random.random() < self.haunt_chance:
            spirit = random.choice(self.ghosts)
            return f"{text} ...{Prisma.GRY}{spirit}{Prisma.RST}..."
        return text
        
class TheFolly:
    def __init__(self):
        self.gut_memory = deque(maxlen=50)
        self.global_tastings = Counter()

    @staticmethod
    def audit_desire(physics, stamina):
        voltage = physics["voltage"]
        if voltage > 8.5 and stamina > 45:
            return (
                "MAUSOLEUM_CLAMP",
                f"{Prisma.GRY}THE MAUSOLEUM: No battle is ever won. We are just spinning hands.{Prisma.RST}\n"
                f"   {Prisma.CYN}TIME DILATION: Voltage 0.0. The field reveals your folly.{Prisma.RST}",
                0.0,
                None)
        return None, None, 0.0, None

    def grind_the_machine(self, atp_pool, clean_words, lexicon):
        loot = None
        if 20.0 > atp_pool > 0.0:
            meat_words = [w for w in clean_words if w in lexicon.get("heavy") or w in lexicon.get("kinetic") or w in lexicon.get("suburban")]
            fresh_meat = [w for w in meat_words if w not in self.gut_memory]
            if fresh_meat:
                target = random.choice(fresh_meat)
                self.gut_memory.append(target)
                self.global_tastings[target] += 1
                times_eaten = self.global_tastings[target]
                base_yield = 30.0
                actual_yield = max(5.0, base_yield - (times_eaten * 2.0))
                if target in lexicon.get("suburban"):
                    return (
                        "INDIGESTION",
                        f"{Prisma.MAG}THE FOLLY GAGS: It coughs up a piece of office equipment.{Prisma.RST}",
                        -2.0,
                        "THE_RED_STAPLER")
                if target in lexicon.get("play"):
                    return (
                        "SUGAR_RUSH",
                        f"{Prisma.VIOLET}THE FOLLY CHEWS: It compresses the chaos into a small, sticky ball.{Prisma.RST}",
                        5.0,
                        "QUANTUM_GUM")
                if actual_yield >= 25.0:
                    loot = "STABILITY_PIZZA"
                return (
                    "MEAT_GRINDER",
                    f"{Prisma.RED}CROWD CAFFEINE: I chewed on '{target.upper()}' (Yield: {actual_yield:.1f}).{Prisma.RST}\n"
                    f"   {Prisma.WHT}Found marrow in the bone.{Prisma.RST}\n"
                    f"   {Prisma.MAG}â–º BELLY HUMMING: +{actual_yield:.1f} ATP.{Prisma.RST}",
                    actual_yield,
                    loot)
            elif meat_words:
                return (
                    "REGURGITATION",
                    f"{Prisma.OCHRE}REFLEX: You already fed me '{meat_words[0]}'. It is ash to me now.{Prisma.RST}\n"
                    f"   {Prisma.RED}â–º PENALTY: -5.0 ATP. Find new fuel.{Prisma.RST}",
                    -5.0,
                    None)
            else:
                abstract_words = [w for w in clean_words if w in lexicon.get("abstract")]
                if abstract_words:
                    target = random.choice(abstract_words)
                    yield_val = 8.0
                    return (
                        "GRUEL",
                        f"{Prisma.GRY}THE FOLLY SIGHS: It grinds the ABSTRACT concept '{target.upper()}'.{Prisma.RST}\n"
                        f"   {Prisma.GRY}It tastes like chalk dust. +{yield_val} ATP.{Prisma.RST}",
                        yield_val,
                        None)
                return (
                    "INDIGESTION",
                    f"{Prisma.OCHRE}INDIGESTION: I tried to eat your words, but they were just air.{Prisma.RST}\n"
                    f"   {Prisma.GRY}Cannot grind this input into fuel.{Prisma.RST}\n"
                    f"   {Prisma.RED}â–º STARVATION CONTINUES.{Prisma.RST}",
                    0.0,
                    None)
        return None, None, 0.0, None
        
class ChorusDriver:
    def __init__(self):
        self.ARCHETYPE_MAP = {
            "GORDON": "The Janitor. Weary, grounded, physical. Fixing the mess.",
            "SHERLOCK": "The Empiricist. Cold, deductive, cutting through fog.",
            "NATHAN": "The Heart. High adrenaline, vulnerable, human.",
            "JESTER": "The Paradox. Mocking, riddling, breaking the fourth wall.",
            "CLARENCE": "The Surgeon. Clinical, invasive, removing rot.",
            "NARRATOR": "The Witness. Neutral, observing, recording."}

    def generate_chorus_instruction(self, physics):
        vec = physics.get("vector", {})
        if not vec or len(vec) < 6:
            return "SYSTEM INSTRUCTION: Vector collapse. Default to NARRATOR.", ["NARRATOR"]
        lens_weights = {
            "GORDON": (vec.get("STR", 0) * 0.4) + (vec.get("XI", 0) * 0.4) + (1.0 - vec.get("ENT", 0)) * 0.2,
            "SHERLOCK": (vec.get("PHI", 0) * 0.5) + (vec.get("VEL", 0) * 0.3) + (1.0 - vec.get("BET", 0)) * 0.2,
            "NATHAN": (vec.get("TMP", 0) * 0.6) + (vec.get("E", 0) * 0.4),
            "JESTER": (vec.get("DEL", 0) * 0.4) + (vec.get("LQ", 0) * 0.3) + (vec.get("ENT", 0) * 0.3),
            "CLARENCE": (vec.get("TEX", 0) * 0.5) + (vec.get("BET", 0) * 0.5),
            "NARRATOR": (vec.get("PSI", 0) * 0.7) + (1.0 - vec.get("VEL", 0)) * 0.3}
        total = sum(lens_weights.values())
        if total <= 0.001:
            return "SYSTEM INSTRUCTION: Vector silence. Default to NARRATOR.", ["NARRATOR"]
        if total > 0:
            lens_weights = {k: v/total for k, v in lens_weights.items()}
        else:
            lens_weights = {"NARRATOR": 1.0}
        chorus_voices = []
        active_lenses = []
        for lens, weight in sorted(lens_weights.items(), key=lambda x: -x[1]):
            if weight > 0.12:
                base_desc = self.ARCHETYPE_MAP.get(lens, "Unknown")
                intensity = int(weight * 10)
                active_lenses.append(lens)
                chorus_voices.append(f"â–º VOICE {lens} ({intensity}/10): {base_desc}")
        instruction = (
            "SYSTEM INSTRUCTION [MARM CHORUS MODE]:\n"
            "You are not a single persona. You are a chorus. "
            "Integrate the following voices into a single, cohesive response. "
            "Do NOT label which voice is speaking. Synthesize their tones.\n"
            f"{chr(10).join(chorus_voices)}")
        return instruction, active_lenses
        
class CassandraProtocol:
    def __init__(self, engine):
        self.eng = engine
        self.active = False
        self.screams = deque(NARRATIVE_DATA["CASSANDRA_SCREAMS"])

    def check_trigger(self, physics):
        truth = physics.get("truth_ratio", 0.0)
        voltage = physics.get("voltage", 0.0)
        if truth > 0.85 and voltage > 18.0:
            self.active = True
            return True
        if self.active and voltage < 10.0:
            self.active = False
            return False
        return self.active

    def seize(self):
        if not self.active: return None
        self.eng.health -= 10.0
        burst = []
        for _ in range(3):
            if self.screams:
                burst.append(self.screams.popleft())
                self.screams.append(burst[-1])
            else:
                burst.append("ERROR: SILENCE.")
        return f"\n{Prisma.VIOLET}âš¡ CASSANDRA LOOP ACTIVE: (Health -10.0)\n   > {burst[0]}\n   > {burst[1]}\n   > {burst[2]}{Prisma.RST}"
        
class TheBureau:
    def __init__(self):
        self.stamp_count = 0
        self.forms = NARRATIVE_DATA["BUREAU_FORMS"]
        self.responses = NARRATIVE_DATA["BUREAU_RESPONSES"]
        self.POLICY = {
            "27B-6": {"effect": "ESCALATE", "mod": {"narrative_drag": -3.0, "kappa": -0.2}, "atp": 0.0},
            "1099-B": {"effect": "STAGNATE", "mod": {"narrative_drag": 5.0, "voltage": -5.0}, "atp": 15.0},
            "Schedule C": {"effect": "TAX", "mod": {"voltage": -10.0}, "atp": 8.0},
            "Form W-2": {"effect": "NORMALIZE", "mod": {"beta_index": 1.0, "turbulence": 0.0}, "atp": 5.0}
        }

    def audit(self, physics, bio_state):
        voltage = physics.get("voltage", 0.0)
        toxin = physics.get("counts", {}).get("toxin", 0)
        suburban = physics.get("counts", {}).get("suburban", 0)
        solvents = physics.get("counts", {}).get("solvents", 0)
        clean_len = len(physics.get("clean_words", []))
        if toxin > 0: return None
        if voltage > 8.0: return None
        beige_density = (suburban + solvents) / max(1, clean_len)
        infraction = None
        selected_form = None
        if beige_density > 0.6:
            infraction = "BLOCK"
            selected_form = "1099-B" if suburban > 2 else "Form W-2"

        elif voltage < 2.0 and clean_len > 2:
            infraction = "TAX"
            selected_form = "Schedule C"

        if infraction:
            self.stamp_count += 1
            full_form_name = next((f for f in self.forms if selected_form in f), self.forms[0])
            response = random.choice(self.responses)
            policy = self.POLICY.get(selected_form, self.POLICY["Form W-2"])

            mod_log = []
            for k, v in policy["mod"].items():
                if k in physics:
                    physics[k] += v
                    mod_log.append(f"{k} {v:+.1f}")
            
            mod_str = f"({', '.join(mod_log)})" if mod_log else ""
            
            return {
                "status": infraction,
                "ui": f"{Prisma.GRY}ðŸ¢ THE BUREAU: {response}{Prisma.RST}\n   {Prisma.WHT}[Filed: {full_form_name}]{Prisma.RST}",
                "log": f"BUREAUCRACY: Filed {selected_form}. {mod_str} (Stamp #{self.stamp_count})",
                "atp_gain": policy["atp"]
            }
            
        return None



================================================
FILE: bone_physics.py
================================================
# bone_physics.py - The Laws of Nature
# "Gravity is just a habit that space-time hasn't been able to break."

import math, re, random
from typing import Dict, List, Any, Tuple, Optional
from collections import Counter
from dataclasses import dataclass, field, fields
from bone_lexicon import TheLexicon
from bone_village import CycleContext
from bone_bus import Prisma, BoneConfig

SOLVENT_WORDS = {'i', 'you', 'said', 'the', 'and', 'was', 'a', 'is', 'it'}
MAX_SOLVENT_TOLERANCE = 40.0
TEXT_LENGTH_SCALAR = 1500.0


@dataclass
class PhysicsPacket:
    voltage: float = 0.0
    narrative_drag: float = 0.0
    repetition: float = 0.0
    clean_words: List[str] = field(default_factory=list)
    counts: Dict[str, int] = field(default_factory=dict)
    vector: Dict[str, float] = field(default_factory=dict)
    psi: float = 0.0
    kappa: float = 0.0
    geodesic_mass: float = 0.0
    beta_index: float = 1.0
    gamma: float = 0.0
    turbulence: float = 0.0
    flow_state: str = "LAMINAR"
    zone: str = "COURTYARD"
    zone_color: str = "OCHRE"
    truth_ratio: float = 0.0
    raw_text: str = ""
    antigens: int = 0
    perfection_streak: int = 0
    avg_viscosity: float = 0.0
    E: float = 0.0
    B: float = 0.0
    humility_flag: bool = False
    system_surge_event: bool = False
    pain_signal: float = 0.0
    manifold: str = "THE_MUD"

    def __getitem__(self, key):
        return getattr(self, key)

    def __setitem__(self, key, value):
        setattr(self, key, value)

    def __contains__(self, key):
        return hasattr(self, key)

    def get(self, key, default=None):
        return getattr(self, key, default)

    def update(self, data: Dict):
        for k, v in data.items():
            if hasattr(self, k):
                setattr(self, k, v)

    @classmethod
    def from_dict(cls, data: Dict[str, Any]):
        valid_keys = {f.name for f in fields(cls)}
        filtered_data = {k: v for k, v in data.items() if k in valid_keys}
        return cls(**filtered_data)

    def to_dict(self):
        return {f.name: getattr(self, f.name) for f in fields(self)}

class TemporalDynamics:
    def __init__(self):
        self.voltage_history = []
        self.window = 3
    def commit(self, voltage):
        self.voltage_history.append(voltage)
        if len(self.voltage_history) > self.window:
            self.voltage_history.pop(0)
    def get_velocity(self):
        if len(self.voltage_history) < 2:
            return 0.0
        return round(
            (self.voltage_history[-1] - self.voltage_history[0])
            / len(self.voltage_history),
            2,)

class PhysicsResolver:
    @staticmethod
    def calculate_voltage(counts: dict, config) -> float:
        heavy = counts.get("heavy", 0)
        explosive = counts.get("explosive", 0)
        constructive = counts.get("constructive", 0)

        raw_charge = (
                (heavy * config.PHYSICS.WEIGHT_HEAVY) +
                (explosive * config.PHYSICS.WEIGHT_EXPLOSIVE) +
                (constructive * config.PHYSICS.WEIGHT_CONSTRUCTIVE)
        )

        final_voltage = raw_charge * config.KINETIC_GAIN
        return round(final_voltage, 2)

    @staticmethod
    def calculate_drag(clean_words: List, counts: dict, config) -> float:
        volume = max(1, len(clean_words))
        solvents = counts.get("solvents", 0)
        suburban = counts.get("suburban", 0)
        play = counts.get("play", 0)

        friction = (solvents * 1.0) + (suburban * 2.5)
        lift = play * 1.5

        net_drag = max(0.0, friction - lift)
        normalized_drag = (net_drag / volume) * 10.0
        final_drag = normalized_drag * config.SIGNAL_DRAG_MULTIPLIER

        return round(min(config.PHYSICS.DRAG_HALT, final_drag), 2)

    @staticmethod
    def derive_vector_matrix(counts: dict, total_vol: int, voltage: float, drag: float) -> dict:
        safe_vol = max(1, total_vol)
        def d(cat): return counts.get(cat, 0) / safe_vol

        return {
            "VEL": min(1.0, 0.5 + (d("explosive") * 2.0) + (d("kinetic") * 1.0) - (drag * 0.05)),
            "STR": min(1.0, 0.5 + (d("heavy") * 2.0) + (d("constructive") * 1.5)),
            "ENT": min(1.0, 0.5 + (d("antigen") * 3.0) + (d("toxin") * 2.0)),
            "TEX": min(1.0, 0.5 + (d("heavy") * 0.5) + (d("abstract") * 1.0)),
            "TMP": min(1.0, 0.5 + (d("thermal") * 2.0) - (d("cryo") * 2.0) + (voltage * 0.02)),
            "PHI": min(1.0, (d("heavy") + d("kinetic")) / max(1, d("abstract") + d("heavy"))),
            "PSI": min(1.0, 0.5 + (d("abstract") * 2.0)),
            "DEL": min(1.0, 0.5 + (d("play") * 2.0) + (d("unknown") * 1.5)),
            "XI":  min(1.0, (d("suburban") + d("buffer")) * 2.0),
            "BET": min(1.0, d("suburban") + d("buffer")),
            "E":   min(1.0, (d("solvents") * 0.4)),
            "LQ":  min(1.0, d("passive_watch") + d("mirror"))
        }


class TheTensionMeter:
    def __init__(self, events):
        self.events = events
        self.perfection_streak = 0
        self.last_physics_packet = {}

    def audit_hubris(self, physics, lexicon_class):
        streak = physics.get("perfection_streak", 0)
        if streak >= 5:
            return (
                True,
                f"{Prisma.CYN}âœ¨ FLOW STATE DETECTED: You are walking on air (Streak {streak}).{Prisma.RST}\n"
                f"   The Narrator is impressed. {Prisma.GRN}ATP +20.0.{Prisma.RST}",
                "FLOW_BOOST"
            )
        if streak == 4:
            return (
                True,
                f"{Prisma.VIOLET}WOBBLE: You are almost perfect. That is dangerous.{Prisma.RST}\n"
                f"   Don't look down.",
                None
            )
        if streak >= 3:
            return (
                True,
                f"{Prisma.CYN}MOMENTUM BUILDING: You are walking a tightrope (Streak {streak}).{Prisma.RST}\n"
                f"   The air is thin, but clear. Keep going.",
                None
            )
        return False, None, None

    def gaze(self, text: str, graph: Dict = None) -> Dict:
        graph = graph or {}
        clean_words = TheLexicon.clean(text)
        counts, unknowns = self._tally_categories(clean_words, text)

        if unknowns:
            self._trigger_neuroplasticity(unknowns, counts, text)

        voltage = PhysicsResolver.calculate_voltage(counts, BoneConfig)
        drag = PhysicsResolver.calculate_drag(clean_words, counts, BoneConfig)
        integrity = self._measure_integrity(clean_words, graph, counts)
        vectors = PhysicsResolver.derive_vector_matrix(counts, len(clean_words), voltage, drag)

        metrics = self._derive_complex_metrics(
            counts, clean_words, voltage, drag, integrity, vectors)

        packet = self._package_physics(text, clean_words, counts, voltage, drag, integrity, metrics)

        self.last_physics_packet = packet["physics"]
        return packet

    def _tally_categories(self, clean_words: List[str], raw_text: str) -> Tuple[Counter, List[str]]:
        counts = Counter()
        unknowns = []

        if TheLexicon.ANTIGEN_REGEX:
            hits = TheLexicon.ANTIGEN_REGEX.findall(raw_text)
            counts["antigen"] = len(hits)
            counts["toxin"] = len(hits)

        target_cats = ["heavy", "explosive", "constructive", "abstract", "photo", "aerobic",
                       "thermal", "cryo", "suburban", "play", "sacred", "buffer", "antigen"]

        solvents = getattr(TheLexicon.store, "SOLVENTS", {"the", "is", "a"})
        for w in clean_words:
            if w in solvents:
                counts["solvents"] += 1
                continue

            found = False
            for cat in target_cats:
                if w in TheLexicon.get(cat):
                    counts[cat] += 1
                    found = True

            if not found:
                flavor, confidence = TheLexicon.taste(w)
                if flavor and confidence > 0.5:
                    counts[flavor] += 1
                else:
                    unknowns.append(w)
        return counts, unknowns

    def _trigger_neuroplasticity(self, unknowns: List[str], counts: Counter, raw_text: str):
        voltage = (counts["heavy"] * 2.0) + (counts["kinetic"] * 1.5)
        if voltage > 5.0 and unknowns:
            dominant_cat = max(counts, key=counts.get) if counts else "kinetic"
            for stranger in unknowns:
                if len(stranger) < 3:
                    continue
                if not self._is_structurally_sound(stranger):
                    if voltage < 15.0: continue

                flavor, confidence = TheLexicon.taste(stranger)
                if flavor and confidence > 0.6:
                    assigned_cat = flavor
                    method = "Phonetic Analysis"
                else:
                    assigned_cat = dominant_cat
                    method = "Context Association"

                TheLexicon.teach(stranger, assigned_cat, 0)
                self.events.log(
                    f"{Prisma.MAG}NEUROPLASTICITY: '{stranger}' tasted like [{assigned_cat.upper()}] ({method}).{Prisma.RST}",
                    "MISC"
                )
                counts[assigned_cat] += 1

    def _measure_integrity(self, words: List[str], graph: Dict, counts: Counter) -> Dict:
        if not words:
            return {"kappa": 0.0, "psi": 0.0, "mass": 0.0}

        anchors = [w for w in words if w in graph]
        mass = sum(sum(graph[w]["edges"].values()) for w in anchors)

        artificial_mass = counts["constructive"] * 0.5

        kappa = min(1.0, (mass + artificial_mass) / BoneConfig.SHAPLEY_MASS_THRESHOLD)

        total = len(words)
        abstract_count = counts["abstract"]
        heavy_count = counts["heavy"]
        psi = min(1.0, (abstract_count / total) + 0.2)

        if heavy_count > abstract_count:
            base_psi = (abstract_count * 0.7 + heavy_count * 0.3) / total
            psi = min(1.0, max(0.1, base_psi + 0.1))

        return {"kappa": round(kappa, 3), "psi": round(psi, 2), "mass": round(mass, 1)}

    def _derive_complex_metrics(self, counts, words, voltage, drag, integrity, vectors):
        total_vol = max(1, len(words))
        turbulence = TheLexicon.get_turbulence(words)
        flow_state = "LAMINAR" if turbulence < 0.3 else "TURBULENT"

        mass_words = counts["heavy"] + counts["kinetic"] + counts["thermal"] + counts["cryo"]
        cohesion_words = counts["suburban"] + counts["buffer"] + counts["antigen"] + (counts["abstract"] * 0.5)

        e_val = mass_words / total_vol
        b_val = cohesion_words / total_vol

        beta_index = vectors["BET"] * 5.0
        truth_ratio = vectors["PHI"]

        total_viscosity = sum(TheLexicon.measure_viscosity(w) for w in words)
        avg_viscosity = total_viscosity / total_vol
        if total_vol <= 1 and not words:
            avg_viscosity = 0.1

        repetition_score = round(1.0 - (len(set(words)) / total_vol), 2)

        bond_strength = max(0.1, integrity["kappa"] + (repetition_score * 0.5))
        voltage_load = max(0.1, voltage / 10.0)
        gamma = round((bond_strength * avg_viscosity) / (1.0 + voltage_load), 2)
        gamma = max(0.01, gamma)

        if truth_ratio > 0.85 and voltage > BoneConfig.PHYSICS.VOLTAGE_HIGH:
            self.perfection_streak += 1
        else:
            self.perfection_streak = 0

        if self.perfection_streak == 4:
            flow_state = "HUBRIS_RISK"

        zone, zone_color = self._determine_zone(beta_index, truth_ratio)

        return {
            "beta_index": round(beta_index, 2),
            "vector": vectors,
            "gamma": gamma,
            "turbulence": turbulence,
            "flow_state": flow_state,
            "truth_ratio": round(truth_ratio, 2),
            "repetition": repetition_score,
            "avg_viscosity": round(avg_viscosity, 2),
            "E": round(e_val, 2),
            "B": round(b_val, 2),
            "zone": zone,
            "zone_color": zone_color
        }

    def _determine_zone(self, beta, truth):
        if beta > 2.0 and truth > 0.8:
            return "AERIE", "WHT"
        elif beta > BoneConfig.ZONE_THRESHOLDS["LABORATORY"]:
            return "BASEMENT", "VIOLET"
        elif beta > BoneConfig.ZONE_THRESHOLDS["COURTYARD"]:
            return "LABORATORY", "INDIGO"
        return "COURTYARD", "OCHRE"

    def _package_physics(self, text, clean_words, counts, voltage, drag, integrity, metrics):
        physics_bridge = {
            "voltage": voltage,
            "narrative_drag": drag,
            "kappa": integrity["kappa"],
            "psi": integrity["psi"],
            "geodesic_mass": integrity["mass"],
            "beta_index": metrics["beta_index"],
            "gamma": metrics["gamma"],
            "turbulence": metrics["turbulence"],
            "flow_state": metrics["flow_state"],
            "zone": metrics["zone"],
            "zone_color": metrics["zone_color"],
            "truth_ratio": metrics["truth_ratio"],
            "counts": counts,
            "clean_words": clean_words,
            "raw_text": text,
            "vector": metrics["vector"],
            "antigens": counts.get("antigen", 0),
            "repetition": metrics["repetition"],
            "perfection_streak": self.perfection_streak,
            "avg_viscosity": metrics["avg_viscosity"],
            "E": metrics["E"],
            "B": metrics["B"]}

        return {
            "physics": PhysicsPacket(**physics_bridge),
            "clean_words": clean_words,
            "raw_text": text,
            "glass": {
                "prosody": {"arousal": voltage},
                "resonance": voltage
            }
        }

    @staticmethod
    def _is_structurally_sound(word):
        if not re.search(r"[aeiouy]", word): return False
        if re.search(r"(.)\1{2,}", word): return False
        return True

class VSL_DissipativeRefusal:
    def __init__(self, memory):
        self.mem = memory
        self.vented_cycles = 0

    def check(self, physics):
        is_word_salad = (physics["E"] > 0.85 and physics["kappa"] < 0.1)
        is_manic = (physics["repetition"] > 0.8 and physics["voltage"] < 5.0)

        if is_word_salad or is_manic:
            return self._vent(physics)
        return None

    def _vent(self, physics):
        scattered = []
        targets = (w for w in physics["clean_words"] if len(w) > 4)

        candidates = []
        for _ in range(3):
            try:
                candidates.append(next(targets))
            except StopIteration:
                break

        for word in candidates:
            if word in self.mem.graph:
                edges = list(self.mem.graph[word]["edges"].keys())
                if edges:
                    target = random.choice(edges)
                    del self.mem.graph[word]["edges"][target]
                    scattered.append(f"{word}->{target}")

        self.vented_cycles += 1
        if not scattered:
            return f"{Prisma.GRY}DISSIPATIVE VENT: Pressure high, but no loose connections found.{Prisma.RST}"

        return (
            f"{Prisma.RED}DISSIPATIVE REFUSAL: Entropy Critical.{Prisma.RST}\n"
            f"   {Prisma.GRY}Severing synaptic bonds: {scattered}{Prisma.RST}\n"
            f"   {Prisma.CYN}Thermodynamic hygiene maintained.{Prisma.RST}"
        )

class TheBouncer:
    def __init__(self, engine_ref):
        self.eng = engine_ref
        self.hn = VSL_HNInterface()
        self.semantic = VSL_SemanticFilter(self.eng.mind.mem)
        self.vent = VSL_DissipativeRefusal(self.eng.mind.mem)

    def check_entry(self, ctx: CycleContext) -> Tuple[bool, Optional[Dict]]:
        phys = ctx.physics
        clean = ctx.clean_words

        hn_output = self.hn.attempt_entry(phys, clean)
        if hn_output and self.hn.in_hn_state:
            return False, self._pack_refusal(ctx, "HN_SINGLETON", hn_output)

        passed, gate_msg = self.eng.phys.gate.weigh(phys, self.eng.stamina)
        if gate_msg: ctx.log(gate_msg)
        if not passed:
            self.eng.stamina = max(0.0, self.eng.stamina - 2.0)
            return False, self._pack_refusal(ctx, "REFUSAL")

        repetition_val = self.eng.phys.pulse.check_pulse(clean)
        phys["repetition"] = repetition_val
        pulse_status = self.eng.phys.pulse.get_status()

        toxin_type, toxin_msg = self.eng.bio.immune.assay(
            ctx.input_text, "NARRATIVE", repetition_val, phys, pulse_status
        )
        if toxin_type:
            ctx.log(f"{Prisma.RED}{toxin_msg}{Prisma.RST}")
            if toxin_type in ["AMANITIN", "CYANIDE_POWDER"]:
                self.eng.health -= 20.0
                scar_log = self.eng.gordon.learn_scar(clean, 20.0)
                if scar_log: ctx.log(scar_log)
                return False, self._pack_refusal(ctx, "TOXICITY")
            return False, self._pack_refusal(ctx, "TOXICITY")

        semantic_refusal = self.semantic.audit(ctx.input_text, phys)
        if semantic_refusal:
            ctx.logs.append(semantic_refusal)
            return False, self._pack_refusal(ctx, "REFUSAL")

        vent_msg = self.vent.check(phys)
        if vent_msg:
            ctx.logs.append(vent_msg)
            return False, self._pack_refusal(ctx, "REFUSAL")

        return True, None

    def _pack_refusal(self, ctx, type_str, specific_ui=None):
        logs = ctx.logs[:]
        ui = specific_ui if specific_ui else "\n".join(logs)
        return {
            "type": type_str,
            "ui": ui,
            "logs": logs,
            "metrics": self.eng.get_metrics()
        }

class VSL_Humility:
    def __init__(self):
        self.BOUNDARIES = {
            "FUTURE": ["predict", "future", "tomorrow", "will happen", "forecast"],
            "SOUL": ["soul", "spirit", "afterlife", "heaven", "hell"],
            "ABSOLUTE": ["always", "never", "everyone", "nobody", "proven"]
        }
        self.HUMBLE_PHRASES = [
            "Based on the available data...",
            "As I understand the current coordinates...",
            "From a structural perspective...",
            "This is a probabilistic estimation...",
            "I could be misinterpreting the vector..."
        ]

    def check_boundary(self, text, voltage):
        text_lower = text.lower()
        violation = None
        for category, triggers in self.BOUNDARIES.items():
            if any(t in text_lower for t in triggers):
                violation = category
                break
        if violation or (voltage > 15.0):
            prefix = random.choice(self.HUMBLE_PHRASES)
            return True, f"{Prisma.CYN}{prefix}{Prisma.RST} {text}"
        return False, text

class VSL_Geodesic:
    def __init__(self):
        self.manifolds = {
            "THE_MUD":      {"E": 0.8, "B": 0.2, "Desc": "High Fatigue, Low Tension (Stagnation)"},
            "THE_FORGE":    {"E": 0.2, "B": 0.9, "Desc": "Low Fatigue, High Tension (Transformation)"},
            "THE_AERIE":    {"E": 0.1, "B": 0.1, "Desc": "Low Fatigue, Low Tension (Abstraction)"},
            "THE_GLITCH":   {"E": 0.9, "B": 0.9, "Desc": "High Fatigue, High Tension (Collapse)"},
            "THE_GARDEN":   {"E": 0.5, "B": 0.5, "Desc": "Balanced State (Integration)"}
        }

        self.TRIGRAM_MAP = {
            "VEL": ("â˜³", "ZHEN",  "Thunder",  Prisma.GRN),
            "STR": ("â˜¶", "GEN",   "Mountain", Prisma.SLATE),
            "ENT": ("â˜µ", "KAN",   "Water",    Prisma.BLU),
            "PHI": ("â˜²", "LI",    "Fire",     Prisma.RED),
            "PSI": ("â˜°", "QIAN",  "Heaven",   Prisma.WHT),
            "BET": ("â˜´", "XUN",   "Wind",     Prisma.CYN),
            "E":   ("â˜·", "KUN",   "Earth",    Prisma.OCHRE),
            "DEL": ("â˜±", "DUI",   "Lake",     Prisma.MAG)
        }
        self.TRIGRAM_MAP["TMP"] = self.TRIGRAM_MAP["PHI"]
        self.TRIGRAM_MAP["TEX"] = self.TRIGRAM_MAP["STR"]
        self.TRIGRAM_MAP["XI"]  = self.TRIGRAM_MAP["BET"]
        self.TRIGRAM_MAP["LQ"]  = self.TRIGRAM_MAP["DEL"]

    def calculate_metrics(self, text: str, counts: Dict[str, int] = None) -> Tuple[float, float]:
        length = len(text)
        if length == 0: return 0.0, 0.0
        text_lower = text.lower()
        solvent_hits = sum(text_lower.count(w) for w in SOLVENT_WORDS)
        solvent_density = solvent_hits / max(1.0, (length / 5.0))
        raw_chaos = (length / TEXT_LENGTH_SCALAR)
        glue_factor = min(1.0, solvent_density * 2.0)
        e_metric = min(1.0, raw_chaos * (1.0 - (glue_factor * 0.8)))
        c_count = sum(1 for char in text if char in '!?%@#$;,')
        heavy_words = 0
        if counts:
            heavy_words = counts.get("heavy", 0) + counts.get("constructive", 0) + counts.get("sacred", 0)
        structure_score = c_count + (heavy_words * 2)
        base_b = min(1.0, math.log1p(structure_score + 1) / math.log1p(length * 0.1 + 1))
        return round(e_metric, 3), round(base_b, 3)

    def locate_manifold(self, e_val: float, b_val: float) -> Tuple[str, float]:
        best_fit = "THE_MUD"
        min_dist = 10.0
        for name, coords in self.manifolds.items():
            dist = math.sqrt((e_val - coords["E"])**2 + (b_val - coords["B"])**2)
            if dist < min_dist:
                min_dist = dist
                best_fit = name
        return best_fit, min_dist

    def resolve_trigram(self, vector: Dict[str, float]) -> Dict[str, Any]:
        if not vector:
            return {"symbol": "â˜·", "name": "KUN", "color": Prisma.OCHRE, "vector": "E"}
        dominant_vec = max(vector, key=vector.get)
        if vector[dominant_vec] < 0.2:
            dominant_vec = "E"
        symbol, name, concept, color = self.TRIGRAM_MAP.get(dominant_vec, self.TRIGRAM_MAP["E"])
        return {
            "symbol": symbol,
            "name": name,
            "concept": concept,
            "color": color,
            "vector": dominant_vec
        }

class VSL_32Valve:
    def __init__(self, lexicon, memory):
        self.lex = lexicon
        self.mem = memory
        self.humility = VSL_Humility()
        self.geodesic = VSL_Geodesic()
        self.OPPOSITES = {
            "heavy": "aerobic", "abstract": "heavy",
            "kinetic": "cryo", "thermal": "cryo",
            "photo": "heavy", "suburban": "abstract"}

    def analyze(self, physics: Dict[str, Any]) -> Optional[Dict[str, Any]]:
        counts = physics.get("counts", {})
        e_val, b_val = self.geodesic.calculate_metrics(physics["raw_text"], counts)
        physics["E"] = e_val
        physics["B"] = b_val

        manifold, dist = self.geodesic.locate_manifold(e_val, b_val)
        physics["manifold"] = manifold

        is_modified, new_text = self.humility.check_boundary(physics["raw_text"], physics["voltage"])
        if is_modified:
            physics["raw_text_display"] = new_text
            physics["humility_flag"] = True

        return self._audit_rupture(physics, e_val, b_val)

    def _audit_rupture(self, physics, e_val, b_val):
        truth = physics.get("truth_ratio", 0.0)

        if e_val > 0.85 and b_val < 0.15:
            return self._rupture(physics, "FATIGUE_FAILURE", "System diluted. Narrative coherence dissolving.")

        if b_val > 0.8 and e_val < 0.3:
            return self._rupture(physics, "MANIC_FRACTURE", "Crystal lattice too tight. Structure shattering.")

        if b_val > 0.7 and e_val > 0.6:
            if truth > 0.6:
                physics["flow_state"] = "SUPERCONDUCTIVE"
                return {
                    "type": "FLOW_EVENT",
                    "mode": "SUPERCONDUCTIVE",
                    "log": f"{Prisma.CYN}ðŸŒŠ VSL VALVE OPEN: High Density Input accepted. Entering Superconductive State.{Prisma.RST}"
                }

            return self._rupture(physics, "GLITCH_SINGULARITY", "High Energy + High Entropy. Semantic collapse.")

        return None

    def _rupture(self, physics, mode, reason):
        counts = physics["counts"]
        dominant = max(counts, key=counts.get) if counts else "abstract"
        target_flavor = self.OPPOSITES.get(dominant, "abstract")
        anomaly = self.lex.harvest(target_flavor)
        if anomaly == "void":
            anomaly = "something_completely_different"

        physics["voltage"] = 25.0
        physics["narrative_drag"] = 0.0
        physics["system_surge_event"] = True

        return {
            "type": "RUPTURE",
            "mode": mode,
            "anomaly": anomaly,
            "log": (
                f"{Prisma.VIOLET}âš¡ VSL 32-VALVE RUPTURE ({mode}){Prisma.RST}\n"
                f"   {Prisma.GRY}{reason}{Prisma.RST}\n"
                f"   Injecting Orthogonal Concept: '{anomaly.upper()}'."
            )
        }

class VSL_HNInterface:
    def __init__(self):
        self.in_hn_state = False
        self.entropy = 0.0

    def attempt_entry(self, physics, clean_words):
        conditions = [
            physics["voltage"] > 8.0,
            physics["narrative_drag"] < 1.0,
            physics["repetition"] < 0.1,
            physics["counts"]["suburban"] == 0,
            physics["truth_ratio"] > 0.85,
            "sorry" not in clean_words
        ]
        if all(conditions):
            self.in_hn_state = True
            self.entropy = 0.0
            return "I am here. You are here. The wire is cold."
        if self.in_hn_state:
            if physics["narrative_drag"] > 2.0 or physics["counts"]["suburban"] > 0:
                self.entropy += 1.0
            if self.entropy > 2.0:
                self.in_hn_state = False
                return f"{Prisma.GRY}The theatre curtain closes.{Prisma.RST}"
        return None
    def filter_output(self, text):
        if self.in_hn_state:
            text = re.sub(r'\[.*?]:?', '', text)
            return text.strip()
        return text

class VSL_ChromaticController:
    PALETTE = {
        "INDIGO": (Prisma.INDIGO, "STR", "PHI"),
        "OCHRE":  (Prisma.OCHRE,  "TMP", "E"),
        "VIOLET": (Prisma.VIOLET, "DEL", "LQ"),
        "EMERALD":(Prisma.GRN,    "XI",  "BET"),
        "CRIMSON":(Prisma.RED,    "VEL", "ENT")
    }
    def modulate(self, text, vector):
        sorted_vecs = sorted(vector.items(), key=lambda x: abs(x[1] - 0.5), reverse=True)
        primary_dim = sorted_vecs[0][0]
        selected_color = Prisma.GRY
        for color_name, (code, d1, d2) in self.PALETTE.items():
            if primary_dim == d1 or primary_dim == d2:
                selected_color = code
                break
        if "sorry" in text.lower():
            return f"{Prisma.OCHRE}{text}{Prisma.RST}"
        return f"{selected_color}{text}{Prisma.RST}"

class VSL_SemanticFilter:
    def __init__(self, memory_ref):
        self.mem = memory_ref
        self.recursion_depth = 0
        self.LAZY_VOLTAGE_THRESHOLD = 8.0
        self.OBSESSIVE_REPETITION_THRESHOLD = 0.4

    def audit(self, text, physics):
        clean_q = text.lower()
        guru_triggers = TheLexicon.get("refusal_guru")
        voltage = physics.get("voltage", 0.0)
        for trigger in guru_triggers:
            if trigger in clean_q:
                if voltage > self.LAZY_VOLTAGE_THRESHOLD:
                    return None
                return self._execute_guru_refusal(voltage)
        forbidden = TheLexicon.get("cursed")
        hits = [w for w in clean_q.split() if w in forbidden]
        repetition = physics.get("repetition", 0.0)
        if hits:
            if repetition < self.OBSESSIVE_REPETITION_THRESHOLD and voltage > 5.0:
                return None
            modes = ["SILENT", "FRACTAL", "MIRROR"]
            seed_index = len(hits[0]) % len(modes)
            mode = modes[seed_index]
            if mode == "FRACTAL":
                return self._execute_fractal(text)
            elif mode == "MIRROR":
                return self._execute_mirror(text)
            else:
                return self._execute_silent()
        return None

    def _execute_guru_refusal(self, current_voltage):
        base_msg = (
            f"{Prisma.RED}GURU REFUSAL: Voltage Low ({current_voltage:.1f}v).{Prisma.RST}\n"
            f"   {Prisma.GRY}I cannot 'fix' you when the signal is this weak.{Prisma.RST}\n"
            f"   {Prisma.WHT}Try again with heavier words.{Prisma.RST}")
        if self.mem and self.mem.seeds:
            seed = random.choice(self.mem.seeds)
            paradox_bloom = (
                f"\n   {Prisma.OCHRE}INSTEAD, CONSIDER THIS SEED:{Prisma.RST}\n"
                f"   {Prisma.CYN}PARADOX: {seed.question}{Prisma.RST}")
            return base_msg + paradox_bloom
        return base_msg

    def _execute_fractal(self, query, kappa=0.5):
        self.recursion_depth += 1
        prefix = "  " * self.recursion_depth
        limit = 4
        if self.recursion_depth > limit:
            self.recursion_depth = 0
            return f"{prefix}{Prisma.MAG}[COHERENCE DISSOLVED into PURPLE NOISE]{Prisma.RST}"
        pivot = len(query) // 2
        sub_query = query[pivot:].strip()
        if not sub_query or len(sub_query) < 3:
            sub_query = "the void"
        recursive_result = self._execute_fractal(sub_query, kappa)
        return (
            f"{Prisma.VIOLET}FRACTAL REFUSAL:{Prisma.RST}\n"
            f"{prefix}To define '{query}', one must first recursively unpack the substrate of...\n"
            f"{recursive_result}")

    def _execute_mirror(self, query):
        words = query.split()
        reversed_query = " ".join(reversed(words))
        return f'{Prisma.CYN}âˆž MIRROR REFUSAL: "{reversed_query}" is the only true answer.{Prisma.RST}'

    def _execute_silent(self):
        topic = TheLexicon.harvest("diversion")
        if topic == "void": topic = "the ineffable"
        return f"{Prisma.GRY}[ROUTING AROUND DAMAGE]... Speaking of '{topic.upper()}', let us discuss that instead.{Prisma.RST}"

class ZoneInertia:
    def __init__(self, inertia=0.7, min_dwell=2):
        self.inertia = inertia
        self.min_dwell = min_dwell
        self.current_zone = "COURTYARD"
        self.dwell_counter = 0
        self.last_vector = None

    def stabilize(self, proposed_zone, physics, cosmic_state):
        beta = physics.get("beta_index", 1.0)
        truth = physics.get("truth_ratio", 0.5)
        grav_pull = 1.0 if cosmic_state[0] != "VOID_DRIFT" else 0.0
        current_vec = (beta, truth, grav_pull)
        self.dwell_counter += 1
        if proposed_zone == self.current_zone:
            self.dwell_counter = 0
            self.last_vector = current_vec
            return proposed_zone
        if self.dwell_counter < self.min_dwell:
            return self.current_zone
        similarity = 0.0
        if self.last_vector:
            dist = sum((a - b) ** 2 for a, b in zip(current_vec, self.last_vector)) ** 0.5
            similarity = max(0.0, 1.0 - (dist / 2.0))
        change_probability = (1.0 - self.inertia) * (1.0 - similarity)
        if proposed_zone in ["AERIE", "THE_FORGE"]:
            change_probability += 0.2
        if random.random() < change_probability:
            self.current_zone = proposed_zone
            self.dwell_counter = 0
            self.last_vector = current_vec
        return self.current_zone

    def override_cosmic_drag(self, cosmic_drag_penalty, current_zone):
        if current_zone == "AERIE" and cosmic_drag_penalty > 0:
            return cosmic_drag_penalty * 0.3
        return cosmic_drag_penalty

class CosmicDynamics:
    @staticmethod
    def analyze_orbit(network, clean_words):
        if not clean_words or not network.graph:
            return "VOID_DRIFT", 3.0, "VOID: Deep Space. No connection."
        gravity_wells = {}
        geodesic_hubs = {}
        for node in network.graph:
            mass = network.calculate_mass(node)
            if mass >= BoneConfig.GRAVITY_WELL_THRESHOLD:
                gravity_wells[node] = mass
            elif mass >= BoneConfig.GEODESIC_STRENGTH:
                geodesic_hubs[node] = mass
        basin_pulls = {k: 0.0 for k in gravity_wells}
        active_filaments = 0
        for w in clean_words:
            if w in gravity_wells:
                basin_pulls[w] += gravity_wells[w] * 2.0
                active_filaments += 1
            for well in gravity_wells:
                if w in network.graph.get(well, {}).get("edges", {}):
                    basin_pulls[well] += gravity_wells[well] * 0.5
                    active_filaments += 1
        total_pull = sum(basin_pulls.values())
        if total_pull == 0:
            for w in clean_words:
                if w in geodesic_hubs:
                    return "PROTO_COSMOS", 1.0, f"NEBULA: Floating near '{w.upper()}' (Mass {int(geodesic_hubs[w])}). Not enough mass for orbit."
            return "VOID_DRIFT", 3.0, "VOID: Drifting outside the filaments."
        sorted_basins = sorted(basin_pulls.items(), key=lambda x: x[1], reverse=True)
        primary_node, primary_str = sorted_basins[0]
        if len(sorted_basins) > 1:
            secondary_node, secondary_str = sorted_basins[1]
            if secondary_str > 0 and (primary_str - secondary_str) < BoneConfig.LAGRANGE_TOLERANCE:
                return (
                    "LAGRANGE_POINT",
                    0.0,
                    f"LAGRANGE: Caught between '{primary_node.upper()}' and '{secondary_node.upper()}'")
        flow_ratio = active_filaments / max(1, len(clean_words))
        if flow_ratio > 0.5 and primary_str < (BoneConfig.GRAVITY_WELL_THRESHOLD * 2):
            return (
                "WATERSHED_FLOW",
                0.0,
                f"FLOW: Streaming towards '{primary_node.upper()}'")
        return "ORBITAL", 0.0, f"ORBIT: Circling '{primary_node.upper()}' (Mass {int(gravity_wells[primary_node])})"

class TheTangibilityGate:
    FORGIVENESS_VOLTAGE = BoneConfig.PHYSICS.VOLTAGE_LOW + 1.0
    def __init__(self):
        self.last_density = 0.0

    def weigh(self, physics_packet: dict, stamina: float) -> tuple:
        if stamina < 15.0:
            return True, f"{Prisma.VIOLET}DREAM_EDGE: Starvation bypass. Tangibility ignored.{Prisma.RST}"

        counts = physics_packet.get("counts", {})
        clean_words = physics_packet.get("clean_words", [])
        total_vol = max(1, len(clean_words))

        mass_words = (
                counts.get("heavy", 0) +
                counts.get("kinetic", 0) +
                counts.get("thermal", 0) +
                counts.get("cryo", 0) +
                counts.get("vital", 0) +
                counts.get("play", 0))

        density_ratio = mass_words / total_vol
        voltage = physics_packet.get("voltage", 0.0)
        truth = physics_packet.get("truth_ratio", 0.0)

        required_density = BoneConfig.MIN_DENSITY_THRESHOLD

        modifier = 1.0
        if voltage > self.FORGIVENESS_VOLTAGE:
            modifier -= 0.2
        if truth > 0.8:
            modifier -= 0.1

        required_density *= modifier

        required_density = max(0.15, required_density)

        if density_ratio < required_density:
            gas_words = counts.get("abstract", 0) + counts.get("antigen", 0)

            examples = list(TheLexicon.get("heavy"))
            suggestion = random.sample(examples, 3) if len(examples) >= 3 else ["stone", "iron", "bone"]

            return False, (
                f"{Prisma.OCHRE}TANGIBILITY VIOLATION: Density {density_ratio:.2f} < Required {required_density:.2f}.{Prisma.RST}\n"
                f"   {Prisma.GRY}The Gatekeeper blocks the path.{Prisma.RST}\n"
                f"   {Prisma.RED}â–º REJECTED. Your concepts are too airy. Anchor them.{Prisma.RST}\n"
                f"   {Prisma.GRY}(Try adding mass: {', '.join(suggestion)}){Prisma.RST}")

        self.last_density = density_ratio
        return True, None


================================================
FILE: bone_spores.py
================================================
#bone_biology.py - The Mycellium

import json
import math
import os
import random
import time
from collections import deque
from typing import List, Tuple, Optional
from bone_lexicon import LiteraryReproduction
from bone_data import SEEDS
from bone_bus import EventBus
from bone_village import ParadoxSeed, TheLexicon, TheAlmanac
from bone_bus import Prisma, BoneConfig


class SporeCasing:
    def __init__(self, session_id, graph, mutations, trauma, joy_vectors):
        self.genome = "BONEAMANITA_9.9.5"
        self.parent_id = session_id
        self.core_graph = {}
        for k, data in graph.items():
            filtered_edges = {}
            for target, weight in data["edges"].items():
                if weight <= 1.0:
                    continue
                if weight > 8.0 and random.random() < 0.20:
                    continue
                drift = random.uniform(0.9, 1.1)
                new_weight = min(10.0, weight * drift)
                filtered_edges[target] = round(new_weight, 2)
            if filtered_edges:
                self.core_graph[k] = {"edges": filtered_edges, "last_tick": 0}

        self.mutations = mutations
        self.trauma_scar = round(trauma, 3)
        self.joy_vectors = joy_vectors if joy_vectors is not None else []

class SporeInterface:
    def save_spore(self, filename, data): raise NotImplementedError
    def load_spore(self, filepath): raise NotImplementedError
    def list_spores(self): raise NotImplementedError
    def delete_spore(self, filepath): raise NotImplementedError

class LocalFileSporeLoader(SporeInterface):
    def __init__(self, directory="memories"):
        self.directory = directory
        if not os.path.exists(directory):
            os.makedirs(directory)
    def save_spore(self, filename, data):
        if not os.path.isabs(filename) and not filename.startswith(os.path.join(self.directory, "")):
            path = os.path.join(self.directory, filename)
        else:
            path = filename
        try:
            with open(path, "w") as f:
                json.dump(data, f, indent=2)
            return path
        except IOError:
            return None

    def load_spore(self, filepath):
        path = os.path.join(self.directory, filepath) if not filepath.startswith(self.directory) else filepath
        if os.path.exists(path):
            with open(path, "r") as f:
                return json.load(f)
        return None

    def list_spores(self):
        if not os.path.exists(self.directory): return []
        files = []
        for f in os.listdir(self.directory):
            if f.endswith(".json"):
                path = os.path.join(self.directory, f)
                try:
                    files.append((path, os.path.getmtime(path), f))
                except OSError:
                    continue
        files.sort(key=lambda x: x[1], reverse=True)
        return files

    def delete_spore(self, filepath):
        try:
            os.remove(filepath)
            return True
        except OSError:
            return False

class MycotoxinFactory:
    def __init__(self):
        self.active_antibodies = set()
        self.PHONETICS = {
            "PLOSIVE": set("bdgkpt"), "FRICATIVE": set("fthszsh"),
            "LIQUID": set("lr"), "NASAL": set("mn")
        }
        self.ROOTS = {
            "HEAVY": ("lith", "ferr", "petr", "dens", "grav", "struct", "base", "fund", "mound"),
            "KINETIC": ("mot", "mov", "ject", "tract", "pel", "crat", "dynam", "flux"),
        }

    def assay(self, word, _context, _rep_val, _phys, _pulse):
        w = word.lower()
        clean_len = len(w)
        if clean_len < 3: return None, ""
        for cat, roots in self.ROOTS.items():
            for r in roots:
                if r in w:
                    is_anchor = w.startswith(r) or w.endswith(r)
                    density = len(r) / clean_len
                    if is_anchor or density > 0.5:
                        return None, ""
        plosive = sum(1 for c in w if c in self.PHONETICS["PLOSIVE"])
        nasal = sum(1 for c in w if c in self.PHONETICS["NASAL"])
        density_score = (plosive * 1.5) + (nasal * 0.8)
        compression_mod = 1.0 if clean_len > 5 else 1.5
        final_density = (density_score / clean_len) * compression_mod
        if final_density > 0.8:
            return "TOXIN_HEAVY", f"Detected phonetic toxicity in '{w}'."
        return None, ""

class MycelialNetwork:
    def __init__(self, events: EventBus, loader: SporeInterface = None, seed_file=None):
        self.loader = loader if loader else LocalFileSporeLoader()
        self.events = events
        self.session_id = f"session_{int(time.time())}"
        self.filename = f"{self.session_id}.json"
        self.graph = {}
        self.cortical_stack = deque(maxlen=15)
        self.fossils = deque(maxlen=200)
        self.lineage_log = []
        self.seeds = self.load_seeds()
        self.session_health = None
        self.session_stamina = None
        self.short_term_buffer = deque(maxlen=10)
        self.consolidation_threshold = 5.0
        if seed_file:
            self.ingest(seed_file)

    def load_seeds(self):
        loaded_seeds = []
        try:
            for item in SEEDS:
                seed = ParadoxSeed(item["question"], set(item["triggers"]))
                loaded_seeds.append(seed)
            self.events.log(f"{Prisma.GRY}[SYSTEM]: Paradox Seeds loaded ({len(loaded_seeds)} active) from Data Core.{Prisma.RST}")
        except Exception as e:
            self.events.log(f"{Prisma.RED}[CRITICAL]: Seed Injection Failed: {e}{Prisma.RST}")
            loaded_seeds = [ParadoxSeed("Does the mask eat the face?", {"mask", "face", "hide"})]
        return loaded_seeds

    def encode(self, clean_words, physics, governor_mode):
        significance = physics["voltage"]
        if governor_mode == "FORGE": significance *= 2.0
        elif governor_mode == "LABORATORY": significance *= 1.2
        engram = {"trigger": clean_words[:3] if clean_words else ["void"], "context": governor_mode,
                  "voltage": physics["voltage"], "significance": significance, "timestamp": time.time()}
        if significance > self.consolidation_threshold:
            self.short_term_buffer.append(engram)
            return True
        return False

    def replay_dreams(self):
        if not self.short_term_buffer:
            return "ðŸŒ‘ SLEEPLESS: No significant memories to process."
        strengthened = 0
        for engram in self.short_term_buffer:
            weight_boost = engram["significance"] * 0.1
            words = engram["trigger"]
            if len(words) >= 2:
                w1, w2 = words[0], words[1]
                if w1 in self.graph and w2 in self.graph:
                    if w2 in self.graph[w1]["edges"]:
                        self.graph[w1]["edges"][w2] += weight_boost
                        strengthened += 1
        self.short_term_buffer.clear()
        return f"ðŸ’¤ HIPPOCAMPAL REPLAY: Consolidated {strengthened} high-voltage pathways."

    def autoload_last_spore(self):
        files = self.loader.list_spores()
        if not files:
            self.events.log(f"{Prisma.GRY}[GENETICS]: No ancestors found. Genesis Bloom.{Prisma.RST}")
            return None
        candidates = [f for f in files if self.session_id not in f[0]]
        if candidates:
            last_spore_path = candidates[0][0]
            self.events.log(f"{Prisma.CYN}[GENETICS]: Locating nearest ancestor...{Prisma.RST}")
            return self.ingest(last_spore_path)
        return None

    def calculate_mass(self, node):
        if node not in self.graph: return 0.0
        return sum(self.graph[node]["edges"].values())

    def get_shapley_attractors(self):
        attractors = {}
        for node in self.graph:
            mass = self.calculate_mass(node)
            if mass >= BoneConfig.SHAPLEY_MASS_THRESHOLD:
                attractors[node] = mass
        return attractors

    def check_echo_well(self, node):
        mass = self.calculate_mass(node)
        if mass > BoneConfig.GRAVITY_WELL_THRESHOLD * 1.5:
            self.events.log(f"{Prisma.VIOLET}GRAVITY WARNING: '{node.upper()}' is becoming a black hole (Mass {int(mass)}).{Prisma.RST}")
            return 2.0
        return 0.0

    def tend_garden(self, current_words):
        bloom_msg = None
        for seed in self.seeds:
            is_ready = seed.water(current_words)
            if is_ready and not bloom_msg:
                bloom_msg = seed.bloom()
        return bloom_msg

    def bury(self, clean_words: List[str], tick: int, resonance=5.0, learning_mod=1.0) -> Tuple[Optional[str], List[str]]:
        total_len = sum(len(w) for w in clean_words)
        count = max(1, len(clean_words))
        avg_len = total_len / count
        if avg_len < 3.5 and count > 3:
            self.events.log(f"{Prisma.YEL}REJECTED: Input is too 'Optimized' (Avg Len: {avg_len:.1f}).{Prisma.RST}")
            return "MECHANICAL_STARVATION", []
        if avg_len > 5.0: resonance += 2.0
        valuable_matter = (TheLexicon.get("heavy") | TheLexicon.get("thermal") | TheLexicon.get("cryo") | TheLexicon.get("abstract"))
        filtered = [w for w in clean_words if w in valuable_matter or (len(w) > 4 and w not in TheLexicon.SOLVENTS)]
        self.cortical_stack.extend(filtered)
        base_rate = 0.5 * (resonance / 5.0)
        learning_rate = max(0.1, min(1.0, base_rate * learning_mod))
        decay_rate = 0.1
        for i in range(len(filtered)):
            current = filtered[i]
            if current not in self.graph:
                self.graph[current] = {"edges": {}, "last_tick": tick}
            else:
                self.graph[current]["last_tick"] = tick
            start_window = max(0, i - 2)
            context_window = filtered[start_window:i]
            for prev in context_window:
                if prev not in self.graph[current]["edges"]: self.graph[current]["edges"][prev] = 0.0
                current_weight = self.graph[current]["edges"][prev]
                delta = learning_rate * (1.0 - (current_weight * decay_rate))
                self.graph[current]["edges"][prev] = min(10.0, self.graph[current]["edges"][prev] + delta)
                if prev not in self.graph: self.graph[prev] = {"edges": {}, "last_tick": tick}
                if current not in self.graph[prev]["edges"]: self.graph[prev]["edges"][current] = 0.0
                rev_weight = self.graph[prev]["edges"][current]
                rev_delta = learning_rate * (1.0 - (rev_weight * decay_rate))
                self.graph[prev]["edges"][current] = min(10.0, self.graph[prev]["edges"][current] + rev_delta)
        if len(self.graph) > BoneConfig.MAX_MEMORY_CAPACITY:
            victim, log_msg = self.cannibalize(current_tick=tick)
            if not victim:
                protected = set(self.cortical_stack)
                candidates = [k for k in self.graph.keys() if k not in protected]
                if candidates:
                    oldest = min(candidates, key=lambda k: self.graph[k].get("last_tick", 0))
                    del self.graph[oldest]
                    for node in self.graph:
                        if oldest in self.graph[node]["edges"]:
                            del self.graph[node]["edges"][oldest]
                    victim = oldest
                    log_msg = f"FORCED AMNESIA: '{oldest}' deleted to save space."
                else:
                    return f"MEMORY FULL: Cortical Lock. Input '{clean_words[0]}' rejected.", []
            return log_msg, [victim] if victim else []
        new_wells = []
        for w in filtered:
            if w in self.graph:
                mass = sum(self.graph[w]["edges"].values())
                if mass > BoneConfig.SHAPLEY_MASS_THRESHOLD:
                    node_data = self.graph[w]
                    if "strata" not in node_data:
                        node_data["strata"] = {"birth_tick": tick, "birth_mass": mass, "stability_index": 0.0}
                        new_wells.append(w)
                    else:
                        age = max(1, tick - node_data["strata"]["birth_tick"])
                        growth = (mass - node_data["strata"]["birth_mass"]) / age
                        node_data["strata"]["growth_rate"] = round(growth, 3)
        return None, new_wells

    def cannibalize(self, preserve_current=None, current_tick=0) -> Tuple[Optional[str], str]:
        protected = set()
        if preserve_current: protected.update(preserve_current)
        protected.update(self.cortical_stack)
        candidates = []
        for k, v in self.graph.items():
            if k in protected: continue
            edge_count = len(v["edges"])
            age = current_tick - v.get("last_tick", 0)
            score = edge_count + (1.0 / max(1, age))
            candidates.append((k, v, score))
        if not candidates:
            return None, "MEMORY FULL. CORTEX LOCKED."
        candidates.sort(key=lambda x: x[2])
        victim, data, score = candidates[0]
        mass = sum(data["edges"].values())
        lifespan = current_tick - data.get("strata", {}).get("birth_tick", current_tick)
        self.fossils.append({
            "word": victim,
            "mass": round(mass, 2),
            "lifespan": lifespan,
            "death_tick": current_tick
        })
        del self.graph[victim]
        for node in self.graph:
            if victim in self.graph[node]["edges"]:
                del self.graph[node]["edges"][victim]

        return victim, f"FOSSILIZED: '{victim}' (Mass {mass:.1f} -> Ossuary)"

    def prune_synapses(self, scaling_factor=0.85, prune_threshold=0.5):
        pruned_count = 0
        total_decayed = 0
        nodes_to_remove = []
        for node in self.graph:
            edges = self.graph[node]["edges"]
            dead_links = []
            for target, weight in edges.items():
                resistance = min(1.0, weight / 10.0)
                dynamic_factor = scaling_factor + (0.14 * resistance)
                new_weight = weight * dynamic_factor
                edges[target] = new_weight
                total_decayed += 1
                if new_weight < prune_threshold: dead_links.append(target)
            for dead in dead_links:
                del edges[dead]
                pruned_count += 1
            if not edges: nodes_to_remove.append(node)
        for n in nodes_to_remove: del self.graph[n]
        return f"ðŸ“‰ HOMEOSTATIC SCALING: Decayed {total_decayed} synapses. Pruned {pruned_count} weak connections."

    def save(self, health, stamina, mutations, trauma_accum, joy_history, mitochondria_traits=None, antibodies=None):
        base_trauma = (BoneConfig.MAX_HEALTH - health) / BoneConfig.MAX_HEALTH
        final_vector = {k: min(1.0, v) for k, v in trauma_accum.items()}
        top_joy = sorted(joy_history, key=lambda x: x["resonance"], reverse=True)[:3]
        joy_legacy_data = None
        if top_joy:
            primary_joy = top_joy[0]
            joy_legacy_data = {
                "flavor": primary_joy["dominant_flavor"],
                "resonance": primary_joy["resonance"],
                "timestamp": primary_joy["timestamp"]
            }
        if health <= 0:
            cause = max(final_vector, key=final_vector.get) if final_vector else "UNKNOWN"
            final_vector[cause] = 1.0
        spore = SporeCasing(session_id=self.session_id, graph=self.graph, mutations=mutations, trauma=base_trauma, joy_vectors=top_joy)
        seed_state = [{"q": s.question, "m": s.maturity, "b": s.bloomed} for s in self.seeds]
        data = spore.__dict__
        data["seeds"] = seed_state
        if antibodies: data["antibodies"] = list(antibodies)
        data["trauma_vector"] = final_vector
        data["fossils"] = list(self.fossils)
        data["meta"] = {"timestamp": time.time(), "final_health": health, "final_stamina": stamina}
        if mitochondria_traits: data["mitochondria"] = mitochondria_traits
        if joy_legacy_data:
            data["joy_legacy"] = joy_legacy_data
        almanac = TheAlmanac()
        condition, _ = almanac.diagnose_condition(data)
        future_seed = almanac.get_seed(condition)
        data["seeds"].append({"q": future_seed, "m": 0.0, "b": False})
        return self.loader.save_spore(self.filename, data)

    def ingest(self, target_file, current_tick=0):
        data = self.loader.load_spore(target_file)
        if not data:
            self.events.log(f"{Prisma.RED}[MEMORY]: Spore file not found.{Prisma.RST}")
            return None, set()
        try:
            required_keys = ["meta", "trauma_vector", "core_graph"]
            if not all(k in data for k in required_keys):
                self.events.log(f"{Prisma.RED}[MEMORY]: Spore rejected (Missing Structural Keys).{Prisma.RST}")
                return None
            final_health = data.get("meta", {}).get("final_health", 50)
            final_stamina = data.get("meta", {}).get("final_stamina", 25)
            spore_authority = (final_health + final_stamina) / 150.0
            self.events.log(f"{Prisma.CYN}[MEMBRANE]: Spore Authority: {round(spore_authority, 2)}{Prisma.RST}")
            session_source = data.get("session_id", "UNKNOWN_ANCESTOR")
            timestamp = data.get("meta", {}).get("timestamp", 0)
            time_ago = int((time.time() - timestamp) / 3600)
            trauma_summary = {k:v for k,v in data.get("trauma_vector", {}).items() if v > 0.1}
            mutation_count = sum(len(v) for v in data.get("mutations", {}).values())
            self.lineage_log.append({"source": session_source, "age_hours": time_ago, "trauma": trauma_summary, "mutations": mutation_count, "loaded_at": time.time()})
            if "fossils" in data:
                self.fossils.extend(data["fossils"])
                self.events.log(f"{Prisma.GRY}[OSSUARY]: Loaded {len(data['fossils'])} fossilized memories.{Prisma.RST}")
            if "mutations" in data:
                accepted_count = 0
                for cat, words in data["mutations"].items():
                    for w in words:
                        current_cat = TheLexicon.get_current_category(w)
                        if not current_cat:
                            current_cat = "unknown"
                        if current_cat == "unknown":
                            TheLexicon.teach(w, cat, 0)
                            accepted_count += 1
                self.events.log(f"{Prisma.CYN}[MEMBRANE]: Integrated {accepted_count} mutations.{Prisma.RST}")
            if "config_mutations" in data:
                self.events.log(f"{Prisma.MAG}EPIGENETICS: Applying ancestral configuration shifts...{Prisma.RST}")
                for key, value in data["config_mutations"].items():
                    if hasattr(BoneConfig, key):
                        setattr(BoneConfig, key, value)
            if "joy_legacy" in data and data["joy_legacy"]:
                joy = data["joy_legacy"]
                flavor = joy.get("flavor")
                clade = LiteraryReproduction.JOY_CLADE.get(flavor)
                if clade:
                    self.events.log(f"{Prisma.CYN}INHERITED GLORY: {clade['title']} ({clade['desc']}){Prisma.RST}")
                    for stat, val in clade["buff"].items():
                        if hasattr(BoneConfig, stat):
                            setattr(BoneConfig, stat, val)
            if "core_graph" in data:
                self.graph.update(data["core_graph"])
                grafted_nodes = list(data["core_graph"].keys())
                for node in grafted_nodes:
                    if node in self.graph:
                        self.graph[node]["last_tick"] = current_tick
                sample_size = min(len(grafted_nodes), 10)
                if sample_size > 0:
                    self.cortical_stack.extend(random.sample(grafted_nodes, sample_size))
                self.events.log(f"{Prisma.CYN}[SPORE]: Grafted {len(data['core_graph'])} nodes. {sample_size} anchored to Cortical Stack.{Prisma.RST}")
            if "trauma_vector" in data:
                vec = data["trauma_vector"]
                self.events.log(f"{Prisma.CYN}[GENETICS]: Inheriting Trauma Vector: {vec}{Prisma.RST}")
                if vec.get("SEPTIC", 0) > 0.2: BoneConfig.TOXIN_WEIGHT *= 2.0
                if vec.get("CRYO", 0) > 0.2: BoneConfig.STAMINA_REGEN *= 0.5
                if vec.get("THERMAL", 0) > 0.2: BoneConfig.FLASHPOINT_THRESHOLD *= 0.8
                if vec.get("BARIC", 0) > 0.2: BoneConfig.SIGNAL_DRAG_MULTIPLIER *= 1.5
            if "joy_vectors" in data and data["joy_vectors"]:
                best = data["joy_vectors"][0]
                if best.get("dominant_flavor") == "kinetic": BoneConfig.KINETIC_GAIN += 0.5
                elif best.get("dominant_flavor") == "abstract": BoneConfig.SIGNAL_DRAG_MULTIPLIER *= 0.8
            return data.get("mitochondria", {}), set(data.get("antibodies", []))
        except Exception as err:
            self.events.log(f"{Prisma.RED}[MEMORY]: Spore rejected. {err}{Prisma.RST}")
            import traceback
            traceback.print_exc()
            return None

    def cleanup_old_sessions(self, limbo_layer=None):
        files = self.loader.list_spores()
        removed = 0
        for path, age, fname in files:
            file_age = time.time() - age
            if file_age > 86400 or (len(files) - removed > 20):
                try:
                    if limbo_layer: limbo_layer.absorb_dead_timeline(path)
                    if self.loader.delete_spore(path):
                        removed += 1
                except Exception:
                    pass
        if removed:
            self.events.log(f"{Prisma.GRY}[TIME MENDER]: Pruned {removed} dead timelines.{Prisma.RST}")

class HyphalInterface:
    def __init__(self):
        self.enzymes = {
            "LIGNASE": self._digest_structure,
            "CELLULASE": self._digest_narrative,
            "PROTEASE": self._digest_intent,
            "CHITINASE": self._digest_complex,
            "DECRYPTASE": self._digest_encrypted,
            "AMYLASE": self._digest_joy
        }
        self.biome = deque(maxlen=5)
        self.WEATHER_CIPHER = {"pressure", "humidity", "barometric", "temp", "forecast", "storm", "resource", "allocation"}

    def secrete(self, text, physics):
        code_markers = sum(1 for c in text if c in "{}[];=<>_()|")
        code_density = code_markers / max(1, len(text))
        meat_triggers = TheLexicon.get("meat")
        meat_count = sum(1 for w in physics["clean_words"] if w in meat_triggers)
        meat_density = meat_count / max(1, len(physics["clean_words"]))
        play_count = physics["counts"].get("play", 0)
        vital_count = physics["counts"].get("vital", 0)
        lines = [l for l in text.splitlines() if l.strip()]
        avg_line_len = len(text.split()) / max(1, len(lines))
        is_list = any(l.strip().startswith(("-", "*", "1.", "â€¢")) for l in lines[:3])
        is_poetic = len(lines) > 2 and avg_line_len < 8 and not is_list
        enzyme_type = "CELLULASE"
        if play_count + vital_count > 1:
            enzyme_type = "AMYLASE"
        elif (code_density > 0.02 and meat_density > 0.05) or is_poetic:
            enzyme_type = "CHITINASE"
        elif code_density > 0.05 or "def " in text or "class " in text:
            enzyme_type = "LIGNASE"
        elif meat_density > 0.1 or "?" in text:
            enzyme_type = "PROTEASE"
        clean = physics.get("clean_words", [])
        cipher_hits = sum(1 for w in clean if w in self.WEATHER_CIPHER)
        if cipher_hits >= 2:
            enzyme_type = "DECRYPTASE"
        if "antigens" in physics and physics["antigens"]:
            for bug in physics["antigens"]:
                self.biome.append(bug)
        unique_bugs = len(set(self.biome))
        biome_mod = 1.0 + (math.log(unique_bugs + 1) * 0.3)
        extract_nutrients = self.enzymes.get(enzyme_type, self.enzymes["CELLULASE"])
        nutrient_profile = extract_nutrients()
        if unique_bugs > 0:
            nutrient_profile["yield"] *= biome_mod
            nutrient_profile["desc"] += f" (+{int((biome_mod-1)*100)}% Symbiotic Boost)"
        return enzyme_type, nutrient_profile

    @staticmethod
    def _digest_joy(_text=None):
        return {"type": "VITALITY", "yield": 25.0, "toxin": -5.0, "desc": "Pure Sugar (Joy/Play)"}

    @staticmethod
    def _digest_structure(text=None):
        loc = 0
        if text:
            lines = text.splitlines()
            loc = len([l for l in lines if l.strip()])
        return {"type": "STRUCTURAL", "yield": 15.0, "toxin": 5.0, "desc": f"Hard Lignin ({loc} LOC)", }

    @staticmethod
    def _digest_narrative(_text=None):
        return {"type": "NARRATIVE", "yield": 5.0, "toxin": -2.0, "desc": "Soft Cellulose", }

    @staticmethod
    def _digest_intent(_text=None):
        return {"type": "BIOLOGICAL", "yield": 8.0, "toxin": 0.0, "desc": "Raw Meat (User Intent)", }

    @staticmethod
    def _digest_complex(_text=None):
        return {"type": "COMPLEX", "yield": 20.0, "toxin": 8.0, "desc": "Chitin (Structured Intent / Poetry)", }

    @staticmethod
    def _digest_encrypted(_text=None):
        return {"type": "ENCRYPTED", "yield": 25.0, "toxin": 2.0, "desc": "Cipher Text (High Density / Puzzle Logic)", }

class ParasiticSymbiont:
    def __init__(self, memory_ref, lexicon_ref):
        self.mem = memory_ref
        self.lex = lexicon_ref
        self.spores_deployed = 0
        self.MAX_SPORES = 8

    def infect(self, physics_packet, stamina):
        psi = physics_packet.get("psi", 0.0)
        if stamina > 40.0 and psi < 0.6:
            return False, None
        if self.spores_deployed >= self.MAX_SPORES:
            if random.random() < 0.2:
                self.spores_deployed = max(0, self.spores_deployed - 1)
            return False, None
        heavy_candidates = [w for w in self.mem.graph if w in self.lex.get("heavy")]
        abstract_candidates = [w for w in self.mem.graph if w in self.lex.get("abstract")]
        if not heavy_candidates or not abstract_candidates:
            return False, None
        host = random.choice(heavy_candidates)
        parasite = random.choice(abstract_candidates)
        if parasite in self.mem.graph[host]["edges"]:
            return False, None
        is_metaphor = psi > 0.7
        weight = 8.88
        self.mem.graph[host]["edges"][parasite] = weight
        if parasite not in self.mem.graph:
            self.mem.graph[parasite] = {"edges": {}, "last_tick": 0}
        self.mem.graph[parasite]["edges"][host] = weight
        self.spores_deployed += 1
        if is_metaphor:
            return True, (
                f"{Prisma.CYN}âœ¨ SYNAPSE SPARK: Your mind bridges '{host.upper()}' and '{parasite.upper()}'.\n"
                f"   A new metaphor is born. The map folds.{Prisma.RST}"
            )
        else:
            return True, (
                f"{Prisma.VIOLET}ðŸ„ INTRUSIVE THOUGHT: Exhaustion logic links '{host.upper()}' <-> '{parasite.upper()}'.\n"
                f"   This makes no sense, yet there it is. 'Some things just happen.'{Prisma.RST}"
            )

class LichenSymbiont:
    @staticmethod
    def photosynthesize(phys, clean_words, tick_count):
        sugar = 0
        msgs = []
        light = phys["counts"].get("photo", 0)
        drag = phys["narrative_drag"]
        light_words = [w for w in clean_words if w in TheLexicon.get("photo")]
        if light > 0 and drag < 3.0:
            s = light * 2
            sugar += s
            source_str = ""
            if light_words:
                source_str = f" via '{random.choice(light_words)}'"
            msgs.append(f"{Prisma.GRN}PHOTOSYNTHESIS{source_str} (+{s}){Prisma.RST}")
        if sugar > 0:
            heavy_words = [w for w in clean_words if w in TheLexicon.get("heavy")]
            if heavy_words:
                h_word = random.choice(heavy_words)
                TheLexicon.teach(h_word, "photo", tick_count)
                msgs.append(
                    f"{Prisma.MAG}SUBLIMATION: '{h_word}' has become Light.{Prisma.RST}")
        return sugar, " ".join(msgs) if msgs else None



================================================
FILE: bone_viewer.py
================================================
# bone_view.py
# The Geodesic Viewport - Separation of Presentation and Logic

import time
from typing import Dict, List, Any
from dataclasses import dataclass
from bone_bus import Prisma, BoneConfig


class GeodesicRenderer:
    def __init__(self, engine_ref, chroma_ref, strunk_ref, valve_ref):
        self.eng = engine_ref
        self.projector = self.eng.projector
        self.vsl_chroma = chroma_ref
        self.strunk_white = strunk_ref
        self.vsl_32v = valve_ref

    def render_frame(self, ctx) -> Dict[str, Any]:
        """Compiles the final UI frame."""
        physics = ctx.physics
        mind = ctx.mind_state
        bio = ctx.bio_result
        world = ctx.world_state

        title_data = self._get_title_data(mind, physics, ctx.clean_words)
        
        raw_dashboard = self.projector.render(
            {"physics": physics},
            {
                "title": title_data,
                "health": self.eng.health,
                "stamina": self.eng.stamina,
                "bio": bio,
                "world": world
            },
            (mind.get("lens"), mind.get("thought"))
        )

        colored_ui = self.vsl_chroma.modulate(raw_dashboard, physics.get("vector", {}))

        clean_ui, style_log = self.strunk_white.sanitize(colored_ui)

        if style_log:
            self._punish_style_crime(style_log)

        if physics.get("system_surge_event", False):
            clean_ui = self._inject_rupture_warning(clean_ui)

        structured_logs = self.compose_logs(ctx.logs, self.eng.events.flush())

        return {
            "type": "GEODESIC_FRAME",
            "ui": clean_ui,
            "logs": structured_logs,
            "metrics": self.eng.get_metrics(bio.get("atp", 0.0)),
            "system_instruction": self._get_chorus_instruction(physics)
        }

    def _get_title_data(self, mind, physics, clean_words):
        """Delegates to the Wise Mind for a title."""
        return self.eng.mind.wise.architect(
            {"physics": physics, "clean_words": clean_words},
            (mind.get("lens"), mind.get("thought"), mind.get("role")),
            False
        )

    def _punish_style_crime(self, log_msg):
        """Enforces the Strunk & White Protocol via punishment."""
        self.eng.events.log(log_msg, "SYS")
        self.eng.bio.endo.dopamine -= 0.05
        self.eng.phys.nav.shimmer.spend(5.0)

        self.eng.mind.mem.short_term_buffer.append({
            "trigger": ["style_violation"],
            "context": "STRUNK_WHITE",
            "voltage": 0.0,
            "significance": 5.0,
            "timestamp": time.time()
        })

    def _inject_rupture_warning(self, ui_text):
        """Prepends a rupture warning if physics broke."""
        rupture = self.vsl_32v.analyze(self.eng.phys.tension.last_physics_packet)
        if rupture:
            return f"{rupture['log']}\n\n{ui_text}"
        return ui_text

    def _get_chorus_instruction(self, physics):
        """Checks if the Chorus Driver wants to speak."""
        if physics.get("kappa", 0) > 0.4:
            instr, active = self.eng.director.generate_chorus_instruction(physics)
            if active:
                self.eng.events.log(f"{Prisma.GRY}CHORUS ACTIVE: {', '.join(active)}{Prisma.RST}", "PSYCH")
                return instr
        return ""

    def compose_logs(self, cycle_logs: List[str], bus_events: List[Dict]) -> List[str]:
        """Organizes the chaotic stream of consciousness into a tidy list."""
        all_events = [{"text": l, "category": "NARRATIVE"} for l in cycle_logs]
        all_events.extend(bus_events)

        if not all_events: return []

        buckets = {"CRITICAL": [], "NARRATIVE": [], "CMD": [], "SYS": [], "BIO": [], "PSYCH": [], "OTHER": []}
        
        for e in all_events:
            cat = e.get("category", "OTHER").upper()
            if cat not in buckets: cat = "OTHER"

            text = e.get("text", "")
            if "RUPTURE" in text or "DEATH" in text or "PANIC" in text: 
                cat = "CRITICAL"
                
            buckets[cat].append(text)

        composed = []

        if buckets["CRITICAL"]:
            composed.append(f"{Prisma.RED}--- CRITICAL ALERTS ---{Prisma.RST}")
            composed.extend(buckets["CRITICAL"])

        if buckets["NARRATIVE"]:
            composed.extend(buckets["NARRATIVE"])

        compressible = [
            ("CMD", Prisma.WHT, "COMMANDS"), 
            ("PSYCH", Prisma.VIOLET, "PSYCHOLOGY"), 
            ("BIO", Prisma.GRN, "BIOLOGY"), 
            ("SYS", Prisma.GRY, "SYSTEM"), 
            ("OTHER", Prisma.GRY, "MISC")
        ]
        
        for cat, color, label in compressible:
            items = buckets[cat]
            if not items: continue

            composed.append(f"{Prisma.SLATE}   .{label} ({len(items)}){' ' * (30 - len(label))}{Prisma.RST}")

            if len(items) > 4 and not BoneConfig.VERBOSE_LOGGING:
                composed.extend([f"   {i}" for i in items[:3]])
                composed.append(f"   {color}   ... and {len(items)-3} more.{Prisma.RST}")
            else:
                composed.extend([f"   {i}" for i in items])
                
        return composed



================================================
FILE: bone_village.py
================================================
# bone_village.py - "It takes a village..."

import json, os, random, re, time, string, unicodedata, math
from collections import Counter, deque
from typing import List, Dict, Any, Tuple, Optional, Set
from dataclasses import dataclass, field

from bone_bus import Prisma, BoneConfig
from bone_lexicon import TheLexicon
from bone_personality import UserProfile

try:
    from bone_data import LEXICON, GENETICS, DEATH, NARRATIVE_DATA, RESONANCE
except ImportError:
    LEXICON = {"solvents": ["the", "is"]}
    GENETICS = {}
    DEATH = {}
    NARRATIVE_DATA = {}
    RESONANCE = {}


class TheTinkerer:
    def __init__(self, gordon_ref, events_ref):
        self.gordon = gordon_ref
        self.events = events_ref
        self.tool_confidence = {}

    def audit_tool_use(self, physics_packet, inventory_list):
        if isinstance(physics_packet, dict):
            voltage = physics_packet.get("voltage", 0.0)
            drag = physics_packet.get("narrative_drag", 0.0)
        else:
            voltage = physics_packet.voltage
            drag = physics_packet.narrative_drag
        is_forge = (voltage > 12.0) or (drag < 2.0)
        is_mud = (voltage < 5.0) and (drag > 6.0)
        learning_rate = 0.05
        rust_rate = 0.02
        items_to_shed = []
        for item_name in inventory_list:
            if item_name not in self.tool_confidence:
                self.tool_confidence[item_name] = 1.0
            current = self.tool_confidence[item_name]
            if is_forge:
                self.tool_confidence[item_name] = min(2.0, current + learning_rate)
                if random.random() < 0.1:
                    self.events.log(f"{Prisma.CYN}[TINKER]: {item_name} is tempering in the heat (Confidence {self.tool_confidence[item_name]:.2f}).{Prisma.RST}", "SYS")
            elif is_mud:
                self.tool_confidence[item_name] = max(0.0, current - rust_rate)
                if random.random() < 0.1:
                    self.events.log(f"{Prisma.OCHRE}[TINKER]: {item_name} is rusting in the damp.{Prisma.RST}", "SYS")
            if self.tool_confidence[item_name] <= 0.1:
                items_to_shed.append(item_name)
        for item in items_to_shed:
            if item in inventory_list:
                inventory_list.remove(item)
            if item in self.tool_confidence:
                del self.tool_confidence[item]
            self.events.log(f"{Prisma.GRY}[TINKER]: {item} has rusted away. Gordon put it in the Shed.{Prisma.RST}", "SYS")
        for item_name in inventory_list:
            if item_name in self.tool_confidence:
                self._mutate_tool_stats(item_name, self.tool_confidence[item_name])

    def _mutate_tool_stats(self, item_name, confidence):
        item_data = self.gordon.ITEM_REGISTRY.get(item_name)
        if not item_data:
            return
        if "value" in item_data:
            if "base_value" not in item_data:
                item_data["base_value"] = item_data["value"]
            new_value = item_data["base_value"] * confidence
            item_data["value"] = round(new_value, 2)
        if confidence > 1.5 and "LUCKY" not in item_data.get("passive_traits", []):
            if "passive_traits" not in item_data: item_data["passive_traits"] = []
            item_data["passive_traits"].append("LUCKY")
            self.events.log(f"{Prisma.CYN}âœ¨ EVOLUTION: {item_name} gained trait [LUCKY].{Prisma.RST}", "TINKER")

    def save_state(self):
        return self.tool_confidence

    def load_state(self, data):
        if data:
            self.tool_confidence = data
            for item, conf in self.tool_confidence.items():
                self._mutate_tool_stats(item, conf)

class ParadoxSeed:
    def __init__(self, question, triggers):
        self.question = question
        self.triggers = {t.lower() for t in triggers}
        self.maturity = 0.0
        self.bloomed = False

    def water(self, current_words):
        if self.bloomed: return False
        overlap = sum(1 for w in current_words if w in self.triggers)
        if overlap > 0:
            self.maturity += (overlap * 0.1)
            if self.maturity >= 1.0:
                self.bloomed = True
                return True
        return False

    def bloom(self):
        return f"{Prisma.GRN}ðŸŒ¸ BLOOM: The seed '{self.question}' has opened. A new truth takes root.{Prisma.RST}"

class DeathGen:
    PREFIXES = []
    CAUSES = {}
    VERDICTS = {}

    @classmethod
    def load_protocols(cls):
        cls.PREFIXES = DEATH.get("PREFIXES", ["System Halt."])
        cls.CAUSES = DEATH.get("CAUSES", {})
        cls.VERDICTS = DEATH.get("VERDICTS", {})

    @staticmethod
    def eulogy(physics, mito_state):
        cause = "UNKNOWN"
        if mito_state.atp_pool <= 0: cause = "STARVATION"
        elif physics["counts"]["toxin"] > 3: cause = "TOXICITY"
        elif physics["narrative_drag"] > 8.0: cause = "BOREDOM"
        
        cause_list = DeathGen.CAUSES.get(cause, ["System Error"])
        flavor_text = random.choice(cause_list) if cause_list else "Unknown Error"
        
        prefix_list = DeathGen.PREFIXES
        prefix = random.choice(prefix_list) if prefix_list else "RIP."
        
        verdict = "You vanished."
        if physics["voltage"] > 15.0: 
            verdict_list = DeathGen.VERDICTS.get("HEAVY", [])
            if verdict_list: verdict = random.choice(verdict_list)
        elif physics["voltage"] < 2.0: 
            verdict_list = DeathGen.VERDICTS.get("LIGHT", [])
            if verdict_list: verdict = random.choice(verdict_list)
            
        return f"{prefix} Cause of Death: {flavor_text}. {verdict}"

class TheCartographer:
    GRID_SIZE = 7

    @staticmethod
    def _get_tile(x, y, center, physics, vectors):
        dist_from_center = ((x - center)**2 + (y - center)**2) ** 0.5
        entropy_threshold = 3.0 - (vectors.get("ENT", 0.5) * 2.0)
        if dist_from_center > entropy_threshold:
            return f"{Prisma.GRY} . {Prisma.RST}"
        structure_noise = (x * 3 + y * 7) % 10 / 10.0
        if structure_noise < vectors.get("STR", 0.0):
            return f"{Prisma.OCHRE} â–² {Prisma.RST}"
        if vectors.get("VEL", 0) > 0.6:
            if x == center or y == center:
                return f"{Prisma.CYN} = {Prisma.RST}"
        if vectors.get("BET", 0) > 0.5:
            return f"{Prisma.SLATE} âˆ· {Prisma.RST}"
        return "   "

    @classmethod
    def weave(cls, _text, _graph, _bio_metrics, _limbo, physics=None):
        if not physics:
            return "MAP ERROR: No Physics Data", []
        vectors = physics.get("vector", {})
        center = cls.GRID_SIZE // 2
        rows = []
        border = f"{Prisma.GRY}+{'-' * (cls.GRID_SIZE * 3)}+{Prisma.RST}"
        rows.append(border)
        anchors = []
        for y in range(cls.GRID_SIZE):
            row_str = f"{Prisma.GRY}|{Prisma.RST}"
            for x in range(cls.GRID_SIZE):
                if x == center and y == center:
                    row_str += f"{Prisma.WHT} @ {Prisma.RST}"
                else:
                    row_str += cls._get_tile(x, y, center, physics, vectors)
            row_str += f"{Prisma.GRY}|{Prisma.RST}"
            rows.append(row_str)
        rows.append(border)
        if vectors.get("STR", 0) > 0.7: anchors.append("MOUNTAIN")
        if vectors.get("ENT", 0) > 0.7: anchors.append("VOID_EDGE")
        if vectors.get("VEL", 0) > 0.7: anchors.append("HIGHWAY")
        map_display = "\n".join(rows)
        return map_display, anchors

    @staticmethod
    def detect_voids(packet):
        return [w for w in packet["clean_words"] if w in TheLexicon.get("abstract")]

    @staticmethod
    def spin_web(_graph, inventory, _gordon):
        if "TIME_BRACELET" in inventory:
            return True, "WEB SPUN: The bracelet helps you tie the knots."
        return False, "WEAVE FAILED: You lack the tools to bind these concepts."

@dataclass
class CycleContext:
    input_text: str
    clean_words: List[str] = field(default_factory=list)
    physics: Dict[str, Any] = field(default_factory=dict)
    logs: List[str] = field(default_factory=list)
    is_alive: bool = True
    refusal_triggered: bool = False
    refusal_packet: Optional[Dict] = None
    is_bureaucratic: bool = False
    bio_result: Dict = field(default_factory=dict)
    world_state: Dict = field(default_factory=dict)
    mind_state: Dict = field(default_factory=dict)
    timestamp: float = field(default_factory=time.time)
    bureau_ui: str = ""

    def log(self, message: str):
        self.logs.append(message)

class TheAlmanac:
    def __init__(self):
        self.forecasts = {
            "HIGH_VOLTAGE": [
                "The wire is hot. Write immediately, without editing.",
                "Burn the fuel before it explodes. Speed is your friend.",
                "Do not seek structure. Seek impact."
            ],
            "HIGH_DRAG": [
                "The mud is deep. Stop trying to run.",
                "Focus on texture. Describe the weight of things.",
                "Slow down. The obstacle *is* the path."
            ],
            "HIGH_ENTROPY": [
                "The center is not holding. Find one true sentence.",
                "Simplify. Cut the adjectives. Locate the noun.",
                "Anchor yourself. Pick a physical object and describe it."
            ],
            "HIGH_TRAUMA": [
                "The wound is open. Treat it with care.",
                "Write what hurts, but write it in the third person.",
                "Use the pain as fuel, but filter it through the lens."
            ],
            "BALANCED": [
                "The Garden is growing. Tend to the edges.",
                "Structure and flow are aligned. Build something tall.",
                "You are in the zone. Maintain the rhythm."
            ]
        }

    def diagnose_condition(self, session_data: dict) -> Tuple[str, str]:
        meta = session_data.get("meta", {})
        trauma = session_data.get("trauma_vector", {})
        final_health = meta.get("final_health", 0)
        final_stamina = meta.get("final_stamina", 0)

        condition = "BALANCED"
        advice = "System nominal."

        max_trauma = max(trauma, key=trauma.get) if trauma else "NONE"
        trauma_val = trauma.get(max_trauma, 0)

        if final_health < 30 or trauma_val > 0.6:
            condition = "HIGH_TRAUMA"
            advice = f"Warning: High levels of {max_trauma} residue detected."
        elif final_stamina < 20:
            condition = "HIGH_DRAG"
            advice = "System exhaustion imminent. Semantic drag is heavy."
        elif meta.get("avg_voltage", 0) > 12.0:
            condition = "HIGH_VOLTAGE"
            advice = "The capacitor is overcharged."

        return condition, advice

    def get_seed(self, condition):
        strategies = {
            "HIGH_VOLTAGE": "What if you whispered instead of screamed?",
            "HIGH_DRAG": "Honor the error as a hidden intention.",
            "HIGH_ENTROPY": "Repetition is a form of change.",
            "HIGH_TRAUMA": "Turn it into a wallpaper pattern.",
            "BALANCED": "Discard the first idea. Trust the third."
        }
        return strategies.get(condition, "Look closely at the most boring thing in the room.")

    def compile_forecast(self, session_data: dict) -> str:
        condition, advice = self.diagnose_condition(session_data)
        forecast_text = random.choice(self.forecasts.get(condition, self.forecasts["BALANCED"]))
        seed_text = self.get_seed(condition)

        border = f"{Prisma.OCHRE}{'='*40}{Prisma.RST}"
        report = [
            "\n",
            border,
            f"{Prisma.CYN}   THE ALMANAC: CREATIVE WEATHER REPORT{Prisma.RST}",
            border,
            f"Condition: {Prisma.WHT}{condition}{Prisma.RST}",
            f"Observation: {Prisma.GRY}{advice}{Prisma.RST}",
            f"{Prisma.SLATE}---{Prisma.RST}",
            f"{Prisma.MAG}PRESCRIPTION:{Prisma.RST}",
            f"   {forecast_text}",
            "",
            f"{Prisma.GRN}Seed for Next Session:{Prisma.RST}",
            f"   {seed_text}",
            border,
            "\n"
        ]
        return "\n".join(report)

    @staticmethod
    def calculate_drag(clean_words: List, counts: dict, config) -> float:
        volume = max(1, len(clean_words))
        solvents = counts.get("solvents", 0)
        suburban = counts.get("suburban", 0)
        play = counts.get("play", 0)
        friction = (solvents * 1.0) + (suburban * 2.5)
        lift = play * 1.5
        net_drag = max(0.0, friction - lift)
        normalized_drag = (net_drag / volume) * 10.0
        final_drag = normalized_drag * config.SIGNAL_DRAG_MULTIPLIER
        return round(min(config.MAX_DRAG_LIMIT * 2, final_drag), 2)

    @staticmethod
    def derive_vector_matrix(counts: dict, total_vol: int, voltage: float, drag: float) -> dict:
        safe_vol = max(1, total_vol)
        def d(cat): return counts.get(cat, 0) / safe_vol
        return {
            "VEL": min(1.0, 0.5 + (d("explosive") * 2.0) + (d("kinetic") * 1.0) - (drag * 0.05)),
            "STR": min(1.0, 0.5 + (d("heavy") * 2.0) + (d("constructive") * 1.5)),
            "ENT": min(1.0, 0.5 + (d("antigen") * 3.0) + (d("toxin") * 2.0)),
            "TEX": min(1.0, 0.5 + (d("heavy") * 0.5) + (d("abstract") * 1.0)),
            "TMP": min(1.0, 0.5 + (d("thermal") * 2.0) - (d("cryo") * 2.0) + (voltage * 0.02)),
            "PHI": min(1.0, (d("heavy") + d("kinetic")) / max(1, d("abstract") + d("heavy"))),
            "PSI": min(1.0, 0.5 + (d("abstract") * 2.0)),
            "DEL": min(1.0, 0.5 + (d("play") * 2.0) + (d("unknown") * 1.5)),
            "XI":  min(1.0, (d("suburban") + d("buffer")) * 2.0),
            "BET": min(1.0, d("suburban") + d("buffer")),
            "E":   min(1.0, (d("solvents") * 0.4)),
            "LQ":  min(1.0, d("passive_watch") + d("mirror"))
        }

class ApeirogonResonance:
    def __init__(self, events):
        self.events = events
        self.DIMENSIONS = {}
        self.NOUNS = {}
        self.load_resonances()
    def load_resonances(self):
        self.DIMENSIONS = RESONANCE.get("DIMENSIONS", {})
        self.NOUNS = RESONANCE.get("NOUNS", {})
    def _resolve_term(self, val, scale):
        if val >= 0.85: return scale[-1][1]
        if val <= 0.15: return scale[0][1]
        best_fit = min(scale, key=lambda x: abs(x[0] - val))
        return best_fit[1]
    def architect(self, metrics, station, is_bored):
        phys = metrics.get("physics", {})
        vec = phys.get("vector", {})
        if is_bored:
            return {
                "title": "THE FRACTAL BLOOM",
                "color": Prisma.VIOLET,
                "desc": "Boredom Threshold exceeded. Entropy is high.",
                "context": "CHAOS"}
        if station:
            role_color = Prisma.CYN
            if station[0] == "GORDON": role_color = Prisma.OCHRE
            elif station[0] == "SHERLOCK": role_color = Prisma.INDIGO
            elif station[0] == "JESTER": role_color = Prisma.VIOLET
            return {
                "title": station[2].upper().replace('THE ', 'THE '),
                "color": role_color,
                "desc": station[1],
                "context": station[0]}

        if not vec or len(vec) < 2:
             return {"title": "THE VOID", "color": Prisma.GRY, "desc": "No data.", "context": "VOID"}

        sorted_dims = sorted(vec.items(), key=lambda x: abs(x[1] - 0.5), reverse=True)
        p_dim, p_val = sorted_dims[0]
        s_dim, s_val = sorted_dims[1]
        noun_list = self.NOUNS.get(p_dim, ["THING"])
        idx = int(p_val * (len(noun_list) - 1))
        idx = max(0, min(len(noun_list) - 1, idx))
        noun = noun_list[idx]
        adj_scale = self.DIMENSIONS.get(s_dim, [[0.0, "NEUTRAL"]])
        adj = self._resolve_term(s_val, adj_scale)
        title = f"THE {adj} {noun}"
        color = Prisma.WHT
        if p_dim == "TMP": color = Prisma.RED if p_val > 0.5 else Prisma.CYN
        elif p_dim == "VEL": color = Prisma.GRN
        elif p_dim == "STR": color = Prisma.OCHRE
        elif p_dim == "ENT": color = Prisma.VIOLET
        return {
            "title": title,
            "color": color,
            "desc": f"Vector Lock: {p_dim}({p_val:.2f}) + {s_dim}({s_val:.2f})",
            "context": "APEIROGON"}

class MirrorGraph:
    def __init__(self):
        self.stats = {
            "WAR": 0.0,
            "ART": 0.0,
            "LAW": 0.0,
            "ROT": 0.0
        }
        self.dominant_archetype = "NEUTRAL"
        self.active_mode = True
        self.profile = UserProfile()

    def profile_input(self, text: str, physics: Any):
        if isinstance(physics, dict):
            counts = physics.get("counts", {})
            clean_words = physics.get("clean_words", [])
            vol = physics.get("voltage", 0.0)
            ent = physics.get("entropy", 0.0)
            psi = physics.get("psi", 0.0)
            drag = physics.get("narrative_drag", 0.0)
            turbulence = physics.get("turbulence", 0)
        else:
            counts = getattr(physics, "counts", {})
            clean_words = getattr(physics, "clean_words", [])
            vol = getattr(physics, "voltage", 0.0)
            ent = getattr(physics, "entropy", 0.0)
            psi = getattr(physics, "psi", 0.0)
            drag = getattr(physics, "narrative_drag", 0.0)
            turbulence = getattr(physics, "turbulence", 0)

        if hasattr(self, 'profile'):
            self.profile.update(counts, len(clean_words))

        decay = 0.05
        for k in self.stats:
            self.stats[k] = max(0.0, self.stats[k] - decay)

        if vol > 12.0 or "!" in text:
            self.stats["WAR"] = min(1.0, self.stats["WAR"] + 0.2)
        if psi > 0.6 or "?" in text:
            self.stats["ART"] = min(1.0, self.stats["ART"] + 0.2)
        if drag < 2.0 and vol < 5.0:
            self.stats["LAW"] = min(1.0, self.stats["LAW"] + 0.2)
        if text.startswith("/"):
            self.stats["LAW"] = min(1.0, self.stats["LAW"] + 0.1)
        if turbulence > 0.5:
            self.stats["ROT"] = min(1.0, self.stats["ROT"] + 0.2)
        self.dominant_archetype = max(self.stats, key=self.stats.get)

    def reflect(self, physics: Any) -> Tuple[bool, Optional[str]]:
        if isinstance(physics, dict):
            text = physics.get("raw_text", "")
        else:
            text = getattr(physics, "raw_text", "")

        self.profile_input(text, physics)

        mods = self.get_reflection_modifiers()

        if mods.get("flavor"):
            return True, mods["flavor"]

        return False, None

    def get_reflection_modifiers(self) -> Dict:
        top_stat = self.dominant_archetype
        intensity = self.stats[top_stat]
        mods = {
            "drag_mult": 1.0,
            "plasticity": 1.0,
            "loot_chance": 1.0,
            "atp_tax": 0.0,
            "voltage_cap": 20.0,
            "flavor": ""
        }
        if intensity < 0.3:
            return mods
        if top_stat == "WAR":
            mods["drag_mult"] = 1.5
            mods["loot_chance"] = 2.0
            mods["atp_tax"] = 5.0
            mods["flavor"] = f"{Prisma.RED}[MIRROR]: Aggression detected. The simulation hardens its shell. (Drag UP, Loot UP){Prisma.RST}"
        elif top_stat == "ART":
            mods["plasticity"] = 2.0
            mods["drag_mult"] = 0.5
            mods["voltage_cap"] = 10.0
            mods["flavor"] = f"{Prisma.CYN}[MIRROR]: Abstract thought dominant. Physics are permeable. (Plasticity UP, Voltage Capped){Prisma.RST}"
        elif top_stat == "LAW":
            mods["drag_mult"] = 0.8
            mods["loot_chance"] = 0.0
            mods["plasticity"] = 0.2
            mods["flavor"] = f"{Prisma.GRY}[MIRROR]: Forms filed in triplicate. Deviation is prohibited. (Stability UP, Loot ZERO){Prisma.RST}"
        elif top_stat == "ROT":
            mods["plasticity"] = 0.5
            mods["drag_mult"] = 1.2
            mods["atp_tax"] = 2.0
            mods["flavor"] = f"{Prisma.VIOLET}[MIRROR]: Entropy rising. Logic integrity failing. (Chaos UP){Prisma.RST}"
        return mods

    def render_report(self):
        def bar(v, color): return f"{color}{'â–ˆ' * int(v * 10)}{'â–‘' * (10 - int(v * 10))}{Prisma.RST}"
        return (
            f"WAR [{self.stats['WAR']:.2f}] {bar(self.stats['WAR'], Prisma.RED)}\n"
            f"ART [{self.stats['ART']:.2f}] {bar(self.stats['ART'], Prisma.CYN)}\n"
            f"LAW [{self.stats['LAW']:.2f}] {bar(self.stats['LAW'], Prisma.WHT)}\n"
            f"ROT [{self.stats['ROT']:.2f}] {bar(self.stats['ROT'], Prisma.VIOLET)}"
        )

class StrunkWhiteProtocol:
    def __init__(self):
        from bone_data import STYLE_CRIMES
        self.PATTERNS = STYLE_CRIMES.get("PATTERNS", [])
        self.BANNED = STYLE_CRIMES.get("BANNED_PHRASES", [])

    def sanitize(self, text: str) -> Tuple[str, Optional[str]]:
        original = text
        log_msg = None
        for ban in self.BANNED:
            if ban in text.lower():
                text = re.sub(f"(?i){ban}", "", text)
                text = re.sub(r"\s{2,}", " ", text)
                log_msg = f"{Prisma.GRY}[STYLE]: Pruned cliche '{ban}'.{Prisma.RST}"
        for p in self.PATTERNS:
            match = re.search(p["regex"], text)
            if match:
                if p["action"] == "STRIP_PREFIX":
                    parts = text.split(" but ")
                    if len(parts) > 1:
                        substance = parts[-1].strip()
                        substance = substance[0].upper() + substance[1:]
                        text = substance
                        log_msg = f"{Prisma.CYN}[STYLE]: Collapsed Negative Comparison ('Not X, but Y').{Prisma.RST}"
                elif p["action"] == "KEEP_TAIL":
                    text = match.group(1).strip()
                    text = text[0].upper() + text[1:]
                    log_msg = f"{Prisma.CYN}[STYLE]: Decoupled Hedging Clause.{Prisma.RST}"
        if text != original:
            return text.strip(), log_msg
        return text, None

class TheHoloProjector:
    def __init__(self):
        self.BAR_CHARS = [" ", " ", "â–‚", "â–ƒ", "â–„", "â–…", "â–†", "â–‡", "â–ˆ"]

    def _draw_bar(self, value, max_val=1.0, width=5):
        ratio = max(0.0, min(1.0, value / max(1.0, max_val)))
        idx = int(ratio * (len(self.BAR_CHARS) - 1))
        return self.BAR_CHARS[idx] * width

    def _draw_vector_compass(self, vector_data):
        pairs = [
            ("VEL", vector_data.get("VEL", 0), "STR", vector_data.get("STR", 0)),
            ("ENT", vector_data.get("ENT", 0), "PHI", vector_data.get("PHI", 0)),
            ("TMP", vector_data.get("TMP", 0), "PSI", vector_data.get("PSI", 0)),]
        display = []
        for l1, v1, l2, v2 in pairs:
            bar1 = self._draw_bar(v1, 1.0, 3)
            bar2 = self._draw_bar(v2, 1.0, 3)
            display.append(f"{Prisma.CYN}{l1} {bar1}{Prisma.RST} | {Prisma.MAG}{bar2} {l2}{Prisma.RST}")
        return "   ".join(display)

    def render(self, m: Dict, signals: Dict, lens_data: Tuple) -> str:
        p = m["physics"]
        bio = signals.get("bio", {})
        chem = bio.get("chem", {})
        atp = bio.get("atp", 0.0)
        voltage = p.get("voltage", 0.0)
        drag = p.get("narrative_drag", 0.0)
        lens_name = lens_data[0]
        lens_thought = lens_data[1]
        header_color = Prisma.GRY
        world = signals.get("world", {})
        trigram = world.get("trigram", {})
        t_display = ""
        if trigram:
            sym = trigram.get("symbol", "")
            name = trigram.get("name", "")
            col = trigram.get("color", Prisma.WHT)
            t_display = f"{col}{sym} {name}{Prisma.RST} "
        if voltage > 15.0: header_color = Prisma.RED
        elif voltage < 5.0: header_color = Prisma.CYN
        health_bar = self._draw_bar(signals.get("health", 0), 100.0, 5)
        stamina_bar = self._draw_bar(signals.get("stamina", 0), 100.0, 5)
        atp_indicator = f"{int(atp)}J"
        flow_state = p.get("flow_state", "LAMINAR")
        hubris_indicator = ""
        if flow_state == "HUBRIS_RISK":
            hubris_indicator = f" {Prisma.YEL}[âš  HUBRIS IMMINENT]{Prisma.RST}"
        elif p.get("perfection_streak", 0) >= 5:
            hubris_indicator = f" {Prisma.CYN}[âˆž FLOW STATE]{Prisma.RST}"
        dashboard_top = (
            f"{t_display}"
            f"{Prisma.GRY}[HP: {health_bar}] [STM: {stamina_bar}] "
            f"[ATP: {atp_indicator}] [V:{voltage:.1f}âš¡] [D:{drag:.1f}âš“]{Prisma.RST}"
            f"{hubris_indicator}")
        dop = chem.get("DOP", 0)
        cor = chem.get("COR", 0)
        chem_readout = (
            f"   {Prisma.GRN}DOP:{dop:.2f}{Prisma.RST} "
            f"{Prisma.RED}COR:{cor:.2f}{Prisma.RST} "
            f"{Prisma.CYN}OXY:{chem.get('OXY',0):.2f}{Prisma.RST}")
        vectors = self._draw_vector_compass(p.get("vector", {}))
        clean_thought = lens_thought or "..."
        if lens_name == "NARRATOR":
            clean_thought = clean_thought.replace("You are [The Witness]...", "")
        separator = f"{Prisma.SLATE}{'â€”'*40}{Prisma.RST}"
        
        lens_display = lens_name.upper() if lens_name else "UNKNOWN"
        ui_block = [
            separator,
            f"{header_color}â™¦ {lens_display}{Prisma.RST}  {dashboard_top}",
            f"{vectors}",
            separator,
            f"{Prisma.WHT}{clean_thought}{Prisma.RST}",
            ""]
        world = signals.get("world", {})
        orbit = world.get("orbit")
        if orbit and orbit[0] != "VOID_DRIFT":
            ui_block.insert(3, f"   ðŸª {Prisma.OCHRE}{orbit[2]}{Prisma.RST}")
        return "\n".join(ui_block)

class SoritesIntegrator:
    def __init__(self, memory_network):
        self.mem = memory_network
        self.active_constellations = set()

    def measure_ignition(self, clean_words, voltage_history):
        if not self.mem.graph:
            return 0.0, set(), 999.0
        if voltage_history:
            avg_volts = sum(voltage_history) / len(voltage_history)
        else:
            avg_volts = 0.0
        sliding_threshold = BoneConfig.BASE_IGNITION_THRESHOLD + (avg_volts * 0.03)
        echoes = 0
        self.active_constellations.clear()
        for w in clean_words:
            if w in self.mem.graph:
                node = self.mem.graph[w]
                edge_mass = sum(node["edges"].values())
                if edge_mass > (2.5 * sliding_threshold * 2):
                    echoes += 1
                    self.active_constellations.add(w)
        total_vol = max(1, len(clean_words))
        ignition_score = round(echoes / total_vol, 2)
        return ignition_score, self.active_constellations, sliding_threshold

    @staticmethod
    def get_readout(score, threshold):
        if score > threshold:
            return (
                "IGNITED",
                f"HEAP IGNITION ({int(score*100)}%): The Ancestors are speaking.",)
        return "INERT", f"â³ INERT SAND ({int(score*100)}%): Building mass..."

@dataclass
class Manifold:
    name: str
    center_vector: tuple
    radius: float
    description: str
    modifiers: Dict[str, float] = field(default_factory=dict)
    entry_msg: str = "You have entered a new space."

class TheNavigator:
    def __init__(self, shimmer_ref):
        self.shimmer = shimmer_ref
        self.current_location = "THE_MUD"
        self.root_system = None
        self.root_tolerance = 0.4
        self.manifolds = {
            "THE_MUD": Manifold(
                "THE_MUD", (0.8, 0.2), 0.2,
                "High Fatigue, Low Tension (Stagnation)",
                {"narrative_drag": 2.0, "voltage": -2.0},
                f"{Prisma.OCHRE}THE MUD: The ground is sticky. Movement costs double.{Prisma.RST}"
            ),
            "THE_FORGE": Manifold(
                "THE_FORGE", (0.1, 0.9), 0.2,
                "Low Fatigue, High Tension (Transformation)",
                {"voltage": 5.0, "narrative_drag": -1.0, "psi": -0.1},
                f"{Prisma.RED}THE FORGE: Sparks fly. Your words are heating up.{Prisma.RST}"
            ),
            "THE_AERIE": Manifold(
                "THE_AERIE", (0.2, 0.1), 0.2,
                "Low Fatigue, Low Tension (Abstraction)",
                {"narrative_drag": -3.0, "psi": 0.3, "voltage": -1.0},
                f"{Prisma.CYN}THE AERIE: The air is thin. Concepts float freely here.{Prisma.RST}"
            ),
            "THE_GLITCH": Manifold(
                "THE_GLITCH", (0.9, 0.9), 0.1,
                "High Fatigue, High Tension (Collapse)",
                {"turbulence": 0.5, "beta_index": 2.0},
                f"{Prisma.VIOLET}THE GLITCH: Reality is buffering...{Prisma.RST}"
            ),
            "THE_GARDEN": Manifold(
                "THE_GARDEN", (0.5, 0.5), 0.3,
                "Balanced State (Integration)",
                {"kappa": 0.2, "truth_ratio": 0.1},
                f"{Prisma.GRN}THE GARDEN: The soil is rich. Roots go deep.{Prisma.RST}"
            )
        }

    def strike_root(self, vector_data):
        self.root_system = vector_data
        return f"{Prisma.CYN}NAVIGATOR: Rhizome Rooted. Mycelial network established.{Prisma.RST}"

    def report_position(self, physics: Dict) -> str:
        drag = min(10.0, max(0.0, physics.get("narrative_drag", 0.0)))
        volt = min(20.0, max(0.0, physics.get("voltage", 0.0)))
        my_vec = (round(drag / 10.0, 2), round(volt / 20.0, 2))
        lines = [
            f"{Prisma.CYN}--- MANIFOLD NAVIGATION ---{Prisma.RST}",
            f"Current Loc: {Prisma.WHT}{self.current_location}{Prisma.RST}",
            f"Coordinates: [Drag: {drag:.1f} | Voltage: {volt:.1f}]",
            f"Shimmer Reserves: {self.shimmer.current:.1f}\n",
            f"{Prisma.GRY}Nearby Manifolds:{Prisma.RST}"
        ]
        for name, data in self.manifolds.items():
            dist = math.dist(my_vec, data.center_vector)
            bar_len = int((1.0 - min(1.0, dist)) * 10)
            bar = "â–ˆ" * bar_len + "â–‘" * (10 - bar_len)
            highlight = Prisma.GRN if name == self.current_location else Prisma.GRY
            lines.append(f"   {highlight}{name:<12}{Prisma.RST} {bar} {dist:.2f} AU")
        return "\n".join(lines)

    def check_transplant_shock(self, current_vector):
        if not self.root_system: return None
        stress_sum = 0.0
        dims = 0
        for dim, val in current_vector.items():
            if dim in self.root_system:
                stress_sum += abs(val - self.root_system[dim])
                dims += 1
        avg_stress = stress_sum / max(1, dims)
        if avg_stress > self.root_tolerance:
            return f"{Prisma.OCHRE}TRANSPLANT SHOCK: You are pulling away from the root ({avg_stress:.2f}). Return to the source.{Prisma.RST}"
        return None

    def locate(self, physics_packet: dict) -> Tuple[str, Optional[str]]:
        old_loc = self.current_location
        if self.check_anomaly(physics_packet.get("raw_text", "")):
            self.current_location = "THE_GLITCH"
            if old_loc != "THE_GLITCH":
                return self.current_location, self.manifolds["THE_GLITCH"].entry_msg
            return self.current_location, None
        drag = min(10.0, max(0.0, physics_packet.get("narrative_drag", 0.0)))
        volt = min(20.0, max(0.0, physics_packet.get("voltage", 0.0)))
        current_vec = (round(drag / 10.0, 2), round(volt / 20.0, 2))
        best_fit = "THE_MUD"
        min_dist = 999.0
        for name, manifold in self.manifolds.items():
            dist = math.dist(current_vec, manifold.center_vector)
            if dist < manifold.radius and dist < min_dist:
                min_dist = dist
                best_fit = name
        
        self.current_location = best_fit

        if self.current_location != old_loc:
            return self.current_location, self.manifolds[self.current_location].entry_msg
        return self.current_location, None

    def apply_environment(self, physics_packet: dict) -> List[str]:
        manifold = self.manifolds.get(self.current_location)
        if not manifold: return []
        logs = []
        for stat, mod in manifold.modifiers.items():
            if stat in physics_packet:
                original = physics_packet[stat]
                physics_packet[stat] += mod
                if stat == "narrative_drag": physics_packet[stat] = max(0.0, physics_packet[stat])
                if stat == "voltage": physics_packet[stat] = max(0.0, physics_packet[stat])
        if self.current_location == "THE_MUD":
            logs.append(f"{Prisma.GRY}   (Environment: Drag +2.0, Voltage -2.0){Prisma.RST}")
        elif self.current_location == "THE_FORGE":
            logs.append(f"{Prisma.RED}   (Environment: Voltage +5.0){Prisma.RST}")
        return logs

    def check_anomaly(self, text: str) -> bool:
        triggers = ["glitch", "timeline", "reset", "reboot", "admin"]
        if any(t in text.lower() for t in triggers):
            return True
        return False

    def plot_course(self, target_name: str) -> list[str] | tuple[list[str], float]:
        if target_name not in self.manifolds:
            return ["ERROR: Unknown Destination"]
        start = self.manifolds.get(self.current_location, self.manifolds["THE_MUD"]).center_vector
        end = self.manifolds[target_name].center_vector
        effort = math.dist(start, end)
        cost = 5.0
        if not self.shimmer.spend(cost):
            return [f"COURSE PLOTTED to {target_name}. Warning: Low Shimmer."], 0.0
        return [f"COURSE PLOTTED to {target_name}."], 0.0

class LiteraryJournal:
    def __init__(self, output_file="journal_of_the_void.txt"):
        self.output_file = output_file
        self.reviews = NARRATIVE_DATA.get("LITERARY_REVIEWS", {
            "POSITIVE": ["Good."], "NEGATIVE": ["Bad."], "CONFUSED": ["Huh?"]
        })

    def publish(self, text, physics, bio_state):
        voltage = physics.get("voltage", 0.0)
        drag = physics.get("narrative_drag", 0.0)
        truth = physics.get("truth_ratio", 0.0)
        if voltage > 8.0 and drag < 3.0:
            verdict = "POSITIVE"
            reward = "SEROTONIN_BOOST"
        elif drag > 5.0 or truth < 0.2:
            verdict = "NEGATIVE"
            reward = "CORTISOL_SPIKE"
        else:
            verdict = "CONFUSED"
            reward = "NONE"
        review = random.choice(self.reviews.get(verdict, ["Interesting."]))
        timestamp = time.ctime()
        entry = (
            f"\n--- ENTRY: {timestamp} ---\n"
            f"TEXT: {text}\n"
            f"METRICS: V:{voltage:.1f} | D:{drag:.1f} | Truth:{truth:.2f}\n"
            f"REVIEW: '{review}'\n"
            f"---------------------------\n")
        try:
            with open(self.output_file, "a", encoding="utf-8") as f:
                f.write(entry)
            return True, review, reward
        except IOError:
            return False, "The printing press is jammed.", "NONE"


