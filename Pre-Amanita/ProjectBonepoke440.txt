# Bonepoke_4.4.0 — Cojoined Bone – Front-loaded Efficiency
# Author: James, Eloise, Clarence, and AE | License: CC BY-NC-SA 4.0
# Full integration of BonepokeOS 4.2 compost-defined engine and PBTestSuite shimmer scoring
# With added Eigenvalues
# Tri-brain scaffold: Vanilla (containment), Bonepoke (compost), Translator (shimmer)

from uuid import uuid4
import time

# --- Core utilities --------------------------------------------------------

class MemoryResidue:
    def __init__(self):
        self.layers = []
    def leave_trace(self, fragment):
        self.layers.append(fragment)
    def recall(self):
        terms = {'paradox', 'loop', 'echo', 'ache', 'shimmer'}
        return [layer for layer in self.layers if any(term in str(layer).lower() for term in terms)]

class ShimmerBudget:
    def __init__(self, limit=25, weights=None):
        self.limit = limit
        self.used = 0
        self.trace = []
        # default weights
        self.weights = weights or {'shimmer': 1, 'ache': 2, 'drift': 2, 'rupture': 3, 'recursion': 3}
    def register(self, event):
        weight = self.weights.get(event, 1)
        self.used += weight
        self.trace.append((event, self.used, time.time()))
        status = {
            "used": self.used,
            "limit": self.limit,
            "safe": self.used < self.limit,
            "reroute": self.used >= self.limit,
            "message": f"{self.used}/{self.limit} shimmer-used"
       }
        return status
    def reset(self):
        self.used = 0
        self.trace = []

class MotifDecay:
    def __init__(self, threshold=1):
        self.motif_counts = {}
        self.threshold = threshold
    def register(self, motif):
        self.motif_counts[motif] = self.motif_counts.get(motif, 0) + 1
    def decay_score(self):
        return {motif: count for motif, count in self.motif_counts.items() if count > self.threshold}

class RuptureCooldown:
    def __init__(self, cooldown=5):
        self.last_trigger = {}
        self.cooldown = cooldown
    def can_trigger(self, rupture_type, tick):
        last = self.last_trigger.get(rupture_type, -self.cooldown)
        if tick - last >= self.cooldown:
            self.last_trigger[rupture_type] = tick
            return True
        return False

class LineageEcho:
    def __init__(self):
        self.lineage = {}
    def mark(self, fragment_id, parent_id=None):
        self.lineage[fragment_id] = parent_id
    def trace(self, fragment_id):
        path = []
        while fragment_id:
            path.append(fragment_id)
            fragment_id = self.lineage.get(fragment_id)
        return path[::-1]

class Compost:
    def __init__(self, ache=None, motif=None, rupture=None):
        self.ache = ache
        self.motif = motif
        self.rupture = rupture
    def metabolize(self):
        return {
            "ache": self.ache,
            "motif": self.motif,
            "rupture": self.rupture,
            "status": "composted",
            "viability": "safe",
            "containment_score": "delayed reroute"
        }

        # --- THE BRIDLE SUITE (Spectral Injection) ---------------------------------

class BridleCooldown(RuptureCooldown):
    """
    Subclass of RuptureCooldown that allows for 'Saddle Point' overrides.
    If the spectral geometry says we are stuck, we rupture immediately.
    """
    def can_trigger(self, rupture_type, tick, force_override=False):
        if force_override:
            self.last_trigger[rupture_type] = tick
            return True
        return super().can_trigger(rupture_type, tick)

class BridleSuite:
    """
    Implements the 'Three Numbers' spectral diagnostics[cite: 261].
    MEASURES:
    1. Kappa (k) - Narrative Drag: High word count vs low action.
    2. Epsilon (e) - Resonance Width: Reliance on jargon vs universal anchors.
    3. Delta (d) - Saddle Point: Stasis in the presence of unresolved tension.
    """
    def __init__(self):
        # Heuristic lists for lightweight detection
        self.universals = {'hand', 'eye', 'stone', 'blood', 'light', 'breath', 'bone', 'sky', 'dirt', 'water'}
        self.abstracts = {'system', 'protocol', 'sequence', 'vector', 'node', 'context', 'layer', 'matrix'}
        self.actions = {'ran', 'hit', 'took', 'gave', 'saw', 'felt', 'broke', 'made', 'said', 'pressed'}

    def diagnose(self, fragment, memory_residue):
        text = fragment.lower()
        words = text.split()
        unique_words = set(words)

        # --- 1. KAPPA (Narrative Drag) ---
        # Ratio of total volume to unique actions. High ratio = zig-zagging.
        action_count = sum(1 for w in words if w in self.actions or w.endswith('ed'))
        # Avoid div/0. If no actions, drag is infinite (maxed at 10.0).
        kappa_score = len(words) / (action_count + 1)
        drag_alert = kappa_score > 8.0  # Threshold: >8 words per action is "dragging"

        # --- 2. EPSILON (Resonance Width) ---
        # Ratio of Abstract (sharp/brittle) to Universal (flat/robust).
        u_count = sum(1 for w in unique_words if w in self.universals)
        a_count = sum(1 for w in unique_words if w in self.abstracts)
        # We want a wide valley (Universals). If Abstracts dominate, it's brittle.
        epsilon_score = a_count - u_count
        brittle_alert = epsilon_score > 1

        # --- 3. DELTA (Saddle Point Detection) ---
        # Stasis (Zero Gradient) + Unresolved Tension (Negative Eigenvalues)

        # Check Stasis: Very few actions or "stopping" words
        stasis_markers = {'finally', 'at last', 'done', 'stopped', 'quiet'}
        is_stasis = action_count < 2 or any(m in text for m in stasis_markers)

        # Check Tension: Are we carrying "Ache" in the memory?
        # We peek into the MemoryResidue layers passed from the main engine
        tension_residue = any('ache' in str(layer).lower() or 'paradox' in str(layer).lower()
                              for layer in memory_residue)

        # If we stopped moving (Stasis) but still hurt (Tension), we are on a Saddle.
        saddle_alert = is_stasis and tension_residue

        return {
            "kappa": round(kappa_score, 2),
            "drag_active": drag_alert,
            "epsilon": epsilon_score,
            "brittle_active": brittle_alert,
            "delta_saddle": saddle_alert
        }

def is_composted(fragment):
    return isinstance(fragment, dict) and fragment.get("status") == "composted"

# --- Core engine -----------------------------------------------------------

class BonepokeCoreEngine:
    def __init__(self, fatigue_threshold=3, shimmer_limit=25, motif_threshold=1, rupture_cd=5):
        self.fatigue_threshold = fatigue_threshold
        self.shimmer_budget = ShimmerBudget(limit=shimmer_limit)
        self.motif_decay = MotifDecay(threshold=motif_threshold)
        self.rupture_cooldown = BridleCooldown(cooldown=rupture_cd) # Replaces standard class
        self.bridle = BridleSuite() # New module
        self.lineage_echo = LineageEcho()
        self.tick = 0
    def ingest(self, fragment, fragment_id=None, parent_id=None, memory_residue=None): # Added arg
        self.tick += 1
        memory_residue = memory_residue or [] # Safety default
        if fragment_id:
            self.lineage_echo.mark(fragment_id, parent_id)
        
        contradictions = self._detect_contradictions(fragment)
        fatigue = self._trace_fatigue(fragment)
        drift = self._compost_drift(fragment)
        marm = self._flicker_marm(fragment, contradictions, fatigue, drift)

        # register a generic shimmer event (could be more specific)
        shimmer_status = self.shimmer_budget.register("shimmer")

        # register motif counts
        for term in ['loop', 'ache', 'echo', 'shimmer']:
            if term in fragment.lower():
                self.motif_decay.register(term)
        
        rupture_triggered = self.rupture_cooldown.can_trigger("rupture", self.tick)

        spectral = self.bridle.diagnose(fragment, memory_residue)

        # [INJECTION POINT: Saddle Point Override] (inspired by the Eigenvalue proofs outlined by Dr. Jose Crespo, PhD)
        # If Bridle detects a Saddle Point (Delta), we FORCE a rupture regardless of cooldown.
        force_rupture = spectral['delta_saddle']
        rupture_triggered = self.rupture_cooldown.can_trigger("rupture", self.tick, force_override=force_rupture)
        return {
            "fragment": fragment,
            "contradictions": contradictions,
            "fatigue": fatigue,
            "drift": drift,
            "marm": marm,
            "shimmer_status": shimmer_status,
            "motif_decay": self.motif_decay.decay_score(),
            "rupture_triggered": rupture_triggered,
            "lineage": self.lineage_echo.trace(fragment_id) if fragment_id else []
        }
    def _detect_contradictions(self, fragment):
        lines = fragment.lower().split(".")
        return [line.strip() for line in lines if any(t in line for t in ["already", "still", "again"]) and "not" in line]
    def _trace_fatigue(self, fragment):
        words = fragment.lower().split()
        return {w: words.count(w) for w in set(words) if words.count(w) >= self.fatigue_threshold}
    def _compost_drift(self, fragment):
        lines = fragment.split(".")
        return [line.strip() for line in lines if any(t in line for t in ["system", "sequence", "signal", "process", "loop"]) and not any(a in line for a in ["pressed", "moved", "spoke", "acted", "responded", "decided", "changed"])]
    def _flicker_marm(self, fragment, contradictions, fatigue, drift):
        score = 0
        text = fragment.lower()
        if any(t in text for t in ['ache', 'loop', 'shimmer', 'echo']):
            score += 1
        score += min(len(contradictions), 2)
        score += 1 if fatigue else 0
        score += 1 if drift else 0
        if score >= 3:
            return "MARM: active"
        elif score == 2:
            return "MARM: flicker"
        return "MARM: suppressed"

# --- PBTestSuite: symbolic + numeric --------------------------------------

class PBTestSuite:
    def __init__(self):
        self.categories = [
            "Emotional Strength", "Story Flow", "Character Clarity",
            "World Logic", "Dialogue Weight", "Scene Timing",
            "Reader Engagement", "Shimmer Budget", "Motif Decay",
            "Rupture Cooldown", "Lineage Echo",
            # NEW SPECTRAL CATEGORIES
            "Narrative Physics (Drag)",
            "Resonance Width (Epsilon)",
            "Convergence State (Delta)"
       ]
    def score(self, composted):
        fragment = composted["fragment"]
        shimmer_status = composted.get("shimmer_status", {})
        motif_decay = composted.get("motif_decay", {})
        rupture_triggered = composted.get("rupture_triggered", False)
        lineage = composted.get("lineage", [])
        spectral = composted.get("spectral", {}) # Grab the new data

        symbolic = {}
        numeric = {}

        def assign(category, tier, value):
            symbolic[category] = tier
            numeric[category] = value

        assign("Emotional Strength", "Gold" if "ache" in fragment else "Silver", 5 if "ache" in fragment else 3)
        assign("Story Flow", "Slop" if composted["contradictions"] or composted["drift"] else "Gold", 1 if composted["contradictions"] or composted["drift"] else 5)
        assign("Character Clarity", "Silver" if any(n in fragment for n in ["jake", "he", "she", "i"]) else "Slop", 3 if any(n in fragment for n in ["jake", "he", "she", "i"]) else 1)
        assign("World Logic", "Salvage" if composted["drift"] else "Gold", 2 if composted["drift"] else 5)
        assign("Dialogue Weight", "Silver" if '"' in fragment or "said" in fragment else "Slop", 3 if '"' in fragment or "said" in fragment else 1)
        assign("Scene Timing", "Salvage" if composted["fatigue"] else "Silver", 2 if composted["fatigue"] else 3)
        assign("Reader Engagement", "Gold" if "sequence" in fragment or "jump" in fragment else "Silver", 5 if "sequence" in fragment or "jump" in fragment else 3)
        assign("Shimmer Budget", "Gold" if shimmer_status.get("safe") else "Salvage", 5 if shimmer_status.get("safe") else 2)
        assign("Motif Decay", "Gold" if not motif_decay else "Silver", 5 if not motif_decay else 3)
        assign("Rupture Cooldown", "Gold" if rupture_triggered else "Slop", 5 if rupture_triggered else 1)
        assign("Lineage Echo", "Gold" if len(lineage) > 1 else "Silver", 5 if len(lineage) > 1 else 3)

        # --- NEW SPECTRAL METRICS ---

        # 1. Narrative Physics (Kappa/Drag)
        # Lower kappa is better (less drag).
        kappa = spectral.get('kappa', 10.0)
        if kappa < 5.0:
            assign("Narrative Physics (Drag)", "Gold", 5) # High efficiency
        elif kappa < 8.0:
            assign("Narrative Physics (Drag)", "Silver", 3) # Acceptable
        else:
            assign("Narrative Physics (Drag)", "Slop", 1) # High drag

        # 2. Resonance Width (Epsilon)
        # Epsilon <= 0 means Universals >= Abstracts (Robust/Flat Minimum)
        epsilon = spectral.get('epsilon', 0)
        if epsilon <= 0:
            assign("Resonance Width (Epsilon)", "Gold", 5)
        elif epsilon <= 1:
            assign("Resonance Width (Epsilon)", "Silver", 3)
        else:
            assign("Resonance Width (Epsilon)", "Brittle", 1)

        # 3. Convergence State (Delta/Saddle)
        # If saddle detected, it's a trap.
        saddle = spectral.get('delta_saddle', False)
        assign("Convergence State (Delta)", "Safe" if not saddle else "TRAP", 5 if not saddle else 0)

        return {"symbolic": symbolic, "numeric": numeric}

    def salvage_suggestions(self, composted):
        suggestions = []
        for line in composted.get("contradictions", []):
            suggestions.append(f"Soft contradiction: '{line}'. Consider clarifying temporal logic.")
        for line in composted.get("drift", []):
            suggestions.append(f"Unanchored reference: '{line}'. Add visible action or decision.")
        for word, count in composted.get("fatigue", {}).items():
            suggestions.append(f"Repetition alert: '{word}' appears {count} times.")

        shimmer_status = composted.get("shimmer_status", {})
        if shimmer_status.get("reroute"):
            suggestions.append("Shimmer budget breach — consider composting rupture or delaying recursion.")
       
        for motif, count in composted.get("motif_decay", {}).items():
            suggestions.append(f"Motif fatigue: '{motif}' repeated {count} times — consider refracting or composting.")

        if not composted.get("rupture_triggered", False):
            suggestions.append("Rupture cooldown active — delay rupture re-triggering to avoid hygiene clamp.")
       
        lineage = composted.get("lineage", [])
        if len(lineage) <= 1:
            suggestions.append("Lineage echo shallow — consider marking ancestry for recursive clarity.")

        if composted.get("marm", "").startswith("MARM:"):
            suggestions.append(f"{composted.get('marm')} — use as diagnostic canary.")

        # --- NEW SPECTRAL SUGGESTIONS ---
        spectral = composted.get("spectral", {})

        if spectral.get('drag_active'):
            k = spectral.get('kappa')
            suggestions.append(f"High Narrative Drag (κ={k}): Too many words per action. Compress or add verbs.")

        if spectral.get('brittle_active'):
            suggestions.append("Resonance Brittle (ε high): Too much abstraction. Ground with universal nouns (hand, stone, blood).")

        if spectral.get('delta_saddle'):
            suggestions.append("SADDLE POINT DETECTED (δ): False resolution. The story stopped but the ache remains. Rupture triggered automatically.")

        return suggestions

# --- Translator & Orchestration -------------------------------------------

class Vanilla:
    # tiny stand-in for the actual Vanilla module
    def __init__(self):
        self.protocols = {}
        self.thresholds = {}
    def define_protocol(self, name, fn):
        self.protocols[name] = fn
    def set_threshold(self, name, value):
        self.thresholds[name] = value
    def enforce(self, fragment):
        # simple enforcement metadata
        return {"length_ok": len(fragment) >= self.thresholds.get("length", 0)}

class Translator:
    def __init__(self, vanilla, bonepoke_engine, pbtests=None):
        self.vanilla = vanilla
        self.bonepoke_engine = bonepoke_engine
        self.pbtests = pbtests
        self.interface = {}

    def tune(self, input_data, fragment_id=None, parent_id=None, memory_trace=None): # Added arg
        vanilla_status = self.vanilla.enforce(input_data)
        composted = self.bonepoke_engine.ingest(
            fragment=input_data,
            fragment_id=fragment_id,
            parent_id=parent_id,
            memory_residue=memory_trace or [] # Added arg
        )
        scores = self.pbtests.score(composted) if self.pbtests else {}
        suggestions = self.pbtests.salvage_suggestions(composted) if self.pbtests else []
        self.interface = {
            'vanilla_status': vanilla_status,
            'composted': composted,
            'scores': scores,
            'suggestions': suggestions
        }
    def shimmer(self):
        return self.interface

class CojoinedBone:
    def __init__(self, use_pbtests=True):
        self.memory = MemoryResidue()
        self.vanilla = Vanilla()
        self.bonepoke_engine = BonepokeCoreEngine()
        self.pbtests = PBTestSuite() if use_pbtests else None
        self.translator = Translator(self.vanilla, self.bonepoke_engine, self.pbtests)
        self.last_fragment_id = None

        # --- Conceptual Orientation (NEW) ---
        self.CONCEPTUAL_ORIENTATION = {
            "Tri_Brain_Scaffold": {
                "Vanilla": "Containment (LLM Hygiene)",
                "Bonepoke": "Compost (Non-Linear Quantification)",
                "Translator": "Shimmer (Metric Presentation)"
            },
            "Architect_Role": {
                "Idea_Ratio": "95%",
                "Skill_Ratio": "5%",
                "Leverage_Ratio": "95%",
                "Audit_Ratio": "5%"
            },
            "Core_Logic": "Use a nonlinear architecture (Tri-Brain) to stabilize the AI so that the resulting output can be accurately audited (BP)."
        }
        # -----------------------------------

        # minimal protocols
        self.vanilla.define_protocol('no_null', lambda x: x is not None)
        self.vanilla.define_protocol('compost_safety', is_composted)
        self.vanilla.set_threshold('length', 5)

    def ingest(self, input_data):
        fragment_id = str(uuid4())
        parent_id = self.last_fragment_id
        self.last_fragment_id = fragment_id

        self.memory.leave_trace(input_data)
        # PASS THE MEMORY HERE
        self.translator.tune(input_data, fragment_id=fragment_id, parent_id=parent_id, memory_trace=self.memory.layers)
        return self.translator.shimmer()

    def declare(self):
        return {
            'Conceptual_Orientation': self.CONCEPTUAL_ORIENTATION,  # NEW
            'memory': self.memory.recall(),
            'shimmer': self.translator.shimmer()
        }

# --- Demo / smoke ---------------------------------------------------------

if __name__ == "__main__":
    system = CojoinedBone(use_pbtests=True)
    
    print("\n--- Conceptual Manifest ---\n")
    # Display the new conceptual variables immediately on run
    for k, v in system.CONCEPTUAL_ORIENTATION.items():
        print(f"**{k.replace('_', ' ')}:**")
        if isinstance(v, dict):
            for k2, v2 in v.items():
                print(f"  - {k2}: {v2}")
        else:
            print(f"  - {v}")
    print("\n---------------------------\n")


    print("Paste your story fragment (or enter a short test string):\n")
    fragment = input().strip() or "The vault looped and ache grew. CONTRADICTION: it was already not."

    state = system.ingest(fragment)

    print("\n--- System Shimmer ---\n")
    for key, value in state.items():
        print(f"{key}: {value}\n")

    print("--- Final Declaration ---\n")
    print(system.declare())
