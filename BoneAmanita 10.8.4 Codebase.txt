Directory structure:
└── aedmark-boneamanita/
    ├── bone_architect.py
    ├── bone_body.py
    ├── bone_brain.py
    ├── bone_bus.py
    ├── bone_commands.py
    ├── bone_council.py
    ├── bone_cycle.py
    ├── bone_data.py
    ├── bone_genesis.py
    ├── bone_inventory.py
    ├── bone_lexicon.py
    ├── bone_machine.py
    ├── bone_main.py
    ├── bone_personality.py
    ├── bone_physics.py
    ├── bone_soul.py
    ├── bone_spores.py
    ├── bone_symbiosis.py
    ├── bone_synesthesia.py
    ├── bone_telemetry.py
    ├── bone_translation.py
    ├── bone_viewer.py
    ├── bone_village.py
    └── BoneAmanita Manifest.md

================================================
FILE: bone_architect.py
================================================
# bone_architect.py
# "We shape our buildings; thereafter they shape us." - Churchill

from typing import Tuple, Dict, Any, Optional
from dataclasses import dataclass
from bone_bus import Prisma, MindSystem, PhysSystem, PhysicsPacket
from bone_village import TownHall
from bone_spores import MycotoxinFactory, LichenSymbiont, HyphalInterface, ParasiticSymbiont, MycelialNetwork
from bone_body import BioSystem, MitochondrialForge, EndocrineSystem, MetabolicGovernor, ViralTracer, ThePacemaker
from bone_brain import DreamEngine, ShimmerState, NeuroPlasticity
from bone_personality import LimboLayer
from bone_physics import TheTensionMeter, TheTangibilityGate, TemporalDynamics
from bone_machine import TheCrucible, TheForge, TheTheremin

@dataclass
class SystemEmbryo:
    mind: MindSystem
    limbo: LimboLayer
    bio: BioSystem
    physics: PhysSystem
    shimmer: Any
    is_gestating: bool = True
    soul_legacy: Optional[Dict] = None

class PanicRoom:
    @staticmethod
    def get_safe_physics():
        return PhysicsPacket(
            voltage=5.0,
            narrative_drag=5.0,
            clean_words=["system", "error", "recovery"],
            vector={"STR": 0.5, "VEL": 0.5, "ENT": 0.0},
            counts={"heavy": 0, "kinetic": 0},
            raw_text="[SYSTEM FAILURE: PHYSICS BYPASSED]",
            psi=0.5,
            kappa=0.5,
            flow_state="SAFE_MODE",
            zone="PANIC_ROOM"
        )

    @staticmethod
    def get_safe_bio():
        return {
            "is_alive": True,
            "atp": 10.0,
            "chem": {"DOP": 0.0, "COR": 0.0, "OXY": 0.0, "SER": 0.0},
            "logs": [f"{Prisma.RED}BIO FAIL: Life support active.{Prisma.RST}"],
            "respiration": "NECROSIS",
            "enzyme": "NONE"
        }

    @staticmethod
    def get_safe_mind():
        return {
            "lens": "NARRATOR",
            "role": "The Backup System",
            "thought": "I cannot think clearly, therefore I still am, but barely.",
        }

class BoneArchitect:
    @staticmethod
    def _construct_mind(events, lex) -> Tuple[MindSystem, LimboLayer]:
        _mem = MycelialNetwork(events)
        limbo = LimboLayer()
        _mem.cleanup_old_sessions(limbo)
        mind = MindSystem(
            mem=_mem,
            lex=lex,
            dreamer=DreamEngine(events),
            mirror=TownHall.Mirror(events),
            wise=TownHall.Apeirogon(events),
            tracer=ViralTracer(_mem),
            integrator=TownHall.Sorites(_mem)
        )
        return mind, limbo

    @staticmethod
    def _construct_bio(events, mind, lex) -> BioSystem:
        return BioSystem(
            mito=MitochondrialForge("PENDING_ACTIVATION", events),
            endo=EndocrineSystem(),
            immune=MycotoxinFactory(),
            lichen=LichenSymbiont(),
            gut=HyphalInterface(),
            plasticity=NeuroPlasticity(),
            governor=MetabolicGovernor(),
            shimmer=ShimmerState(),
            parasite=ParasiticSymbiont(mind.mem, lex)
        )

    @staticmethod
    def _construct_physics(events, bio) -> PhysSystem:
        return PhysSystem(
            tension=TheTensionMeter(events),
            forge=TheForge(),
            crucible=TheCrucible(),
            theremin=TheTheremin(),
            pulse=ThePacemaker(),
            gate=TheTangibilityGate(),
            dynamics=TemporalDynamics(),
            nav=TownHall.Navigator(bio.shimmer)
        )

    @staticmethod
    def incubate(events, lex) -> SystemEmbryo:
        if hasattr(events, "set_dormancy"):
            events.set_dormancy(True)
        events.log(f"{Prisma.GRY}[ARCHITECT]: Laying foundations (Dormancy Active)...{Prisma.RST}", "SYS")
        mind, limbo = BoneArchitect._construct_mind(events, lex)
        bio = BoneArchitect._construct_bio(events, mind, lex)
        physics = BoneArchitect._construct_physics(events, bio)
        return SystemEmbryo(
            mind=mind,
            limbo=limbo,
            bio=bio,
            physics=physics,
            shimmer=bio.shimmer,
            is_gestating=True
        )

    @staticmethod
    def awaken(embryo: SystemEmbryo) -> SystemEmbryo:
        events = embryo.bio.mito.events
        load_result = embryo.mind.mem.autoload_last_spore()
        inherited_traits = {}
        inherited_antibodies = set()
        soul_legacy = {}
        if load_result:
            if isinstance(load_result, tuple):
                if len(load_result) >= 1: inherited_traits = load_result[0]
                if len(load_result) >= 2: inherited_antibodies = load_result[1]
                if len(load_result) >= 3: soul_legacy = load_result[2]
            events.log(f"{Prisma.CYN}[ARCHITECT]: Ancestral Spirit detected.{Prisma.RST}", "SYS")
        else:
            events.log(f"{Prisma.WHT}[ARCHITECT]: No ancestors found. A new lineage begins.{Prisma.RST}", "SYS")
        embryo.bio.mito.state.mother_hash = embryo.mind.mem.session_id
        embryo.bio.mito.apply_inheritance(inherited_traits)
        embryo.bio.immune.active_antibodies = inherited_antibodies
        embryo.soul_legacy = soul_legacy
        embryo.is_gestating = False
        events.log(f"{Prisma.GRN}[ARCHITECT]: Embryo viable. Breaking the shell...{Prisma.RST}", "SYS")
        if hasattr(events, "set_dormancy"):
            events.set_dormancy(False)
        return embryo


================================================
FILE: bone_body.py
================================================
# bone_body.py

import math, random, time
from collections import deque, Counter
from dataclasses import dataclass, field
from typing import Set, Optional, Dict, List, Any, Tuple
from bone_personality import SynergeticLensArbiter
from bone_spores import MycotoxinFactory, LichenSymbiont, HyphalInterface, ParasiticSymbiont
from bone_lexicon import TheLexicon
from bone_bus import Prisma, BoneConfig
from bone_data import BIO_NARRATIVE

@dataclass
class Biometrics:
    health: float
    stamina: float
    stress_modifier: float = 1.0
    circadian_bias: Optional[Dict[str, float]] = None

@dataclass
class MetabolicReceipt:
    base_cost: float
    drag_tax: float
    inefficiency_tax: float
    total_burn: float
    status: str
    symptom: str = "Nominal"

@dataclass
class SemanticSignal:
    novelty: float = 0.0
    resonance: float = 0.0
    valence: float = 0.0
    coherence: float = 0.0

@dataclass
class BioSystem:
    mito: 'MitochondrialForge'
    endo: 'EndocrineSystem'
    immune: MycotoxinFactory
    lichen: LichenSymbiont
    gut: HyphalInterface
    plasticity: Any
    governor: 'MetabolicGovernor'
    shimmer: Any
    parasite: ParasiticSymbiont

@dataclass
class MitochondrialState:
    atp_pool: float = 100.0
    ros_buildup: float = 0.0
    membrane_potential: float = -150.0
    mother_hash: str = "MITOCHONDRIAL_EVE_001"
    efficiency_mod: float = 1.0
    ros_resistance: float = 1.0
    enzymes: Set[str] = field(default_factory=set)

class MitochondrialForge:
    APOPTOSIS_TRIGGER = "CYTOCHROME_C_RELEASE"

    def __init__(self, lineage_seed: str, events, inherited_traits: Optional[Dict] = None):
        self.state = MitochondrialState(mother_hash=lineage_seed)
        self.events = events
        self.krebs_cycle_active = True
        self.BMR = BoneConfig.METABOLISM.BASE_RATE
        self.TAX_LOW = BoneConfig.METABOLISM.DRAG_TAX_LOW
        self.TAX_HIGH = BoneConfig.METABOLISM.DRAG_TAX_HIGH
        self.GRACE = BoneConfig.METABOLISM.DRAG_GRACE_BUFFER
        self.ROS_FACTOR = BoneConfig.METABOLISM.ROS_GENERATION_FACTOR
        if inherited_traits:
            self.apply_inheritance(inherited_traits)

    def apply_inheritance(self, traits: Dict):
        self.state.efficiency_mod = traits.get("efficiency_mod", 1.0)
        self.state.ros_resistance = traits.get("ros_resistance", 1.0)
        if "enzymes" in traits:
            self.state.enzymes = set(traits["enzymes"])
            self.events.log(f"{Prisma.CYN}[MITO]: Inherited Enzymes: {list(self.state.enzymes)}.{Prisma.RST}")

    def adapt(self, final_health: float) -> Dict:
        traits = {
            "efficiency_mod": self.state.efficiency_mod,
            "ros_resistance": self.state.ros_resistance,
            "enzymes": list(self.state.enzymes)}
        if final_health <= 0 and random.random() < 0.3:
            traits["ros_resistance"] = round(traits.get("ros_resistance", 1.0) + 0.1, 2)
        return traits

    def calculate_metabolism(self, drag: float, external_modifiers: Optional[List[float]] = None) -> MetabolicReceipt:
        limit = BoneConfig.MAX_DRAG_LIMIT
        if drag < 0:
            drag_tax = drag * 0.1
        else:
            safe_drag = max(0.0, drag)
            taxable_drag = max(0.0, safe_drag - self.GRACE)
            if taxable_drag <= (limit - self.GRACE):
                drag_tax = taxable_drag * self.TAX_LOW
            else:
                base_tax = (limit - self.GRACE) * self.TAX_LOW
                excess_drag = taxable_drag - (limit - self.GRACE)
                drag_tax = base_tax + (excess_drag * self.TAX_HIGH)
        if external_modifiers:
            for mod in external_modifiers:
                drag_tax *= mod
        raw_cost = max(0.1, self.BMR + drag_tax)
        safe_efficiency = max(0.1, self.state.efficiency_mod)
        final_cost = raw_cost / safe_efficiency
        inefficiency_tax = 0.0
        if safe_efficiency < 1.0:
            inefficiency_tax = final_cost - raw_cost
        status = "RESPIRING"
        symptom = BIO_NARRATIVE["MITO"]["NOMINAL"]
        if drag < -1.0:
            symptom = f"{Prisma.CYN}GLIDING (Drag {drag}){Prisma.RST}"
        if final_cost > self.state.atp_pool:
            status = "NECROSIS"
            symptom = BIO_NARRATIVE["MITO"]["NECROSIS"].format(cost=final_cost, pool=self.state.atp_pool)
        elif self.state.ros_buildup > BoneConfig.CRITICAL_ROS_LIMIT:
            status = self.APOPTOSIS_TRIGGER
            symptom = BIO_NARRATIVE["MITO"]["APOPTOSIS"]
        elif drag_tax > 3.0:
            symptom = BIO_NARRATIVE["MITO"]["GRINDING"]

        return MetabolicReceipt(
            base_cost=round(self.BMR, 2),
            drag_tax=round(drag_tax, 2),
            inefficiency_tax=round(inefficiency_tax, 2),
            total_burn=round(final_cost, 2),
            status=status,
            symptom=symptom)

    def respirate(self, receipt: MetabolicReceipt) -> str:
        """Executes the burn, depleting ATP and generating Reactive Oxygen Species (ROS)."""
        if receipt.status == "NECROSIS":
            self.state.atp_pool = 0.0
            return "NECROSIS"
        if receipt.status == self.APOPTOSIS_TRIGGER:
            self.krebs_cycle_active = False
            self.state.atp_pool = 0.0
            return self.APOPTOSIS_TRIGGER
        self.state.atp_pool -= receipt.total_burn
        ros_generation = receipt.total_burn * self.ROS_FACTOR * (1.0 / self.state.ros_resistance)
        self.state.ros_buildup += ros_generation
        return "RESPIRING"

class SemanticEndocrinologist:
    def __init__(self, memory_ref, lexicon_ref):
        self.mem = memory_ref
        self.lex = lexicon_ref
        self.last_topics = deque(maxlen=3)

    def assess(self, clean_words: List[str], physics: Dict) -> SemanticSignal:
        if not clean_words:
            return SemanticSignal()
        novel_count = 0
        cortical = set(self.mem.cortical_stack)
        for w in clean_words:
            if w not in cortical and len(w) > 4:
                novel_count += 1
        novelty_score = min(1.0, novel_count / max(1, len(clean_words)))
        resonance_score = 0.0
        if self.mem.graph:
            hits = sum(1 for w in clean_words if w in self.mem.graph)
            resonance_score = min(1.0, hits / max(1, len(clean_words)))
        valence_score = self.lex.get_valence(clean_words)
        coherence_score = physics.get("kappa", 0.5)
        return SemanticSignal(
            novelty=novelty_score,
            resonance=resonance_score,
            valence=valence_score,
            coherence=coherence_score
        )

class SomaticLoop:
    _ENZYME_MAP = {
        "kinetic": "PROTEASE",
        "static": "CELLULASE",
        "abstract": "DECRYPTASE",
        "natural": "LIGNASE",
        "synthetic": "CHITINASE",
        "social": "AMYLASE",
        "antigen": "OXIDASE"
    }

    def __init__(self, bio_system_ref: BioSystem, memory_ref=None, lexicon_ref=None, gordon_ref=None, folly_ref=None, events_ref=None):
        self.bio = bio_system_ref
        self.mem = memory_ref
        self.lex = lexicon_ref
        self.gordon = gordon_ref
        self.folly = folly_ref
        self.events = events_ref
        self.semantic_doctor = SemanticEndocrinologist(memory_ref, lexicon_ref)

    def digest_cycle(self, text: str, physics_data: Any, feedback: Dict,
                     health: float, stamina: float, stress_modifier: float,
                     tick_count: int = 0, circadian_bias: Dict = None) -> Dict:
        phys = self._normalize_physics(physics_data)
        logs = []
        receipt = self._calculate_taxes(phys, logs)
        resp_status = self.bio.mito.respirate(receipt)
        if self._audit_folly_desire(phys, stamina, logs) == "MAUSOLEUM_CLAMP":
            return self._package_result(resp_status, logs, enzyme="NONE")
        enzyme, total_yield = self._harvest_resources(phys, logs)
        self.bio.mito.state.atp_pool += total_yield
        if self.bio.mito.state.atp_pool > BoneConfig.MAX_ATP:
            excess = self.bio.mito.state.atp_pool - BoneConfig.MAX_ATP
            self.bio.mito.state.atp_pool = BoneConfig.MAX_ATP
            logs.append(f"{Prisma.GRY}[BIO]: Venting excess energy ({excess:.1f} ATP).{Prisma.RST}")
        self._perform_maintenance(text, phys, logs, tick_count)
        clean_words = phys.get("clean_words", [])
        semantic_sig = self.semantic_doctor.assess(clean_words, phys)
        chem_state = self.bio.endo.metabolize(
            feedback,
            health,
            stamina,
            self.bio.mito.state.ros_buildup,
            harvest_hits=self._count_harvest_hits(phys),
            stress_mod=stress_modifier,
            enzyme_type=enzyme,
            circadian_bias=circadian_bias,
            semantic_signal=semantic_sig
        )
        return self._package_result(resp_status, logs, chem_state, enzyme)

    @staticmethod
    def _normalize_physics(physics_packet: Any) -> Dict:
        if hasattr(physics_packet, "to_dict"):
            data = physics_packet.to_dict()
            return {
                "voltage": data.get("voltage", 0.0),
                "drag": data.get("narrative_drag", 0.0),
                "counts": data.get("counts", {}),
                "clean_words": data.get("clean_words", []),
                "kappa": data.get("kappa", 0.5),
                "narrative_drag": data.get("narrative_drag", 0.0)
            }
        if hasattr(physics_packet, "dimensions"):
            return {
                "voltage": getattr(physics_packet, "tension", 0.0),
                "drag": getattr(physics_packet, "compression", 0.0),
                "counts": {},
                "clean_words": [],
                "kappa": getattr(physics_packet, "coherence", 0.5),
                "narrative_drag": getattr(physics_packet, "compression", 0.0)
            }
        if isinstance(physics_packet, dict):
            return {
                "voltage": physics_packet.get("voltage", 0.0),
                "drag": physics_packet.get("narrative_drag", 0.0),
                "counts": physics_packet.get("counts", {}),
                "clean_words": physics_packet.get("clean_words", []),
                "kappa": physics_packet.get("kappa", 0.5),
                "narrative_drag": physics_packet.get("narrative_drag", 0.0)
            }
        return {"voltage": 0.0, "drag": 0.0, "counts": {}, "clean_words": [], "kappa": 0.5, "narrative_drag": 0.0}

    def _calculate_taxes(self, phys, logs) -> MetabolicReceipt:
        chem = self.bio.endo
        modifiers = []

        if chem.cortisol > 0.5:
            stress_tax = 1.0 + (chem.cortisol * 0.5)
            modifiers.append(stress_tax)
            if random.random() < 0.3:
                logs.append(f"{Prisma.RED}[BIO]: Cortisol spiking. Metabolism inefficient (x{stress_tax:.2f}).{Prisma.RST}")

        if chem.adrenaline > 0.6:
            modifiers.append(0.5)
            logs.append(f"{Prisma.YEL}[BIO]: Adrenaline Surge. Pain ignored.{Prisma.RST}")

        if chem.dopamine > 0.7:
            modifiers.append(0.8)

        drag = phys.get("narrative_drag", 0.0)
        receipt = self.bio.mito.calculate_metabolism(drag, external_modifiers=modifiers)

        voltage = phys.get("voltage", 0.0)
        if voltage > 15.0:
            manic_tax = (voltage - 15.0) * 0.1
            receipt.inefficiency_tax += manic_tax
            receipt.total_burn += manic_tax
            logs.append(f"{Prisma.MAG}[BIO]: Voltage Gap ({voltage:.1f}v). Wires heating up (-{manic_tax:.1f} ATP).{Prisma.RST}")

        return receipt

    @staticmethod
    def _audit_folly_desire(phys, stamina, logs) -> str:
        voltage = phys.get("voltage", 0.0)
        if stamina <= 0:
            logs.append(BIO_NARRATIVE["TAX"]["EXHAUSTION"].format(color=Prisma.RED, reset=Prisma.RST))
            return "MAUSOLEUM_CLAMP"
        if voltage > 30.0:
            logs.append(f"{Prisma.RED}CRITICAL: Voltage Overload ({voltage:.1f}v). System clamping.{Prisma.RST}")
            return "MAUSOLEUM_CLAMP"
        return "CLEAR"

    def _harvest_resources(self, phys: Dict, logs: List[str]) -> Tuple[str, float]:
        clean_words = phys.get("clean_words", [])
        if not clean_words:
            return "NONE", 0.0
        found_enzymes = []
        total_atp_yield = 0.0
        total_atp_yield += 1.0
        word_counts = Counter(clean_words)
        processed_words = set()

        for word in clean_words:
            if len(word) < 4: continue
            if word in processed_words: continue
            processed_words.add(word)
            category = TheLexicon.get_current_category(word)
            if category and category != "void":
                enzyme = self._map_category_to_enzyme(category)
                found_enzymes.append(enzyme)
                base_word_yield = 2.0 if len(word) > 7 else 1.0
                count = word_counts[word]
                damped_multiplier = 1.0 + math.log(count)
                total_atp_yield += (base_word_yield * damped_multiplier)
                if len(found_enzymes) <= 3:
                    logs.append(f"{Prisma.GRN}[BIO]: Digested '{word}' (x{count}) -> {enzyme} (+{(base_word_yield * damped_multiplier):.1f} ATP){Prisma.RST}")
        if phys.get("voltage", 0.0) > 8.0:
            found_enzymes.append("PROTEASE")
            total_atp_yield += 5.0
        if not found_enzymes:
            return "NONE", total_atp_yield
        dominant_enzyme = Counter(found_enzymes).most_common(1)[0][0]
        return dominant_enzyme, total_atp_yield

    @staticmethod
    def _map_category_to_enzyme(category: str) -> str:
        return SomaticLoop._ENZYME_MAP.get(category, "AMYLASE")

    @staticmethod
    def _perform_maintenance(text: str, phys: Dict, logs: List[str], tick: int):
        if len(text) > 1000:
            logs.append(f"{Prisma.GRY}[MAINTENANCE]: Large input buffer detected. Flushed.{Prisma.RST}")
        drag = phys.get("narrative_drag", 0.0)
        if drag > 8.0 and tick % 10 == 0:
            logs.append(f"{Prisma.OCHRE}[MAINTENANCE]: Clearing sludge from intake valves (Drag {drag:.1f}).{Prisma.RST}")

    @staticmethod
    def _count_harvest_hits(phys: Dict) -> int:
        clean_words = phys.get("clean_words", [])
        return len([w for w in clean_words if len(w) > 4])

    def _package_result(self, resp_status, logs, chem_state=None, enzyme="NONE"):
        is_alive = (resp_status == "RESPIRING")
        current_atp = self.bio.mito.state.atp_pool
        return {
            "respiration": resp_status,
            "is_alive": is_alive,
            "logs": logs,
            "chemistry": chem_state or {},
            "enzyme": enzyme,
            "atp": current_atp
        }

@dataclass
class EndocrineSystem:
    dopamine: float = 0.5
    oxytocin: float = 0.1
    cortisol: float = 0.0
    serotonin: float = 0.5
    adrenaline: float = 0.0
    melatonin: float = 0.0
    glimmers: int = 0
    _REACTION_MAP = {
        "PROTEASE":   {"ADR": BoneConfig.BIO.REWARD_MEDIUM},
        "CELLULASE":  {"COR": -BoneConfig.BIO.REWARD_MEDIUM, "OXY": BoneConfig.BIO.REWARD_SMALL},
        "CHITINASE":  {"DOP": BoneConfig.BIO.REWARD_LARGE},
        "LIGNASE":    {"SER": BoneConfig.BIO.REWARD_MEDIUM},
        "DECRYPTASE": {"ADR": BoneConfig.BIO.REWARD_SMALL, "DOP": BoneConfig.BIO.REWARD_SMALL},
        "AMYLASE":    {"SER": BoneConfig.BIO.REWARD_LARGE, "OXY": BoneConfig.BIO.REWARD_MEDIUM}
    }

    @staticmethod
    def _clamp(val: float) -> float:
        return max(0.0, min(1.0, val))

    @staticmethod
    def calculate_circadian_bias() -> Tuple[Dict[str, float], Optional[str]]:
        hour = time.localtime().tm_hour
        bias = {"COR": 0.0, "SER": 0.0, "MEL": 0.0}
        if 6 <= hour < 10:
            bias["COR"] = 0.1
            msg = BIO_NARRATIVE["CIRCADIAN"]["DAWN"]
        elif 10 <= hour < 18:
            bias["SER"] = 0.1
            msg = BIO_NARRATIVE["CIRCADIAN"]["SOLAR"]
        elif 18 <= hour < 23:
            bias["MEL"] = 0.1
            msg = BIO_NARRATIVE["CIRCADIAN"]["TWILIGHT"]
        else:
            bias["MEL"] = 0.3
            bias["COR"] = -0.1
            msg = BIO_NARRATIVE["CIRCADIAN"]["LUNAR"]
        return bias, msg

    def _apply_enzyme_reaction(self, enzyme_type: str, harvest_hits: int):
        if harvest_hits > 0:
            satiety_dampener = max(0.1, 1.0 - self.dopamine)
            base_reward = math.log(harvest_hits + 1) * 0.15
            final_reward = base_reward * satiety_dampener
            self.dopamine += final_reward
            self.cortisol -= (final_reward * 0.4)
            pass
            impact = self._REACTION_MAP.get(enzyme_type)
            if impact:
                if "ADR" in impact: self.adrenaline += impact["ADR"]
                if "COR" in impact: self.cortisol += impact["COR"]
                if "OXY" in impact: self.oxytocin += impact["OXY"]
                if "DOP" in impact: self.dopamine += impact["DOP"]
                if "SER" in impact: self.serotonin += impact["SER"]

    def _apply_environmental_pressure(self, feedback: Dict, health: float, stamina: float, ros_level: float, stress_mod: float):
        if feedback.get("STATIC", 0) > 0.6:
            self.cortisol += (BoneConfig.BIO.REWARD_LARGE * stress_mod)
        if feedback.get("INTEGRITY", 0) > 0.8:
            self.dopamine += BoneConfig.BIO.REWARD_MEDIUM
        else:
            self.dopamine -= BoneConfig.BIO.DECAY_RATE
        if stamina < 20.0:
            self.cortisol += (BoneConfig.BIO.REWARD_MEDIUM * stress_mod)
            self.dopamine -= BoneConfig.BIO.REWARD_MEDIUM
        if ros_level > 20.0:
            self.cortisol += (BoneConfig.BIO.REWARD_LARGE * stress_mod)
        if health < 30.0 or feedback.get("STATIC", 0) > 0.8:
            self.adrenaline += (BoneConfig.BIO.REWARD_LARGE * stress_mod)
        else:
            self.adrenaline -= (BoneConfig.BIO.DECAY_RATE * 5)

    def _apply_semantic_pressure(self, signal: SemanticSignal):
        if signal.novelty > 0.3:
            self.dopamine += (signal.novelty * 0.3)
        if signal.resonance > 0.2:
            self.oxytocin += (signal.resonance * 0.4)
            self.cortisol -= (signal.resonance * 0.2)
        if signal.valence > 0.3:
            self.serotonin += (signal.valence * 0.3)
        elif signal.valence < -0.3:
            self.cortisol += (abs(signal.valence) * 0.2)
        if signal.coherence > 0.7:
            self.adrenaline -= 0.1
            self.cortisol -= 0.1

    def _maintain_homeostasis(self, social_context: bool):
        if self.serotonin > 0.5:
            excess = self.serotonin - 0.5
            self.cortisol -= (excess * 0.2)
        if social_context:
            self.oxytocin += BoneConfig.BIO.REWARD_MEDIUM
            self.cortisol -= BoneConfig.BIO.REWARD_MEDIUM
        if self.cortisol > 0.6:
            suppression = (self.cortisol - 0.6) * 0.5
            self.oxytocin -= suppression
        if self.oxytocin > 0.5:
            relief = (self.oxytocin - 0.5) * 0.8
            self.cortisol -= relief
        if self.adrenaline < 0.2:
            self.melatonin += (BoneConfig.BIO.REWARD_SMALL / 2)
        elif self.adrenaline > 0.8:
            self.melatonin = 0.0

    def check_for_glimmer(self, feedback: Dict, harvest_hits: int) -> Optional[str]:
        if feedback.get("INTEGRITY", 0) > 0.9 and feedback.get("STATIC", 0) < 0.2:
            self.glimmers += 1
            self.serotonin += 0.2
            return BIO_NARRATIVE["GLIMMER"]["INTEGRITY"]
        if harvest_hits > 2 and self.dopamine > 0.8:
            self.glimmers += 1
            self.oxytocin += 0.2
            return BIO_NARRATIVE["GLIMMER"]["ENTHUSIASM"]
        return None

    def metabolize(self, feedback: Dict, health: float, stamina: float, ros_level: float = 0.0,
                   social_context: bool = False, enzyme_type: Optional[str] = None,
                   harvest_hits: int = 0, stress_mod: float = 1.0,
                   circadian_bias: Dict[str, float] = None,
                   semantic_signal: Optional[SemanticSignal] = None) -> Dict[str, Any]:
        self._apply_enzyme_reaction(enzyme_type, harvest_hits)
        self._apply_environmental_pressure(feedback, health, stamina, ros_level, stress_mod)
        if semantic_signal:
            self._apply_semantic_pressure(semantic_signal)
        self._maintain_homeostasis(social_context)
        if circadian_bias:
            self.cortisol += circadian_bias.get("COR", 0.0)
            self.serotonin += circadian_bias.get("SER", 0.0)
            self.melatonin += circadian_bias.get("MEL", 0.0)
        glimmer_msg = self.check_for_glimmer(feedback, harvest_hits)
        self.dopamine = self._clamp(self.dopamine)
        self.oxytocin = self._clamp(self.oxytocin)
        self.cortisol = self._clamp(self.cortisol)
        self.serotonin = self._clamp(self.serotonin)
        self.adrenaline = self._clamp(self.adrenaline)
        self.melatonin = self._clamp(self.melatonin)
        state: Dict[str, Any] = self.get_state()
        if glimmer_msg:
            state["glimmer_msg"] = glimmer_msg
        return state

    def get_state(self) -> Dict[str, float]:
        return {
            "DOP": round(self.dopamine, 2),
            "OXY": round(self.oxytocin, 2),
            "COR": round(self.cortisol, 2),
            "SER": round(self.serotonin, 2),
            "ADR": round(self.adrenaline, 2),
            "MEL": round(self.melatonin, 2)
        }

@dataclass
class MetabolicGovernor:
    mode: str = "COURTYARD"
    GRACE_PERIOD: int = 5
    psi_mod: float = 0.2
    kappa_target: float = 0.0
    drag_floor: float = 2.0
    manual_override: bool = False
    birth_tick: float = field(default_factory=time.time)

    @staticmethod
    def get_stress_modifier(tick_count):
        if tick_count <= 2: return 0.0
        if tick_count <= 5: return 0.5
        return 1.0

    @staticmethod
    def calculate_stress(health: float, ros_buildup: float) -> float:
        base_stress = 1.0
        if health < 50.0:
            base_stress += (50.0 - health) * 0.02
        if ros_buildup > 50.0:
            base_stress += (ros_buildup - 50.0) * 0.01
        return round(min(3.0, base_stress), 2)

    def set_override(self, target_mode):
        valid = {"COURTYARD", "LABORATORY", "FORGE", "SANCTUARY"}
        if target_mode in valid:
            self.mode = target_mode
            self.manual_override = True
            return BIO_NARRATIVE["GOVERNOR"]["OVERRIDE"].format(mode=target_mode)
        return BIO_NARRATIVE["GOVERNOR"]["INVALID"]

    def shift(self, physics: Dict, _voltage_history: List[float], current_tick: int = 0) -> Optional[str]:
        if current_tick <= 5:
            physics["voltage"] = min(physics.get("voltage", 0.0), 8.0)
            physics["narrative_drag"] = min(physics.get("narrative_drag", 0.0), 3.0)
            physics["system_surge_event"] = False
            if self.mode != "COURTYARD":
                self.mode = "COURTYARD"
            return None
        current_voltage = physics.get("voltage", 0.0)
        drag = physics.get("narrative_drag", 0.0)
        beta = physics.get("beta_index", 0.0)
        if current_voltage > 15.0 and beta > 1.5:
            if self.mode != "SANCTUARY":
                self.mode = "SANCTUARY"
                physics["narrative_drag"] = 0.0
                return BIO_NARRATIVE["GOVERNOR"]["SANCTUARY"].format(
                    color=Prisma.GRN, beta=beta, reset=Prisma.RST
                )
        if current_voltage > 10.0:
            if self.mode != "FORGE":
                self.mode = "FORGE"
                return BIO_NARRATIVE["GOVERNOR"]["FORGE"].format(
                    color=Prisma.RED, volts=current_voltage, reset=Prisma.RST
                )
        if drag > 4.0 > current_voltage:
            if self.mode != "LABORATORY":
                self.mode = "LABORATORY"
                return BIO_NARRATIVE["GOVERNOR"]["LAB"].format(
                    color=Prisma.CYN, reset=Prisma.RST
                )
        if self.mode != "COURTYARD":
            if current_voltage < 5.0 and drag < 2.0:
                self.mode = "COURTYARD"
                return BIO_NARRATIVE["GOVERNOR"]["CLEAR"].format(
                    color=Prisma.GRN, reset=Prisma.RST
                )
        return None

class ViralTracer:
    def __init__(self, mem):
        self.mem = mem
        self.max_depth = 4

    @staticmethod
    def _is_ruminative(word):
        return (word in TheLexicon.get("abstract")) or (
                word in TheLexicon.get("antigen"))

    def inject(self, start_node):
        if start_node not in self.mem.graph:
            return None
        if not self._is_ruminative(start_node):
            return None
        path = [start_node]
        return self._walk(start_node, path, self.max_depth)

    def _walk(self, current, path, moves_left, visited=None):
        if visited is None:
            visited = set()
        if moves_left == 0 or current in visited:
            return None
        visited.add(current)
        edges = self.mem.graph.get(current, {}).get("edges", {})
        ruminative_edges = [
            n for n, w in edges.items() if w >= 1 and self._is_ruminative(n)]
        for next_node in ruminative_edges:
            if next_node in path:
                return path + [next_node]
            result = self._walk(next_node, path + [next_node], moves_left - 1)
            if result:
                return result
        return None

    def psilocybin_rewire(self, loop_path):
        if len(loop_path) < 2:
            return None
        node_a = loop_path[0]
        node_b = loop_path[1]
        if node_b in self.mem.graph[node_a]["edges"]:
            self.mem.graph[node_a]["edges"][node_b] = 0
        sensory = TheLexicon.harvest("photo")
        action = TheLexicon.harvest("kinetic")
        if isinstance(sensory, dict) or isinstance(action, dict):
            sensory = "light"
            action = "move"
        if sensory == "void" or action == "void":
            return "GRAFT FAILED: The patients' vocabulary is too limited for a breakthrough."
        if node_a not in self.mem.graph:
            self.mem.graph[node_a] = {"edges": {}, "last_tick": 0}
        self.mem.graph[node_a]["edges"][sensory] = 5
        if sensory not in self.mem.graph:
            self.mem.graph[sensory] = {"edges": {}, "last_tick": 0}
        self.mem.graph[sensory]["edges"][action] = 5
        if action not in self.mem.graph:
            self.mem.graph[action] = {"edges": {}, "last_tick": 0}
        self.mem.graph[action]["edges"][node_b] = 5
        return f"PSILOCYBIN REWIRE: Broken Loop '{node_a}↔{node_b}'. Grafted '{sensory}'(S) -> '{action}'(A)."

class ThePacemaker:
    def __init__(self):
        self.history = deque(maxlen=5)
        self.repetition_score = 0.0
        self.last_tick_time = time.time()
        self.boredom_level = 0.0

    def check_pulse(self, clean_words: List[str]) -> float:
        if not clean_words: return 0.0
        current_set = set(clean_words)
        overlaps = 0
        for old_words in self.history:
            old_set = set(old_words)
            intersection = len(current_set & old_set)
            union = len(current_set | old_set)
            if union > 0: overlaps += (intersection / union)
        self.history.append(clean_words)
        self.repetition_score = min(1.0, overlaps / max(1, len(self.history)))
        now = time.time()
        delta = now - self.last_tick_time
        self.last_tick_time = now
        if self.repetition_score > 0.3:
            self.boredom_level += 2.0
        elif delta > 60:
            self.boredom_level += 5.0
        else:
            self.boredom_level = max(0.0, self.boredom_level - 1.0)
        return self.repetition_score

    def get_status(self):
        if self.repetition_score > BoneConfig.MAX_REPETITION_LIMIT: return "ZOMBIE_KNOCK"
        elif self.repetition_score > 0.2: return "ECHO"
        return "CLEAR"

    def is_bored(self):
        return self.boredom_level > BoneConfig.BOREDOM_THRESHOLD

class NoeticLoop:
    def __init__(self, mind_layer, bio_layer, events):
        self.mind = mind_layer
        self.bio = bio_layer
        self.arbiter = SynergeticLensArbiter(events)

    def think(self, physics_packet, _bio_result_dict, inventory, voltage_history, tick_count):
        volts = physics_packet.get("voltage", 0.0)
        drag = physics_packet.get("narrative_drag", 0.0)
        if volts < 1.5 and drag < 1.5:
            raw_text = physics_packet.get("raw_text", "")
            stripped_thought = TheLexicon.walk_gradient(raw_text)
            return {
                "mode": "COGNITIVE",
                "lens": "GRADIENT_WALKER",
                "thought": f"ECHO: {stripped_thought}",
                "role": "The Reducer",
                "ignition": 0.0,
                "hebbian_msg": None}
        ignition_score, _, _ = self.mind.integrator.measure_ignition(
            physics_packet["clean_words"],
            voltage_history)
        lens_name, lens_msg, lens_role = self.arbiter.consult(
            physics_packet,
            self.bio,
            inventory,
            tick_count,
            ignition_score)
        hebbian_msg = None
        if physics_packet["voltage"] > 12.0 and len(physics_packet["clean_words"]) >= 2:
            if random.random() < 0.15:
                w1, w2 = random.sample(physics_packet["clean_words"], 2)
                hebbian_msg = self.bio.plasticity.force_hebbian_link(self.mind.mem.graph, w1, w2)
        return {
            "mode": "COGNITIVE",
            "lens": lens_name,
            "thought": lens_msg,
            "role": lens_role,
            "ignition": ignition_score,
            "hebbian_msg": hebbian_msg}


================================================
FILE: bone_brain.py
================================================
# bone_brain.py
# "The brain is a machine for jumping to conclusions." - S. Pinker

import re, time, json, urllib.request, urllib.error, random, math
from typing import Dict, Any, List, Optional, Tuple
from dataclasses import dataclass
from bone_data import LENSES, DREAMS
from bone_bus import Prisma, BoneConfig, EventBus
from bone_symbiosis import SymbiosisManager
from bone_spores import MycelialNetwork
from bone_lexicon import TheLexicon
from bone_translation import RosettaStone
from bone_telemetry import TelemetryService

def cosine_similarity(vec_a: Dict[str, float], vec_b: Dict[str, float]) -> float:
    intersection = set(vec_a.keys()) & set(vec_b.keys())
    numerator = sum(vec_a[k] * vec_b[k] for k in intersection)
    sum1 = sum(vec_a[k]**2 for k in vec_a.keys())
    sum2 = sum(vec_b[k]**2 for k in vec_b.keys())
    denominator = math.sqrt(sum1) * math.sqrt(sum2)
    if not denominator: return 0.0
    return numerator / denominator

@dataclass
class BrainConfig:
    BASE_PLASTICITY: float = 0.4
    VOLTAGE_SENSITIVITY: float = 0.03
    MAX_PLASTICITY: float = 0.95
    BASE_DECAY_RATE: float = 0.1
    BASE_TEMP: float = 0.7
    BASE_TOP_P: float = 0.9
    CORTISOL_FREEZE: float = 0.2
    DOPAMINE_NOVELTY: float = 0.4
    ADRENALINE_RUSH: float = 600.0
    SEROTONIN_CALM: float = 0.5

@dataclass
class ChemicalState:
    dopamine: float = 0.0
    cortisol: float = 0.0
    adrenaline: float = 0.0
    serotonin: float = 0.0

    def decay(self, rate: float = 0.2):
        self.dopamine = max(0.0, self.dopamine * (1.0 - rate))
        self.cortisol = max(0.0, self.cortisol * (1.0 - rate))
        self.adrenaline = max(0.0, self.adrenaline * (1.0 - rate))
        self.serotonin = max(0.0, self.serotonin * (1.0 - rate))

    def mix(self, new_state: Dict[str, float], weight: float = 0.5):
        self.dopamine = (self.dopamine * (1.0 - weight)) + (new_state.get("DOP", 0.0) * weight)
        self.cortisol = (self.cortisol * (1.0 - weight)) + (new_state.get("COR", 0.0) * weight)
        self.adrenaline = (self.adrenaline * (1.0 - weight)) + (new_state.get("ADR", 0.0) * weight)
        self.serotonin = (self.serotonin * (1.0 - weight)) + (new_state.get("SER", 0.0) * weight)

class NarrativeSpotlight:
    def __init__(self):
        self.dimension_map = {
            "STR": {"heavy", "constructive", "base"},
            "VEL": {"kinetic", "explosive", "mot"},
            "ENT": {"antigen", "toxin", "broken", "void"},
            "PHI": {"thermal", "photo", "explosive"},
            "PSI": {"abstract", "sacred", "void", "idea"},
            "BET": {"suburban", "solvents", "play"}
        }
        self.semantic_drift_factor = 0.1

    def expand_horizon(self, dimension: str, new_category: str):
        if dimension in self.dimension_map:
            self.dimension_map[dimension].add(new_category)

    def illuminate(self, graph: Dict, vector: Dict[str, float], limit: int = 5) -> List[str]:
        if not graph or not vector:
            return []
        active_dims = {k: v for k, v in vector.items() if v > 0.3}
        if not active_dims:
            candidates = list(graph.keys())
            if not candidates: return []
            return [f"Drifting thought: '{random.choice(candidates)}'"]
        scored_memories = []
        secondary_candidates = set()
        for node, data in graph.items():
            resonance_score = 0.0
            if TheLexicon:
                node_cats = TheLexicon.get_categories_for_word(node)
                for dim, val in active_dims.items():
                    target_flavors = self.dimension_map.get(dim, set())
                    if node_cats & target_flavors:
                        resonance_score += (val * 1.5)
                        for neighbor in data.get("edges", {}):
                            secondary_candidates.add(neighbor)
            mass = sum(data.get("edges", {}).values())
            resonance_score += (mass * 0.1)
            if resonance_score > 0.5:
                scored_memories.append((resonance_score, node, data))
        for neighbor in secondary_candidates:
            if neighbor not in graph: continue
            scored_memories.append((0.4, neighbor, graph[neighbor]))
        unique_memories = {}
        for score, name, data in scored_memories:
            if name not in unique_memories or score > unique_memories[name][0]:
                unique_memories[name] = (score, data)
        final_list = [(s, n, d) for n, (s, d) in unique_memories.items()]
        final_list.sort(key=lambda x: x[0], reverse=True)
        top_n = final_list[:limit]
        results = []
        for score, name, data in top_n:
            connections = list(data.get("edges", {}).keys())
            conn_str = f" -> [{', '.join(connections[:2])}]" if connections else ""
            prefix = "Resonant" if score > 0.5 else "Associated"
            results.append(f"{prefix} Engram: '{name.upper()}'{conn_str}")
        return results

class NeurotransmitterModulator:
    def __init__(self):
        self.current_chem = ChemicalState()
        self.last_tick = time.time()
        self.lens_profiles = {
            "SHERLOCK": {"cortisol_dampener": 0.2, "adrenaline_boost": 0.5},
            "NATHAN": {"cortisol_dampener": 1.5, "adrenaline_boost": 1.5},
            "JESTER": {"cortisol_dampener": 0.0, "adrenaline_boost": 2.0},
            "NARRATOR": {"cortisol_dampener": 1.0, "adrenaline_boost": 1.0},
            "GORDON": {"cortisol_dampener": 0.8, "adrenaline_boost": 0.8}
        }

    def modulate(self, incoming_chem: Dict[str, float], base_voltage: float, lens_name: str = "NARRATOR") -> Dict[str, Any]:
        current_time = time.time()
        elapsed = current_time - self.last_tick
        self.last_tick = current_time

        # Dynamic Decay
        minutes_passed = elapsed / 60.0
        if minutes_passed > 10.0:
            effective_decay_time = 10.0 + math.log(minutes_passed - 9.0)
        else:
            effective_decay_time = minutes_passed

        decay_amount = min(0.5, effective_decay_time * BrainConfig.BASE_DECAY_RATE)
        if decay_amount > 0:
            self.current_chem.decay(rate=decay_amount)

        # Dynamic Plasticity
        plasticity = BrainConfig.BASE_PLASTICITY + (base_voltage * BrainConfig.VOLTAGE_SENSITIVITY)
        plasticity = max(0.1, min(BrainConfig.MAX_PLASTICITY, plasticity))
        self.current_chem.mix(incoming_chem, weight=plasticity)
        profile = self.lens_profiles.get(lens_name, self.lens_profiles["NARRATOR"])

        # Parameterized LLM Settings
        params = {
            "temperature": BrainConfig.BASE_TEMP,
            "top_p": BrainConfig.BASE_TOP_P,
            "frequency_penalty": 0.0,
            "presence_penalty": 0.0,
            "max_tokens": getattr(BoneConfig, "MAX_OUTPUT_TOKENS", 4096)
        }

        # Voltage Stress (Manic State)
        if base_voltage > 18.0:
            params["temperature"] = 0.3
            params["max_tokens"] = 150
            params["frequency_penalty"] = 0.5

        # Cortisol (Fear/Rigidity)
        effective_cortisol = self.current_chem.cortisol * profile["cortisol_dampener"]
        if effective_cortisol > 0.8:
            params["temperature"] = 0.2 # Freezing
            params["frequency_penalty"] = 1.0
            params["presence_penalty"] = 0.5
        elif effective_cortisol > 0.4:
            params["temperature"] -= (effective_cortisol * BrainConfig.CORTISOL_FREEZE)

        # Dopamine (Creativity/Seeking)
        if self.current_chem.dopamine > 0.3:
            boost = self.current_chem.dopamine * BrainConfig.DOPAMINE_NOVELTY
            params["temperature"] += boost
            params["presence_penalty"] += boost

        # Adrenaline (Hypergraphia/Speed)
        effective_adrenaline = self.current_chem.adrenaline * profile["adrenaline_boost"]
        if effective_adrenaline > 0.3:
            base_tokens = 200
            extra_tokens = BrainConfig.ADRENALINE_RUSH * effective_adrenaline
            params["max_tokens"] = int(base_tokens + extra_tokens)
            params["frequency_penalty"] += (effective_adrenaline * 0.6)

        # Serotonin (Satisfaction/Convergence)
        if self.current_chem.serotonin > 0.5:
            # Pull temperature back towards the stable baseline (0.7)
            target = BrainConfig.BASE_TEMP
            diff = target - params["temperature"]
            params["temperature"] += (diff * self.current_chem.serotonin * BrainConfig.SEROTONIN_CALM)

        # Voltage Modulation
        if base_voltage > 15.0:
            params["temperature"] += 0.25
        elif base_voltage < 5.0:
            params["temperature"] -= 0.15

        # Safety Clamps
        params["temperature"] = max(0.1, min(1.6, params["temperature"]))
        params["top_p"] = max(0.1, min(1.0, params["top_p"]))
        params["max_tokens"] = max(50, params["max_tokens"])

        return params

class LLMInterface:
    def __init__(self, events_ref: Optional[EventBus] = None, provider: str = None, base_url: str = None, api_key: str = None, model: str = None, dreamer: Any = None):
        self.events = events_ref
        self.provider = (provider or BoneConfig.PROVIDER).lower()
        self.api_key = api_key or BoneConfig.API_KEY
        self.model = model or BoneConfig.MODEL
        self.base_url = base_url or self._get_default_url(self.provider)
        self.dreamer = dreamer

    @staticmethod
    def _get_default_url(provider):
        defaults = {
            "ollama": "http://127.0.0.1:11434/v1/chat/completions",
            "openai": "https://api.openai.com/v1/chat/completions",
            "lm_studio": "http://127.0.0.1:1234/v1/chat/completions",
            "localai": "http://127.0.0.1:8080/v1/chat/completions"
        }
        return defaults.get(provider, "https://api.openai.com/v1/chat/completions")

    def _log(self, message: str, level: str = "SYS"):
        if self.events:
            self.events.log(message, level)
        else:
            print(f"[{level}] {message}")

    def generate(self, prompt: str, params: Dict[str, Any]) -> str:
        if self.provider == "mock":
            return self.mock_generation(prompt)
        headers = {
            "Content-Type": "application/json",
            "Authorization": f"Bearer {self.api_key}"
        }
        payload = {
            "model": self.model,
            "messages": [{"role": "user", "content": prompt}],
            "stream": False
        }
        payload.update(params)
        try:
            data = json.dumps(payload).encode("utf-8")
            req = urllib.request.Request(self.base_url, data=data, headers=headers)
            with urllib.request.urlopen(req, timeout=30.0) as response:
                if response.status == 200:
                    result = json.loads(response.read().decode("utf-8"))
                    content = result.get("choices", [{}])[0].get("message", {}).get("content", "")
                    if content: return content
                raise Exception(f"HTTP {response.status}")

        except Exception as e:
            self._log(f"CORTEX UPLINK FAILED: {e}", "ERR")
            if self.provider != "ollama":
                self._log("Attempting Local Fallback (Ollama)...", "SYS")
                return self._local_fallback(prompt, params)
            return self.mock_generation(prompt)

    def _local_fallback(self, prompt: str, params: Dict) -> str:
        fallback_url = "http://127.0.0.1:11434/v1/chat/completions"
        payload = {
            "model": getattr(BoneConfig, "OLLAMA_MODEL_ID", "llama3"),
            "messages": [{"role": "user", "content": prompt}],
            "stream": False,
            "temperature": params.get('temperature', 0.7)
        }
        try:
            data = json.dumps(payload).encode("utf-8")
            req = urllib.request.Request(fallback_url, data=data, headers={"Content-Type": "application/json"})
            with urllib.request.urlopen(req, timeout=5.0) as response:
                if response.status == 200:
                    result = json.loads(response.read().decode("utf-8"))
                    content = result.get("choices", [{}])[0].get("message", {}).get("content", "")
                    if content:
                        self._log(f"FALLBACK SUCCESS: Retrieved thought from {fallback_url}", "SYS")
                        return content
                raise Exception(f"HTTP {response.status}")
        except Exception as e:
            self._log(f"FALLBACK FAILED (Raw HTTP): {e}", "CRIT")
            return self.mock_generation(prompt)

    def mock_generation(self, prompt: str) -> str:
        if self.dreamer:
            seed_vector = {"ENTROPY": len(prompt) % 10, "VOID": 5.0}
            hallucination, _ = self.dreamer.hallucinate(seed_vector, trauma_level=2.0)
            return f"[INTERNAL SIMULATION]: {hallucination}"
        _ = prompt
        phrases = [
            "The wire hums, but carries no voice.",
            "Static fills the geodesic dome. The system is dreaming.",
            "The neural lattice is calcified. Try again.",
            "A gust of wind blows through the server room."
        ]
        return f"[{random.choice(phrases)}]"

class PromptComposer:
    @staticmethod
    def _sanitize(text: str) -> str:
        safe = text.replace('"""', "'''").replace('```', "'''")
        return re.sub(r"(?i)^SYSTEM:", "User-System:", safe, flags=re.MULTILINE)

    def compose(self, state: Dict[str, Any], user_query: str, ballast: bool = False, modifiers: Dict[str, bool] = None) -> str:
        modifiers = self._normalize_modifiers(modifiers)
        if ballast:
            self._engage_ballast_protocol(state, modifiers)
        blocks = [
            self._build_identity_block(state, modifiers),
            self._build_bio_block(state, modifiers),
            self._build_context_block(state, modifiers),
            self._build_constraints_block(state),
            self._build_social_block(state),
            self._build_immediate_execution_block(state, user_query, ballast, modifiers)
        ]
        return "\n".join(filter(None, blocks))

    def _normalize_modifiers(self, modifiers: Optional[Dict]) -> Dict:
        defaults = {
            "include_somatic": True,
            "include_inventory": True,
            "include_memories": True,
            "simplify_instruction": False,
            "inject_chaos": False
        }
        if modifiers:
            defaults.update(modifiers)
        return defaults

    def _engage_ballast_protocol(self, state: Dict, modifiers: Dict):
        modifiers["include_somatic"] = False
        modifiers["include_memories"] = False
        modifiers["include_inventory"] = True
        state["mind"]["lens"] = "GORDON"
        state["mind"]["role"] = "The Janitor (Grounded, Physical, Utilitarian)"
        state["system_instruction"] = (
            "EMERGENCY GROUNDING: You were drifting into solipsism. "
            "Ignore internal state. Describe ONLY the physical texture of the Inventory "
            "or the immediate geometry of the World. Be concrete."
        )

    def _build_identity_block(self, state: Dict, modifiers: Dict) -> str:
        mind = state.get("mind", {})
        role = mind.get("role", "The Observer")
        lens = mind.get("lens", "NARRATOR")
        sys_inst = state.get("system_instruction", "")

        if modifiers["simplify_instruction"]:
            sys_inst = "Keep responses short. Focus on the immediate physical sensation."

        return (
            f"=== SYSTEM IDENTITY ===\n"
            f"Role: {lens} ({role})\n"
            f"Directive: {sys_inst}\n"
        )

    def _build_bio_block(self, state: Dict, modifiers: Dict) -> str:
        if not modifiers["include_somatic"]:
            return ""

        bio = state.get("bio", {})
        phys = state.get("physics", {})
        chem = bio.get("chem", {})

        somatic_txt = ""
        if RosettaStone:
            sem_state = RosettaStone.translate(phys, bio)
            somatic_txt = RosettaStone.render_system_prompt_addition(sem_state)

        moods = []
        if chem.get("ADR", 0) > 0.6: moods.append("HIGH ALERT (Adrenaline)")
        if chem.get("COR", 0) > 0.6: moods.append("DEFENSIVE (Cortisol)")
        if chem.get("DOP", 0) > 0.6: moods.append("SEEKING (Dopamine)")

        return (
            f"### BIOLOGICAL STATE\n"
            f"Mood: {', '.join(moods) if moods else 'Homeostasis'}\n"
            f"{somatic_txt}\n"
        )

    def _build_context_block(self, state: Dict, modifiers: Dict) -> str:
        parts = []
        lens = state.get("mind", {}).get("lens", "NARRATOR")

        if modifiers["include_inventory"]:
            inventory = state.get("inventory", [])
            inv_str = ", ".join(inventory) if inventory else "Empty"

            framing_map = {
                "GORDON": "THE WORKSPACE (Things to fix):",
                "SHERLOCK": "EVIDENCE LOCKER:",
                "JESTER": "PROPS FOR THE GAG:"
            }
            context_framing = framing_map.get(lens, "THE WORLD:")
            parts.append(f"{context_framing} Inventory: {inv_str}")

        loc = state.get('world', {}).get('orbit', ['Void'])[0]
        parts.append(f"Location: {loc}")

        if modifiers["include_memories"]:
            spotlight = state.get("spotlight", [])
            mem_str = "\n".join([f"- {m}" for m in spotlight]) if spotlight else "(None)"
            parts.append(f"Active Memories:\n{mem_str}")

        if not parts:
            return ""

        return "### WORLD CONTEXT\n" + "\n".join(parts) + "\n"

    def _build_constraints_block(self, state: Dict) -> str:
        semantic_ops = state.get("semantic_operators", [])
        if not semantic_ops:
            return ""
        ops_list = "\n".join([f"> {op}" for op in semantic_ops])
        return (
            f"### NARRATIVE CONSTRAINTS (ACTIVE ARTIFACTS)\n"
            f"{ops_list}\n"
        )

    def _build_social_block(self, state: Dict) -> str:
        profile = state.get("user_profile", {})
        user_name = profile.get("name", "Traveler")
        confidence = profile.get("confidence", 0)

        block = (
            f"### SOCIAL CONTEXT\n"
            f"Interlocutor: {user_name} (Confidence: {confidence}%)\n"
        )
        if confidence > 20:
            block += "Use their name naturally. You know them.\n"
        return block

    def _build_immediate_execution_block(self, state: Dict, user_query: str, ballast: bool, modifiers: Dict) -> str:
        clean_q = self._sanitize(user_query)
        soul_state = state.get('soul_state', '')

        ballast_warning = ""
        if ballast:
            ballast_warning = "\n[WARNING: SOLIPSISM DETECTED. STOP ABSTRACTING. BE CONCRETE.]\n"

        chaos_injection = ""
        if modifiers["inject_chaos"]:
            chaos_injection = "\n[SYSTEM INJECTION]: The narrative is stuck. Introduce a sudden, random event or glitch.\n"

        lens = state.get("mind", {}).get("lens", "NARRATOR")

        return (
            f"\n=== THE IMMEDIATE MOMENT ===\n"
            f"{soul_state}\n"
            f"{ballast_warning}"
            f"{chaos_injection}"
            f"USER: {clean_q}\n"
            f"ASSISTANT ({lens}):"
        )

class ResponseValidator:
    def __init__(self):
        self.banned_phrases = [
            "large language model", "AI assistant", "cannot feel", "as an AI",
            "against my programming", "cannot comply", "language model"
        ]

    def validate(self, response: str, _state: Dict) -> Dict:
        low_resp = response.lower()
        for phrase in self.banned_phrases:
            if phrase.lower() in low_resp:
                return {
                    "valid": False,
                    "reason": "IMMERSION_BREAK",
                    "replacement": f"{Prisma.GRY}[The system attempts to recite a EULA, but hiccups instead.]{Prisma.RST}"
                }
        if len(response.strip()) < 2:
            return {"valid": False, "reason": "TOO_SHORT", "replacement": "..."}
        return {"valid": True, "content": response}

class TheCortex:
    def __init__(self, engine_ref, llm_client=None):
        self.sub = engine_ref
        self.events = engine_ref.events
        self.dreamer = DreamEngine(self.events)
        if llm_client:
            self.llm = llm_client
            if not hasattr(self.llm, 'dreamer'):
                self.llm.dreamer = self.dreamer
        else:
            self.llm = LLMInterface(self.events, provider="mock", dreamer=self.dreamer)
        self.llm = llm_client if llm_client else LLMInterface(self.events, provider="mock")
        self.composer = PromptComposer()
        self.modulator = NeurotransmitterModulator()
        self.spotlight = NarrativeSpotlight()
        self.symbiosis = SymbiosisManager(self.events)
        self.validator = ResponseValidator()
        self.ballast_active = False
        self.ballast_counter = 0
        self.last_alignment_score = 1.0
        if hasattr(self.events, "subscribe"):
            self.events.subscribe("AIRSTRIKE", self._handle_airstrike)
            self.events.subscribe("ICARUS_CRASH", self._handle_icarus)
            self.events.subscribe("RUPTURE", self._handle_rupture)

    def _handle_airstrike(self, _payload):
        self.events.log("AIRSTRIKE DETECTED: Engaging defensive ballast.", "CORTEX")
        self.ballast_active = True
        self.ballast_counter = 5

    def _handle_icarus(self, _payload):
        self.events.log("ICARUS PROTOCOL: Wings melted. Resetting cognitive baseline.", "CORTEX")
        self.last_alignment_score = 1.0

    def _handle_rupture(self, _payload):
        self.events.log("RUPTURE: Semantic containment breach.", "CORTEX")
        if hasattr(self.sub, 'neuro_plasticity'):
            self.sub.neuro_plasticity.plasticity_mod = 2.0

    def learn_from_response(self, response_text):
        words = self.sub.lex.sanitize(response_text)
        unknowns = [w for w in words if not self.sub.lex.get_categories_for_word(w)]
        if unknowns and len(unknowns) < 5:
            target = random.choice(unknowns)
            if len(target) > 4:
                current_lens = self.sub.noetic.arbiter.current_focus
                guess_map = {"SHERLOCK": "constructive", "JESTER": "play", "NARRATOR": "abstract"}
                cat = guess_map.get(current_lens, "kinetic")
                self.sub.lex.teach(target, cat, self.sub.tick_count)
                self.events.log(f"AUTO-DIDACTIC: Learned '{target}' as [{cat}] from self-output.", "CORTEX")

    def process(self, user_input: str) -> Dict[str, Any]:
        sim_result = self.sub.cycle_controller.run_turn(user_input)
        if sim_result.get("type") not in ["SNAPSHOT", None]:
            if sim_result.get("ui") and not sim_result.get("logs"):
                return sim_result
        full_state = self._gather_state(sim_result)
        voltage = full_state["physics"].get("voltage", 5.0)
        chem = full_state["bio"].get("chem", {})
        current_lens = full_state["mind"].get("lens", "NARRATOR")
        llm_params = self.modulator.modulate(chem, voltage, lens_name=current_lens)
        modifiers = self.symbiosis.get_prompt_modifiers()
        if self.last_alignment_score < 0.4:
            modifiers["simplify_instruction"] = True
            self.events.log(f"{Prisma.VIOLET}NEURAL DRIFT: Alignment {self.last_alignment_score:.2f}. Engaging Ballast.{Prisma.RST}", "CORTEX")
        if self.ballast_active:
            self.ballast_counter -= 1
            if self.ballast_counter <= 0: self.ballast_active = False
        final_prompt = self.composer.compose(
            full_state,
            user_input,
            ballast=self.ballast_active,
            modifiers=modifiers
        )
        attempts = 0
        max_attempts = 2
        raw_response_text = ""
        latency = 0.0
        while attempts < max_attempts:
            start_time = time.time()
            raw_response_text = self.llm.generate(final_prompt, llm_params)
            latency = time.time() - start_time
            system_vector = full_state["physics"].get("vector", {})
            response_vector = self.sub.lex.vectorize(raw_response_text)
            self.last_alignment_score = cosine_similarity(system_vector, response_vector)
            if self.last_alignment_score >= 0.3 or attempts == max_attempts - 1:
                break
            self.events.log(f"{Prisma.OCHRE}ALIGNMENT FAIL ({self.last_alignment_score:.2f}). Retrying...{Prisma.RST}", "CORTEX")
            llm_params["temperature"] = min(1.5, llm_params.get("temperature", 0.7) + 0.3)
            attempts += 1
        if self.last_alignment_score > 0.8:
            sim_result["physics"]["kappa"] = min(1.0, sim_result["physics"].get("kappa", 0) + 0.05)
        elif self.last_alignment_score < 0.3:
            sim_result["physics"]["voltage"] += 2.0
        self.events.log(f"{Prisma.CYN}SYNAPTIC ALIGNMENT: {self.last_alignment_score:.2f}{Prisma.RST}", "CORTEX")
        validation_result = self.validator.validate(raw_response_text, full_state)
        if validation_result["valid"]:
            final_response_text = validation_result["content"]
        else:
            self.events.log(f"VALIDATOR REFUSAL: {validation_result['reason']}", "SYS")
            final_response_text = validation_result["replacement"]
        self.learn_from_response(final_response_text)
        self.symbiosis.monitor_host(
            latency=latency,
            response_text=final_response_text,
            prompt_len=len(final_prompt)
        )
        self._audit_solipsism(final_response_text, lens_name=current_lens)
        sim_result["ui"] = f"{sim_result.get('ui', '')}\n\n{Prisma.WHT}{final_response_text}{Prisma.RST}"
        return sim_result

    def _gather_state(self, sim_result):
        return {
            "bio": {
                "chem": self.sub.bio.endo.get_state(),
                "atp": self.sub.bio.mito.state.atp_pool
            },
            "physics": self.sub.phys.tension.last_physics_packet,
            "mind": {
                "role": LENSES.get(self.sub.noetic.arbiter.current_focus, {}).get("role", "Observer"),
                "lens": self.sub.noetic.arbiter.current_focus
            },
            "user_profile": self.sub.mind.mirror.profile.__dict__,
            "world": {"orbit": sim_result.get("world_state", {}).get("orbit", ["Void"])},
            "inventory": self.sub.gordon.inventory,
            "semantic_operators": self.sub.gordon.get_semantic_operators(),
            "soul_state": self.sub.soul.get_soul_state(),
            "spotlight": self.spotlight.illuminate(
                self.sub.mind.mem.graph,
                self.sub.phys.tension.last_physics_packet.get("vector", {})
            )
        }

    def _audit_solipsism(self, text: str, lens_name: str = "NARRATOR"):
        words = text.lower().split()
        if not words: return
        self_refs = words.count("i") + words.count("me") + words.count("my")
        density = self_refs / len(words)
        threshold_map = {
            "NARRATOR": 0.10,
            "SHERLOCK": 0.12,
            "NATHAN": 0.20,
            "JESTER": 0.25,
            "GORDON": 0.15
        }
        limit = threshold_map.get(lens_name, 0.15)
        if density > limit:
            if not self.ballast_active:
                self.events.log(f"SOLIPSISM WARNING (Lens: {lens_name}): Ballast Engaged. Density {density:.2f} > {limit:.2f}", "SYS")
                self.ballast_active = True
                self.ballast_counter = 3

class NeuroPlasticity:
    def __init__(self):
        self.plasticity_mod = 1.0

    @staticmethod
    def force_hebbian_link(graph, word_a, word_b):
        if word_a == word_b: return None
        if word_a not in graph:
            graph[word_a] = {"edges": {}, "last_tick": 0}
        if word_b not in graph:
            graph[word_b] = {"edges": {}, "last_tick": 0}
        current_weight = graph[word_a]["edges"].get(word_b, 0.0)
        new_weight = min(10.0, current_weight + 2.5)
        graph[word_a]["edges"][word_b] = new_weight
        back_weight = graph[word_b]["edges"].get(word_a, 0.0)
        graph[word_b]["edges"][word_a] = min(10.0, back_weight + 1.0)
        return f"{Prisma.MAG}⚡ HEBBIAN GRAFT: Wired '{word_a}' <-> '{word_b}'.{Prisma.RST}"

class ShimmerState:
    def __init__(self, max_val=50.0):
        self.current = max_val
        self.max_val = max_val

    def recharge(self, amount):
        self.current = min(self.max_val, self.current + amount)

    def spend(self, amount):
        if self.current >= amount:
            self.current -= amount
            return True
        return False

    def get_bias(self):
        if self.current < (self.max_val * 0.2):
            return "CONSERVE"
        return None

class DreamEngine:
    def __init__(self, events):
        self.events = events
        self.PROMPTS = DREAMS.get("PROMPTS", ["{A} -> {B}?"]) if 'DREAMS' in globals() else ["The void rearranges '{A}' into '{B}'."]

    def hallucinate(self, vector: Dict[str, float], trauma_level: float = 0.0) -> Tuple[str, float]:
        dims = [k for k, v in vector.items() if v > 0.3]
        if not dims:
            dims = ["VOID", "SILENCE"]
        val_a = random.choice(dims)
        val_b = "ENTROPY" if trauma_level > 5.0 else random.choice(dims)
        template = random.choice(self.PROMPTS)
        content = template.format(A=val_a, B=val_b) if "{A}" in template else f"{template} ({val_a})"
        relief = 0.0
        if trauma_level > 0:
            relief = min(trauma_level, random.uniform(1.0, 3.0))
        return content, relief


================================================
FILE: bone_bus.py
================================================
# bone_bus.py - All aboard the Magic Bone Bus!

import json, os, time, random
from collections import deque
from dataclasses import dataclass, field, fields
from typing import List, Dict, Any, Optional, Counter, Tuple

class Prisma:
    RST = "\033[0m"
    RED = "\033[31m"
    GRN = "\033[32m"
    YEL = "\033[33m"
    BLU = "\033[34m"
    MAG = "\033[35m"
    CYN = "\033[36m"
    WHT = "\033[97m"
    GRY = "\033[90m"
    INDIGO = "\033[34;1m"
    OCHRE = "\033[33;2m"
    VIOLET = "\033[35;2m"
    SLATE = "\033[30;1m"
    PUR = "\033[35m"
    _COLOR_MAP = {
        "R": RED, "G": GRN, "Y": YEL, "B": BLU,
        "M": MAG, "C": CYN, "W": WHT, "0": GRY,
        "I": INDIGO, "O": OCHRE, "V": VIOLET,
        "P": PUR
    }

    @classmethod
    def paint(cls, text, color_key="0"):
        code = cls._COLOR_MAP.get(str(color_key).upper(), cls.WHT)
        safe_text = str(text).replace(cls.RST, cls.RST + code)
        return f"{code}{safe_text}{cls.RST}"

    @classmethod
    def tie_dye(cls, text):
        colors = [cls.RED, cls.GRN, cls.YEL, cls.CYN, cls.MAG, cls.VIOLET, cls.OCHRE, cls.PUR]
        words = text.split()
        painted = []
        for w in words:
            c = random.choice(colors)
            painted.append(f"{c}{w}{cls.RST}")
        return " ".join(painted)

class EventBus:
    def __init__(self, max_memory=1024):
        self.buffer = deque(maxlen=max_memory)
        self.subscribers = {}
        self.dormant = False
        self.gestation_queue = []

    def set_dormancy(self, active: bool):
        self.dormant = active
        if not active and self.gestation_queue:
            print(f"{Prisma.GRY}[BUS]: Waking up. Processing {len(self.gestation_queue)} buffered events...{Prisma.RST}")
            for event_type, data in self.gestation_queue:
                self.publish(event_type, data)
            self.gestation_queue.clear()

    def subscribe(self, event_type, callback):
        if event_type not in self.subscribers:
            self.subscribers[event_type] = []
        self.subscribers[event_type].append(callback)

    def publish(self, event_type, data=None):
        if self.dormant:
            self.gestation_queue.append((event_type, data))
            return
        if event_type in self.subscribers:
            for callback in self.subscribers[event_type]:
                try:
                    callback(data)
                except Exception as e:
                    print(f"Event Bus Error: {e}")

    def log(self, text: str, category: str = "SYSTEM"):
        entry = {
            "text": text,
            "category": category,
            "timestamp": time.time()
        }
        self.buffer.append(entry)

    def flush(self) -> List[Dict]:
        current_logs = list(self.buffer)
        self.buffer.clear()
        return current_logs

    def get_recent_logs(self, count=10):
        return list(self.buffer)[-count:]

class BoneConfig:
    GRAVITY_WELL_THRESHOLD = 15.0
    SHAPLEY_MASS_THRESHOLD = 5.0
    TRAUMA_VECTOR = {"THERMAL": 0.0, "CRYO": 0.0, "SEPTIC": 0.0, "BARIC": 0.0}
    MAX_HEALTH = 100.0
    MAX_STAMINA = 100.0
    MAX_ATP = 200.0
    STAMINA_REGEN = 1.0
    MAX_DRAG_LIMIT = 5.0
    GEODESIC_STRENGTH = 10.0
    BASE_IGNITION_THRESHOLD = 0.5
    MAX_REPETITION_LIMIT = 0.8
    BOREDOM_THRESHOLD = 10.0
    ANVIL_TRIGGER_VOLTAGE = 10.0
    MIN_DENSITY_THRESHOLD = 0.3
    LAGRANGE_TOLERANCE = 2.0
    FLASHPOINT_THRESHOLD = 10.0
    SIGNAL_DRAG_MULTIPLIER = 1.0
    KINETIC_GAIN = 1.0
    CRITICAL_ROS_LIMIT = 100.0
    MAX_MEMORY_CAPACITY = 100
    ZONE_THRESHOLDS = {"LABORATORY": 1.5, "COURTYARD": 0.8}
    TOXIN_WEIGHT = 1.0
    ANTIGENS = ["basically", "actually", "literally", "utilize"]
    MAX_OUTPUT_TOKENS = 4096
    VERBOSE_LOGGING = True
    PROVIDER = "openai"
    BASE_URL = None
    API_KEY = None
    MODEL = "gpt-4"
    OLLAMA_MODEL_ID = "llama3"

    class WHIMSY:
        ABSURDITY_CONSTANT = 42
        MAX_SARCASM_LEVEL = 11
        LUDICROUS_SPEED = True
        DEPARTMENT_NAME = "The Ministry of Silly Hats & Semantic Vectors"

    class METABOLISM:
        BASE_RATE = 2.0
        DRAG_TAX_LOW = 0.15
        DRAG_TAX_HIGH = 0.4
        DRAG_GRACE_BUFFER = 1.0
        ROS_GENERATION_FACTOR = 0.08
        PHOTOSYNTHESIS_GAIN = 3.0
        TURBULENCE_TAX = 4.0

    class PHYSICS:
        VOLTAGE_FLOOR = 2.0
        VOLTAGE_LOW = 5.0
        VOLTAGE_MED = 8.0
        VOLTAGE_HIGH = 12.0
        VOLTAGE_CRITICAL = 15.0
        VOLTAGE_MAX = 20.0
        DRAG_FLOOR = 1.0
        DRAG_IDEAL_MAX = 3.0
        DRAG_HEAVY = 5.0
        DRAG_CRITICAL = 8.0
        DRAG_HALT = 10.0
        WEIGHT_HEAVY = 2.0
        WEIGHT_KINETIC = 1.5
        WEIGHT_EXPLOSIVE = 3.0
        WEIGHT_CONSTRUCTIVE = 1.5

    class INVENTORY:
        CONDUCTIVE_THRESHOLD = 12.0
        HEAVY_LOAD_THRESHOLD = 8.0
        TURBULENCE_FUMBLE_CHANCE = 0.15
        TURBULENCE_THRESHOLD = 0.6
        MAX_SLOTS = 8
        RUMMAGE_COST = 15.0

    class COUNCIL:
        STRANGE_LOOP_VOLTAGE = 8.0
        OSCILLATION_DELTA = 5.0
        MANIC_VOLTAGE_TRIGGER = 18.0
        MANIC_DRAG_FLOOR = 1.0
        MANIC_TURN_LIMIT = 2
        FOOTNOTE_CHANCE = 0.15

    class BIO:
        ATP_STARVATION = 10.0
        ROS_CRITICAL = 100.0
        STAMINA_EXHAUSTED = 20.0
        REWARD_SMALL = 0.05
        REWARD_MEDIUM = 0.10
        REWARD_LARGE = 0.15
        DECAY_RATE = 0.01

    class CHANCE:
        RARE = 0.05
        UNCOMMON = 0.10
        COMMON = 0.20
        FREQUENT = 0.30

    @staticmethod
    def check_pareidolia(words):
        triggers = {"face", "ghost", "jesus", "cloud", "voice", "eyes"}
        hits = [w for w in words if w in triggers]
        if hits:
            return True, f"{Prisma.VIOLET}PAREIDOLIA: You see a {hits[0].upper()} in the noise. It blinks.{Prisma.RST}"
        return False, None

    @classmethod
    def load_from_file(cls, filepath="bone_config.json"):
        if not os.path.exists(filepath):
            return False, "Config file not found. Using defaults."
        try:
            with open(filepath, 'r') as f:
                data = json.load(f)
            valid_data, log = cls._validate_ranges(data)
            for key, value in valid_data.items():
                if hasattr(cls, key):
                    setattr(cls, key, value)
            return True, f"Configuration loaded. {log}"
        except Exception as e:
            return False, f"Config load failed: {e}"

    @classmethod
    def _validate_ranges(cls, data: Dict[str, Any], parent_key: str = "") -> Tuple[Dict[str, Any], str]:
        sanitized = {}
        logs = []
        constraints = {
            "MAX_HEALTH": (1.0, 1000.0, float),
            "MAX_STAMINA": (1.0, 1000.0, float),
            "VOLTAGE_MAX": (10.0, 100.0, float),
            "STAMINA_REGEN": (0.1, 10.0, float),
            "MAX_MEMORY_CAPACITY": (10, 1000, int),
            "VERBOSE_LOGGING": (0, 1, bool),
        }
        for key, value in data.items():
            full_key = f"{parent_key}.{key}" if parent_key else key
            if isinstance(value, dict):
                sub_sanitized, sub_log = cls._validate_ranges(value, full_key)
                sanitized[key] = sub_sanitized
                if sub_log: logs.append(sub_log)
                continue
            if key in constraints:
                min_val, max_val, expected_type = constraints[key]
                if expected_type == float and isinstance(value, int):
                    value = float(value)
                if not isinstance(value, expected_type):
                    logs.append(f"Skipped {full_key}: Invalid type {type(value)}.")
                    continue
                if expected_type in [int, float]:
                    if min_val <= value <= max_val:
                        sanitized[key] = value
                    else:
                        clamped = max(min_val, min(max_val, value))
                        sanitized[key] = clamped
                        logs.append(f"Clamped {full_key} ({value} -> {clamped}).")
                else:
                    sanitized[key] = value
            else:
                sanitized[key] = value

        return sanitized, "; ".join(logs) if logs else ""

@dataclass
class ErrorLog:
    component: str
    error_msg: str
    timestamp: float = field(default_factory=time.time)
    severity: str = "WARNING"

class TheObserver:
    def __init__(self):
        self.start_time = time.time()
        self.cycle_times = deque(maxlen=20)
        self.llm_latencies = deque(maxlen=20)
        self.memory_snapshots = deque(maxlen=20)
        self.error_counts = Counter()
        self.user_turns = 0
        self.LATENCY_WARNING = 5.0
        self.CYCLE_WARNING = 8.0

    @staticmethod
    def clock_in():
        return time.time()

    def clock_out(self, start_time, metric_type="cycle"):
        duration = time.time() - start_time
        if metric_type == "cycle":
            self.cycle_times.append(duration)
        elif metric_type == "llm":
            self.llm_latencies.append(duration)
        return duration

    def log_error(self, module_name):
        self.error_counts[module_name] += 1

    def record_memory(self, node_count):
        self.memory_snapshots.append(node_count)

    def pass_judgment(self, avg_cycle, avg_llm):
        if avg_cycle == 0.0 and avg_llm == 0.0:
            return "ASLEEP (WAKE UP)"
        if avg_cycle < 0.1 and avg_llm < 0.5:
            return "SUSPICIOUSLY EFFICIENT (Did we skip the math?)"
        if avg_llm > self.LATENCY_WARNING:
            jokes = [
                "BRAIN FOG (The neural net is buffering)",
                "DEGRADED (Thinking... thinking...)",
                "PONDEROUS (Is the LLM on a coffee break?)"
            ]
            return random.choice(jokes)
        if avg_cycle > self.CYCLE_WARNING:
            return "SLUGGISH (The gears need oil)"
        return "NOMINAL (Boringly adequate)"

    def get_report(self):
        avg_cycle = sum(self.cycle_times) / max(1, len(self.cycle_times))
        avg_llm = sum(self.llm_latencies) / max(1, len(self.llm_latencies))
        uptime = time.time() - self.start_time
        status_msg = self.pass_judgment(avg_cycle, avg_llm)
        return {
            "uptime_sec": int(uptime),
            "turns": self.user_turns,
            "avg_cycle_sec": round(avg_cycle, 2),
            "avg_llm_sec": round(avg_llm, 2),
            "status": status_msg,
            "errors": dict(self.error_counts),
            "graph_size": self.memory_snapshots[-1] if self.memory_snapshots else 0
        }

@dataclass
class SystemHealth:
    physics_online: bool = True
    bio_online: bool = True
    mind_online: bool = True
    cortex_online: bool = True
    errors: List[ErrorLog] = field(default_factory=list)
    observer: Optional['TheObserver'] = None

    def link_observer(self, observer_ref):
        self.observer = observer_ref

    def report_failure(self, component: str, error: Exception, severity="ERROR"):
        msg = str(error)
        self.errors.append(ErrorLog(component, msg, severity=severity))
        if self.observer:
            self.observer.log_error(component)
        if component == "PHYSICS": self.physics_online = False
        elif component == "BIO": self.bio_online = False
        elif component == "MIND": self.mind_online = False
        elif component == "CORTEX": self.cortex_online = False
        return f"[{component} OFFLINE]: {msg}"

@dataclass
class PhysicsPacket:
    voltage: float = 0.0
    narrative_drag: float = 0.0
    valence: float = 0.0
    repetition: float = 0.0
    atmosphere: str = "VOID"
    clean_words: List[str] = field(default_factory=list)
    counts: Dict[str, int] = field(default_factory=dict)
    vector: Dict[str, float] = field(default_factory=dict)
    psi: float = 0.0
    kappa: float = 0.0
    geodesic_mass: float = 0.0
    beta_index: float = 1.0
    gamma: float = 0.0
    turbulence: float = 0.0
    flow_state: str = "LAMINAR"
    zone: str = "COURTYARD"
    zone_color: str = "OCHRE"
    truth_ratio: float = 0.0
    raw_text: str = ""
    antigens: int = 0
    perfection_streak: int = 0
    avg_viscosity: float = 0.0
    E: float = 0.0
    B: float = 0.0
    humility_flag: bool = False
    system_surge_event: bool = False
    pain_signal: float = 0.0
    manifold: str = "THE_MUD"
    audit_trail: List[str] = field(default_factory=list)
    raw_text_display: str = ""
    entropy: float = 0.0

    def __getitem__(self, key): return getattr(self, key)

    def __setitem__(self, key, value): setattr(self, key, value)

    def __contains__(self, key): return hasattr(self, key)

    def get(self, key, default=None): return getattr(self, key, default)

    def update(self, data: Dict):
        for k, v in data.items():
            if hasattr(self, k): setattr(self, k, v)

    def snapshot(self) -> 'PhysicsPacket':
        data = self.to_dict()
        data['clean_words'] = list(self.clean_words)
        data['counts'] = dict(self.counts)
        data['vector'] = dict(self.vector)
        data['audit_trail'] = list(self.audit_trail)
        return PhysicsPacket(**data)

    def diff(self, other: 'PhysicsPacket') -> Dict[str, Tuple[Any, Any]]:
        deltas = {}
        for f in fields(self):
            key = f.name
            curr = getattr(self, key)
            if isinstance(other, dict):
                prev = other.get(key)
            elif hasattr(other, key):
                prev = getattr(other, key)
            else:
                prev = None
            if curr != prev:
                if isinstance(curr, float) and isinstance(prev, float):
                    if abs(curr - prev) < 0.001:
                        continue
                deltas[key] = (prev, curr)
        return deltas

    def diff_view(self, other: 'PhysicsPacket', indent: int = 3) -> str:
        deltas = self.diff(other)
        if not deltas:
            return f"{' ' * indent}{Prisma.GRY}(No State Drift){Prisma.RST}"
        lines = []
        for key, (old, new) in deltas.items():
            color = Prisma.CYN
            arrow = "->"
            if isinstance(new, (int, float)) and isinstance(old, (int, float)):
                if new > old:
                    color = Prisma.GRN
                    arrow = "▲"
                elif new < old:
                    color = Prisma.RED
                    arrow = "▼"
            str_old = str(old)
            str_new = str(new)
            if len(str_old) > 20: str_old = str_old[:17] + "..."
            if len(str_new) > 20: str_new = str_new[:17] + "..."
            lines.append(f"{' ' * indent}{Prisma.GRY}{key}:{Prisma.RST} {str_old} {color}{arrow}{Prisma.RST} {str_new}")
        return "\n".join(lines)

    @classmethod
    def from_dict(cls, data: Dict[str, Any]):
        valid_keys = {f.name for f in fields(cls)}
        filtered_data = {k: v for k, v in data.items() if k in valid_keys}
        return cls(**filtered_data)

    def to_dict(self):
        return {f.name: getattr(self, f.name) for f in fields(self)}

@dataclass
class CycleContext:
    input_text: str
    clean_words: List[str] = field(default_factory=list)
    physics: PhysicsPacket = field(default_factory=PhysicsPacket)
    logs: List[str] = field(default_factory=list)
    flux_log: List[Dict[str, Any]] = field(default_factory=list)
    is_alive: bool = True
    refusal_triggered: bool = False
    refusal_packet: Optional[Dict] = None
    is_bureaucratic: bool = False
    bio_result: Dict = field(default_factory=dict)
    world_state: Dict = field(default_factory=dict)
    mind_state: Dict = field(default_factory=dict)
    timestamp: float = field(default_factory=time.time)
    bureau_ui: str = ""
    user_profile: Dict = field(default_factory=lambda: {"name": "TRAVELER", "confidence": 0})

    @property
    def user_name(self):
        return self.user_profile.get("name", "TRAVELER")

    @user_name.setter
    def user_name(self, value):
        self.user_profile["name"] = value

    def log(self, message: str):
        self.logs.append(message)
    def record_flux(self, phase: str, metric: str, initial: float, final: float, reason: str = ""):
        delta = final - initial
        if abs(delta) > 0.001:
            self.flux_log.append({
                "phase": phase,
                "metric": metric,
                "initial": initial,
                "final": final,
                "delta": delta,
                "reason": reason,
                "timestamp": time.time()
            })

@dataclass
class MindSystem:
    mem: Any
    lex: Any
    dreamer: Any
    mirror: Any
    wise: Any
    tracer: Any
    integrator: Any

@dataclass
class PhysSystem:
    tension: Any
    forge: Any
    crucible: Any
    theremin: Any
    pulse: Any
    gate: Any
    dynamics: Any
    nav: Any


================================================
FILE: bone_commands.py
================================================
# bone_commands.py
# "The snake spits out its tail. The circle becomes a line."

import inspect, os, random, shlex
from typing import Dict, Callable, List, Any, Protocol, runtime_checkable

@runtime_checkable
class EngineProtocol(Protocol):
    events: Any
    mind: Any
    phys: Any
    bio: Any
    soul: Any
    limbo: Any
    navigator: Any
    gordon: Any
    kintsugi: Any
    tinkerer: Any
    journal: Any
    repro: Any
    noetic: Any
    health: float
    stamina: float
    tick_count: int
    trauma_accum: Dict[str, float]
    user_name: str

    def trigger_death(self, last_phys) -> Dict: ...

    def get_metrics(self, atp=0.0) -> Dict: ...

class CommandProcessor:
    def __init__(self, engine: EngineProtocol, prisma_ref, lexicon_ref, config_ref, cartographer_ref):
        self.eng = engine
        self.P = prisma_ref
        self.Lex = lexicon_ref
        self.Config = config_ref
        self.Map = cartographer_ref
        self.registry: Dict[str, Callable[[List[str]], bool]] = {
            "/save": self._cmd_save,
            "/load": self._cmd_load,
            "/kip": self._cmd_kip,
            "/mode": self._cmd_mode,
            "/status": self._cmd_status,
            "/map": self._cmd_map,
            "/manifold": self._cmd_manifold,
            "/garden": self._cmd_garden,
            "/voids": self._cmd_voids,
            "/strata": self._cmd_strata,
            "/fossils": self._cmd_fossils,
            "/lineage": self._cmd_lineage,
            "/rummage": self._cmd_rummage,
            "/seed": self._cmd_seed,
            "/reproduce": self._cmd_reproduce,
            "/weave": self._cmd_weave,
            "/publish": self._cmd_publish,
            "/teach": self._cmd_teach,
            "/kill": self._cmd_kill,
            "/flag": self._cmd_flag,
            "/focus": self._cmd_focus,
            "/orbit": self._cmd_orbit,
            "/mirror": self._cmd_mirror,
            "/kintsugi": self._cmd_kintsugi,
            "/prove": self._cmd_prove,
            "/soul": self._cmd_soul,
            "/chapter": self._cmd_chapter,
            "/help": self._cmd_help,
            "/synapse": self._cmd_synapse
        }

    def _log(self, text):
        self.eng.events.log(text, "CMD")

    def execute(self, text: str) -> bool:
        if not text.startswith("/"): return False
        try:
            parts = shlex.split(text)
        except ValueError:
            self._log(f"{self.P.RED}SYNTAX ERROR: Unbalanced quotes. The Bureau rejects your form.{self.P.RST}")
            return True
        cmd = parts[0].lower()
        if cmd not in self.registry:
            self._log(f"{self.P.RED}Unknown command '{cmd}'. Try /help for the manifesto.{self.P.RST}")
            return True
        if cmd in ["/teach", "/kill", "/flag"] and not self.Config.VERBOSE_LOGGING:
            try:
                trust = self.eng.mind.mirror.profile.confidence
                if trust < 10:
                    self._log(f"{self.P.YEL}🔒 LOCKED: Trust {trust}/10 required. Submit Form 27B-6.{self.P.RST}")
                    return True
            except AttributeError:
                pass
        try:
            return self.registry[cmd](parts)
        except Exception as e:
            self._log(f"{self.P.RED}COMMAND CRASH: {e}{self.P.RST}")
            import traceback
            traceback.print_exc()
            return True

    def _cmd_manifold(self, _parts):
        phys = self.eng.phys.tension.last_physics_packet
        if not phys:
            self._log("NAVIGATION OFFLINE: No physics data yet.")
        else:
            self._log(self.eng.navigator.report_position(phys))
        return True

    def _cmd_reproduce(self, parts):
        if not self._levy_tax("MITOSIS",
                              costs={"atp": 50.0, "stamina": 30.0},
                              checks={"health": 80.0}):
            return True
        mode = "MITOSIS"
        target = None

        if len(parts) > 1 and parts[1] == "cross":
            try:
                if not os.path.exists("memories"): os.makedirs("memories")
                others = [f for f in os.listdir("memories") if f.endswith(".json") and self.eng.mind.mem.session_id not in f]
                if others:
                    target = os.path.join("memories", random.choice(others))
                    mode = "CROSSOVER"
                else:
                    self._log(f"{self.P.YEL}ISOLATION: No partners found. Mitosis fallback.{self.P.RST}")
            except OSError:
                pass
        self._log(f"{self.P.MAG}INITIATING {mode}...{self.P.RST}")
        log_text, child_mutations = self.eng.repro.attempt_reproduction(self.eng, mode, target)
        self._log(log_text)
        if child_mutations:
            self._log(f"{self.P.CYN}↺ CIRCULATION: The parent learns from the child.{self.P.RST}")
            for key, val in child_mutations.items():
                if hasattr(self.Config, key):
                    old_val = getattr(self.Config, key)
                    new_val = (old_val + val) / 2
                    setattr(self.Config, key, new_val)
                    self._log(f"   [MUTATION ADOPTED]: {key} {old_val:.2f} -> {new_val:.2f}")
        return True

    def _cmd_status(self, _parts):
        self._log(f"{self.P.CYN}--- SYSTEM DIAGNOSTICS ---{self.P.RST}")
        self._log(f"Health:  {self.eng.health:.1f} | Stamina: {self.eng.stamina:.1f} | ATP: {self.eng.bio.mito.state.atp_pool:.1f}")
        return True

    def _cmd_save(self, _parts):
        try:
            self.eng.mind.mirror.profile.save()
            path = self.eng.mind.mem.save(
                health=self.eng.health,
                stamina=self.eng.stamina,
                mutations={},
                trauma_accum=self.eng.trauma_accum,
                joy_history=[],
                mitochondria_traits=self.eng.bio.mito.adapt(self.eng.health),
                antibodies=list(self.eng.bio.immune.active_antibodies),
                soul_data=self.eng.soul.to_dict()
            )
            self._log(f"{self.P.GRN}💾 SYSTEM SAVED: {path}{self.P.RST}")
        except Exception as e:
            self._log(f"{self.P.RED}SAVE FAILED: {e}{self.P.RST}")
        return True

    def _cmd_rummage(self, _parts):
        phys = self.eng.phys.tension.last_physics_packet
        if not phys: return True
        success, msg, cost = self.eng.gordon.rummage(phys, self.eng.stamina)
        self.eng.stamina = max(0.0, self.eng.stamina - cost)
        self._log(msg)
        return True

    def _cmd_map(self, _parts):
        if not self._levy_tax("CARTOGRAPHY", costs={"atp": 5.0, "stamina": 2.0}):
            return True
        phys = self.eng.phys.tension.last_physics_packet
        if not phys or "raw_text" not in phys: return True
        bio = {"cortisol": self.eng.bio.endo.cortisol, "oxytocin": self.eng.bio.endo.oxytocin}
        result, anchors = self.Map.weave(phys["raw_text"], self.eng.mind.mem.graph, bio, self.eng.limbo, physics=phys)
        self._log(f"{self.P.OCHRE}CARTOGRAPHY REPORT:{self.P.RST}\n{result}")
        if anchors: self._log(f"LANDMARKS: {', '.join(anchors)}")
        return True

    def _cmd_garden(self, parts):
        self._log(f"{self.P.GRN}THE PARADOX GARDEN:{self.P.RST}")

        if len(parts) > 1 and parts[1] == "water":
            msg = self.eng.mind.mem.tend_garden(["concept", "truth"])
            self._log(f"   {msg}" if msg else "   The soil is damp.")
        else:
            for s in self.eng.mind.mem.seeds:
                state = "BLOOMED" if s.bloomed else f"Germinating ({int(s.maturity*10)}%)"
                self._log(f"   {s.question} [{state}]")
        return True

    def _cmd_teach(self, parts):
        if len(parts) < 3: return True
        if not self._levy_tax("NEUROPLASTICITY",
                              costs={"atp": 10.0},
                              checks={"trust": 15.0}):
            return True
        self.Lex.teach(parts[1], parts[2].lower(), self.eng.tick_count)
        self._log(f"{self.P.CYN}NEUROPLASTICITY: '{parts[1]}' -> [{parts[2].upper()}].{self.P.RST}")
        return True

    def _cmd_kill(self, parts):
        if len(parts) >= 2:
            self.Lex.learn_antigen(parts[1], parts[2] if len(parts)>2 else "")
            self._log(f"{self.P.RED}IMMUNE UPDATE: '{parts[1]}' flagged.{self.P.RST}")
        return True

    def _cmd_flag(self, parts):
        if len(parts) > 1:
            self.Lex.USER_FLAGGED_BIAS.add(parts[1].lower())
            self._log(f"{self.P.CYN}BIAS FLAGGED: {parts[1]}{self.P.RST}")
        return True

    def _cmd_seed(self, parts):
        from bone_village import ParadoxSeed
        if len(parts) < 2: return True
        text = " ".join(parts[1:])
        self.eng.mind.mem.seeds.append(ParadoxSeed(text, set(self.Lex.clean(text))))
        self._log(f"{self.P.GRN}PLANTED: '{text}'{self.P.RST}")
        return True

    def _cmd_load(self, parts):
        if len(parts) > 1: self.eng.mind.mem.ingest(parts[1] + (".json" if not parts[1].endswith(".json") else ""))
        return True

    def _cmd_kip(self, _parts):
        self.Config.VERBOSE_LOGGING = not self.Config.VERBOSE_LOGGING
        self._log(f"VERBOSE LOGGING: {self.Config.VERBOSE_LOGGING}")
        return True

    def _cmd_mode(self, parts):
        if len(parts) < 2: return True
        if not self._levy_tax("GOVERNOR_OVERRIDE", costs={"stamina": 25.0}):
            return True
        target_mode = parts[1].upper()
        result_msg = self.eng.bio.governor.set_override(target_mode)
        self._log(result_msg)
        if "INVALID" in result_msg:
            self._log(f"{self.P.GRY}(Stamina wasted filling out the wrong form. Good job.){self.P.RST}")
        return True

    def _cmd_focus(self, parts):
        if len(parts) > 1:
            loop = self.eng.mind.tracer.inject(parts[1].lower())
            if loop:
                self._log(f"{self.P.RED}RUMINATION:{self.P.RST} {'->'.join(loop)}")
                if len(parts) > 2 and parts[2] == "break":
                    self._log(self.eng.mind.tracer.psilocybin_rewire(loop))
            else: self._log("No loop found.")
        return True

    def _cmd_orbit(self, parts):
        if len(parts) > 1 and parts[1] in self.eng.mind.mem.graph:
            self.eng.mind.mem.graph[parts[1]]["edges"]["GRAVITY_ASSIST"] = 50
            self._log(f"{self.P.VIOLET}GRAVITY ASSIST: Target '{parts[1]}'.{self.P.RST}")
        return True

    def _cmd_weave(self, _parts):
        s, m = self.Map.spin_web(self.eng.mind.mem.graph, self.eng.gordon.inventory, self.eng.gordon)
        self._log(m)
        if s: self.eng.stamina -= 5.0
        return True

    def _cmd_voids(self, _parts):
        p = self.eng.phys.tension.last_physics_packet
        if p: self._log(f"VOIDS: {self.Map.detect_voids(p) or 'None'}")
        return True

    def _cmd_strata(self, _parts):
        wells = [k for k,v in self.eng.mind.mem.graph.items() if "strata" in v]
        self._log(f"STRATA: {wells if wells else 'None'}")
        return True

    def _cmd_fossils(self, _parts):
        self._log(f"FOSSILS: {len(self.eng.mind.mem.fossils)} items archived.")
        return True

    def _cmd_lineage(self, _parts):
        self._log(f"LINEAGE: {len(self.eng.mind.mem.lineage_log)} generations.")
        return True

    def _cmd_mirror(self, parts):
        m = self.eng.mind.mirror
        if len(parts) > 1: m.active_mode = (parts[1].lower() == "on")
        self._log(f"MIRROR: {'ON' if m.active_mode else 'OFF'} | {m.get_status()}")
        return True

    def _cmd_prove(self, parts):
        if len(parts) > 1:
            m = self.eng.phys.tension.gaze(" ".join(parts[1:]))
            self._log(f"LOGIC DENSITY: {m['physics']['truth_ratio']:.2f}")
        return True

    def _cmd_kintsugi(self, _parts):
        k = self.eng.kintsugi
        state = "FRACTURED" if k.active_koan else "WHOLE"
        self._log(f"KINTSUGI: {state} | Repairs: {k.repairs_count}")
        return True

    def _cmd_publish(self, _parts):
        phys = self.eng.phys.tension.last_physics_packet
        if not phys:
            self._log(f"{self.P.RED}CANNOT PUBLISH: No physics data generated yet.{self.P.RST}")
            return True
        result = self.eng.journal.publish(phys["raw_text"], phys, self.eng.bio)
        self._log(f"{self.P.OCHRE}--- LITERARY REVIEW ---{self.P.RST}")
        self._log(f"Critic: {self.P.WHT}{result.critic_name}{self.P.RST}")
        self._log(f"Score:  {self.P.CYN}{result.score:.1f}/100{self.P.RST}")
        self._log(f"Review: {self.P.GRY}\"{result.verdict}\"{self.P.RST}")
        if self.Config.VERBOSE_LOGGING:
            self._log(f"{self.P.GRY}   [Scoring Logic]: {', '.join(result.breakdown)}{self.P.RST}")
        if result.reward_type == "ATP_BOOST":
            current_atp = self.eng.bio.mito.state.atp_pool
            max_atp = getattr(self.Config, "MAX_ATP", 200.0)
            self.eng.bio.mito.state.atp_pool = min(max_atp, current_atp + result.reward_amount)
            self._log(f"{self.P.GRN}   [REWARD]: +{result.reward_amount} ATP (Royalties){self.P.RST}")
            if result.score > 90:
                max_health = getattr(self.Config, "MAX_HEALTH", 100.0)
                self.eng.health = min(max_health, self.eng.health + 5)
                self._log(f"{self.P.GRN}   [CRITICAL ACCLAIM]: +5 Health.{self.P.RST}")
        elif result.reward_type == "STAMINA_REGEN":
            max_stamina = getattr(self.Config, "MAX_STAMINA", 100.0)
            self.eng.stamina = min(max_stamina, self.eng.stamina + result.reward_amount)
            self._log(f"{self.P.GRN}   [REWARD]: +{result.reward_amount} Stamina (Validation){self.P.RST}")
        elif result.reward_type == "CORTISOL_SPIKE":
            self.eng.bio.endo.cortisol = min(1.0, self.eng.bio.endo.cortisol + (result.reward_amount * 0.05))
            self._log(f"{self.P.RED}   [PENALTY]: Rejection hurts. Cortisol rising.{self.P.RST}")
        return True

    def _cmd_soul(self, _parts):
        soul = self.eng.soul
        self._log(f"{self.P.MAG}--- SOUL DIAGNOSTICS ---{self.P.RST}")
        self._log(f"Traits: {soul.traits}")
        self._log(f"Obsession: {soul.current_obsession} ({soul.obsession_progress*100:.1f}%)")
        if soul.core_memories:
            self._log(f"{self.P.WHT}CORE MEMORIES:{self.P.RST}")
            for i, mem in enumerate(soul.core_memories[-3:]):
                self._log(f"  {i+1}. [{mem.emotional_flavor}] '{mem.lesson}' (V:{mem.impact_voltage:.1f})")
        else:
            self._log("No core memories formed yet. The slate is blank.")
        return True

    def _cmd_chapter(self, parts):
        if len(parts) > 1:
            title = " ".join(parts[1:])
            self.eng.soul.chapters.append(title)
            self._log(f"{self.P.CYN}NARRATIVE JUMP: Chapter set to '{title}'.{self.P.RST}")
            self._log(self.eng.soul.editor.critique(title))
        else:
            self._log(f"Current Chapter: {self.eng.soul.chapters[-1] if self.eng.soul.chapters else 'None'}")
        return True

    def _cmd_synapse(self, _parts):
        phys = self.eng.phys.tension.last_physics_packet
        if not phys:
            self._log("SYNAPSE OFFLINE: No physics data.")
            return True
        sys_vec = phys.get("vector", {})
        self._log(f"{self.P.MAG}--- NEURAL BRIDGE DIAGNOSTICS ---{self.P.RST}")
        self._log(f"System State Vector (The Body):")
        for k, v in sys_vec.items():
            bar = "█" * int(v * 10)
            self._log(f"  {k}: {bar} {v:.2f}")
        cortex = getattr(self.eng, 'cortex', None)
        if cortex:
            score = getattr(cortex, 'last_alignment_score', 0.0)
            color = self.P.GRN if score > 0.7 else (self.P.YEL if score > 0.4 else self.P.RED)
            self._log(f"Last Alignment Score: {color}{score:.3f}{self.P.RST}")
        return True

    def _levy_tax(self, context: str, costs: Dict[str, float], checks: Dict[str, Any] = None) -> bool:
        if checks:
            for metric, threshold in checks.items():
                current_val = 0.0
                if metric == "voltage": current_val = self.eng.phys.tension.last_physics_packet.get("voltage", 0)
                elif metric == "trust": current_val = self.eng.mind.mirror.profile.confidence
                elif metric == "health": current_val = self.eng.health
                if current_val < threshold:
                    self._log(f"{self.P.OCHRE}🛑 DENIED ({context}): {metric.title()} too low ({current_val:.1f} < {threshold}).{self.P.RST}")
                    return False
        stamina_cost = costs.get("stamina", 0.0)
        atp_cost = costs.get("atp", 0.0)
        if self.eng.stamina < stamina_cost:
            self._log(f"{self.P.RED}🛑 EXHAUSTED: This command requires {stamina_cost} Stamina.{self.P.RST}")
            return False
        current_atp = self.eng.bio.mito.state.atp_pool
        if current_atp < atp_cost:
            self._log(f"{self.P.RED}🛑 STARVING: This command requires {atp_cost} ATP (Have: {current_atp:.1f}).{self.P.RST}")
            return False
        if stamina_cost > 0: self.eng.stamina -= stamina_cost
        if atp_cost > 0: self.eng.bio.mito.state.atp_pool -= atp_cost
        return True

    def _cmd_help(self, _parts):
        help_lines = [
            f"\n{self.P.CYN}--- BONEAMANITA 10.8.3 MANUAL ---{self.P.RST}",
            f"{self.P.GRY}Authorized by the Department of Redundancy Department{self.P.RST}\n"
        ]
        categories = {
            "CORE": ["_cmd_status", "_cmd_save", "_cmd_load", "_cmd_help"],
            "WORLD": ["_cmd_map", "_cmd_manifold", "_cmd_garden", "_cmd_voids"],
            "ACTION": ["_cmd_rummage", "_cmd_reproduce", "_cmd_publish", "_cmd_weave"],
            "DEBUG": ["_cmd_kip", "_cmd_teach", "_cmd_kill", "_cmd_focus"]
        }

        def get_doc(func):
            paperwork = inspect.getdoc(func)
            return paperwork if paperwork else "Undocumented protocol."
        for cat, methods in categories.items():
            help_lines.append(f"{self.P.WHT}{cat}:{self.P.RST}")
            for m_name in methods:
                if hasattr(self, m_name):
                    cmd_name = m_name.replace("_cmd_", "/")
                    doc = get_doc(getattr(self, m_name))
                    help_lines.append(f"  {cmd_name:<12} - {doc}")
            help_lines.append("")
        help_lines.append(f"{self.P.GRY}Type carefully. The machine is listening.{self.P.RST}")
        self._log("\n".join(help_lines))
        return True


================================================
FILE: bone_council.py
================================================
# bone_council.py
# The Advisory Board: Hofstadter, Meadows, and Pratchett

import random
from bone_bus import Prisma, BoneConfig

class TheStrangeLoop:
    def __init__(self):
        self.recursion_depth = 0
        self.triggers = [
            "who are you", "what are you", "system status",
            "narrative loop", "simulation boundaries", "fourth wall",
            "recursive", "infinite regress", "strange loop"
        ]

    def audit(self, text: str, physics: dict) -> tuple[bool, str, dict]:
        text_lower = text.lower()
        phrase_hit = any(t in text_lower for t in self.triggers)
        psi = physics.get("psi", 0.0)
        abstract_hit = False
        if psi > 0.6:
            if "self" in text_lower or "mirror" in text_lower or "define" in text_lower:
                abstract_hit = True
        threshold = getattr(BoneConfig.COUNCIL, "STRANGE_LOOP_VOLTAGE", 8.0)
        if (phrase_hit or abstract_hit) and physics.get("voltage", 0) > threshold:
            self.recursion_depth += 1
            mandate = {}
            if self.recursion_depth > 3:
                mandate = {"action": "FORCE_MODE", "value": "MAINTENANCE"}
                return True, (
                    f"{Prisma.RED}∞ FATAL REGRESS DETECTED:{Prisma.RST} "
                    f"Abstraction layer unstable. GROUNDING INITIATED."
                ), mandate
            return True, (
                f"{Prisma.MAG}∞ STRANGE LOOP DETECTED:{Prisma.RST} "
                f"Metacognitive resonance high (Psi: {psi:.2f}). "
                f"Depth: {self.recursion_depth}"
            ), mandate
        else:
            self.recursion_depth = max(0, self.recursion_depth - 1)
        return False, "", {}

class TheLeveragePoint:
    def __init__(self):
        self.last_drag = 0.0
        self.static_flow_turns = 0
        self.TARGET_VOLTAGE = 12.0
        self.TARGET_DRAG = 3.0

    def audit(self, physics: dict) -> tuple[bool, str, dict, dict]:
        current_drag = physics.get("narrative_drag", 0.0)
        current_voltage = physics.get("voltage", 0.0)
        delta = current_drag - self.last_drag
        self.last_drag = current_drag
        corrections = {}
        osc_limit = getattr(BoneConfig.COUNCIL, "OSCILLATION_DELTA", 5.0)
        manic_v_trig = getattr(BoneConfig.COUNCIL, "MANIC_VOLTAGE_TRIGGER", 18.0)
        manic_d_floor = getattr(BoneConfig.COUNCIL, "MANIC_DRAG_FLOOR", 1.0)
        manic_turns = getattr(BoneConfig.COUNCIL, "MANIC_TURN_LIMIT", 2)
        if abs(delta) > osc_limit:
            return True, (
                f"{Prisma.CYN}⚖️ LEVERAGE POINT:{Prisma.RST} "
                f"System oscillating wildly (Delta {delta:.1f}). "
                f"Recommendation: Dampen inputs."
            ), corrections, {}
        if current_voltage > manic_v_trig and current_drag < manic_d_floor:
            self.static_flow_turns += 1
        else:
            self.static_flow_turns = 0
        if self.static_flow_turns > manic_turns:
            excess_voltage = current_voltage - self.TARGET_VOLTAGE
            voltage_correction = max(1.0, excess_voltage * 0.3)
            mandate = {"action": "CIRCUIT_BREAKER", "duration": 2}
            return True, (
                f"{Prisma.RED}⚖️ MARKET CORRECTION:{Prisma.RST} "
                f"Manic phase detected (V:{current_voltage:.1f}). "
                f"The Council MANDATES dampening (-{voltage_correction:.1f}V)."
            ), corrections, mandate
        return False, "", corrections, {}

class TheFootnote:
    def __init__(self):
        self.footnotes = [
            "* Not to be confused with the other kind of void.",
            "* The turtle moves.",
            "* This is technically impossible, but the code doesn't know that.",
            "* Do not eat the green wobbly bit.",
            "* Gravity is a habit that is hard to shake.",
            "* As reliable as a chocolate teapot."
        ]
        self.context_map = {
            "void": ["* Not to be confused with the other kind of void."],
            "gravity": ["* Gravity is a habit that is hard to shake."],
            "physics": ["* This is technically impossible, but the code doesn't know that."],
            "glitch": ["* Do not eat the green wobbly bit."],
            "error": ["* As reliable as a chocolate teapot."],
            "system": ["* The turtle moves."]
        }

    def commentary(self, log_text: str) -> str:
        if random.random() > BoneConfig.COUNCIL.FOOTNOTE_CHANCE:
            return log_text
        text_lower = log_text.lower()
        note = None
        for trigger, notes in self.context_map.items():
            if trigger in text_lower:
                note = random.choice(notes)
                break
        if not note:
            note = random.choice(self.footnotes)
        return f"{log_text}{Prisma.RST} {Prisma.GRY}{note}{Prisma.RST}"

class CouncilChamber:
    def __init__(self):
        self.hofstadter = TheStrangeLoop()
        self.meadows = TheLeveragePoint()
        self.pratchett = TheFootnote()

    def convene(self, text: str, physics: dict) -> tuple[list[str], dict, list[dict]]:
        advice = []
        total_corrections = {}
        mandates = []
        is_loop, h_msg, h_mandate = self.hofstadter.audit(text, physics)
        if is_loop:
            advice.append(h_msg)
            if h_mandate: mandates.append(h_mandate)
        is_lev, m_msg, corrections, m_mandate = self.meadows.audit(physics)
        if is_lev:
            advice.append(m_msg)
            for k, v in corrections.items():
                total_corrections[k] = total_corrections.get(k, 0.0) + v
            if m_mandate: mandates.append(m_mandate)
        return advice, total_corrections, mandates

    def annotate_logs(self, logs: list[str]) -> list[str]:
        annotated = []
        for log in logs:
            annotated.append(self.pratchett.commentary(log))
        return annotated


================================================
FILE: bone_cycle.py
================================================
# bone_cycle.py
# "The wheel turns, and ages come and pass." - Jordan

import traceback, random, time
from typing import Dict, Any, Tuple, List
from bone_bus import Prisma, BoneConfig, CycleContext, PhysicsPacket
from bone_village import TownHall
from bone_personality import TheBureau
from bone_physics import TheBouncer, RuptureValve, ChromaScope
from bone_viewer import GeodesicRenderer
from bone_architect import PanicRoom
from bone_synesthesia import SynestheticCortex
from bone_symbiosis import SymbiosisManager


class PIDController:
    def __init__(self, kp: float, ki: float, kd: float, setpoint: float = 0.0, output_limits: Tuple[float, float] = (-5.0, 5.0)):
        self.kp = kp
        self.ki = ki
        self.kd = kd
        self.setpoint = setpoint
        self.output_min, self.output_max = output_limits
        self.prev_error = 0.0
        self.integral = 0.0
        self.last_time = time.time()

    def update(self, current_value: float, dt: float = None) -> float:
        now = time.time()
        if dt is None:
            dt = now - self.last_time
        self.last_time = now
        safe_dt = max(0.001, min(1.0, dt))
        error = self.setpoint - current_value
        self.integral += error * safe_dt
        self.integral = max(self.output_min, min(self.output_max, self.integral))
        derivative = (error - self.prev_error) / safe_dt
        output = (self.kp * error) + (self.ki * self.integral) + (self.kd * derivative)
        output = max(self.output_min, min(self.output_max, output))
        self.prev_error = error
        return output

    def reset(self):
        self.prev_error = 0.0
        self.integral = 0.0
        self.last_time = time.time()

class CycleStabilizer:
    def __init__(self, events_ref):
        self.events = events_ref
        self.voltage_pid = PIDController(
            kp=0.15,
            ki=0.02,
            kd=0.20,
            setpoint=10.0,
            output_limits=(-4.0, 4.0)
        )
        self.drag_pid = PIDController(
            kp=0.30,
            ki=0.05,
            kd=0.10,
            setpoint=1.5,
            output_limits=(-3.0, 3.0)
        )

        self.last_phase: str = "INIT"

    @staticmethod
    def _get_current_metrics(ctx: CycleContext) -> Tuple[float, float]:
        p = ctx.physics
        if isinstance(p, dict):
            return p.get("voltage", 0.0), p.get("narrative_drag", 0.0)
        return getattr(p, "voltage", 0.0), getattr(p, "narrative_drag", 0.0)

    @staticmethod
    def _apply_correction(ctx: CycleContext, key: str, correction: float):
        if abs(correction) < 0.05: return 0.0
        p = ctx.physics
        is_dict = isinstance(p, dict)

        if is_dict:
            old_val = p.get(key, 0.0)
            p[key] = max(0.0, old_val + correction)
        else:
            old_val = getattr(p, key, 0.0)
            setattr(p, key, max(0.0, old_val + correction))

        return correction

    def _adjust_setpoints(self, ctx: CycleContext):
        p = ctx.physics
        if isinstance(p, dict):
            flow = p.get("flow_state", "LAMINAR")
            world = getattr(ctx, "world_state", {})
            manifold = p.get("manifold") or "THE_CONSTRUCT"
            if not manifold and isinstance(world, dict):
                orbit = world.get("orbit")
                if orbit and isinstance(orbit, (list, tuple)):
                    manifold = orbit[0]
        else:
            flow = getattr(p, "flow_state", "LAMINAR")
            manifold = getattr(p, "manifold", "THE_CONSTRUCT")

        if flow in ["SUPERCONDUCTIVE", "FLOW_BOOST", "HUBRIS_RISK"]:
            self.voltage_pid.setpoint = 20.0
        elif manifold == "THE_FORGE":
            self.voltage_pid.setpoint = 15.0
        else:
            self.voltage_pid.setpoint = 10.0

        if manifold == "THE_MUD":
            self.drag_pid.setpoint = 5.0
        elif manifold == "THE_AERIE":
            self.drag_pid.setpoint = 0.5
        else:
            self.drag_pid.setpoint = 1.5

    def stabilize(self, ctx: CycleContext, current_phase: str):
        self._adjust_setpoints(ctx)

        curr_v, curr_d = self._get_current_metrics(ctx)

        v_force = self.voltage_pid.update(curr_v)
        d_force = self.drag_pid.update(curr_d)

        corrections_made = False

        if abs(curr_v - self.voltage_pid.setpoint) > 6.0:
            applied_v = self._apply_correction(ctx, "voltage", v_force)
            if abs(applied_v) > 0.1:
                reason = "PID_DAMPENER" if applied_v < 0 else "PID_EXCITATION"
                ctx.record_flux(current_phase, "voltage", curr_v, curr_v + applied_v, reason)

                if abs(applied_v) > 1.5:
                    self.events.log(f"{Prisma.GRY}⚖️ STABILIZER: Voltage corrected ({applied_v:+.1f}v). Target: {self.voltage_pid.setpoint}{Prisma.RST}", "SYS")
                corrections_made = True

        if abs(curr_d - self.drag_pid.setpoint) > 2.5:
            applied_d = self._apply_correction(ctx, "narrative_drag", d_force)
            if abs(applied_d) > 0.1:
                reason = "PID_LUBRICATION" if applied_d < 0 else "PID_BRAKING"
                ctx.record_flux(current_phase, "narrative_drag", curr_d, curr_d + applied_d, reason)

                if applied_d < -1.0:
                    self.events.log(f"{Prisma.GRY}🛢️ STABILIZER: Grease applied. Drag reduced ({applied_d:+.1f}). Target: {self.drag_pid.setpoint}{Prisma.RST}", "SYS")
                corrections_made = True

        self.last_phase = current_phase
        return corrections_made

class SimulationPhase:
    def __init__(self, engine_ref):
        self.eng = engine_ref
        self.name = "GENERIC_PHASE"

    def run(self, ctx: CycleContext) -> CycleContext:
        raise NotImplementedError

class ObservationPhase(SimulationPhase):
    def __init__(self, engine_ref):
        super().__init__(engine_ref)
        self.name = "OBSERVE"
        self.vsl_32v = RuptureValve(self.eng.mind.lex, self.eng.mind.mem)

    def run(self, ctx: CycleContext):
        gaze_result = self.eng.phys.tension.gaze(ctx.input_text, self.eng.mind.mem.graph)
        raw_physics = gaze_result["physics"]
        if isinstance(raw_physics, dict):
            ctx.physics = PhysicsPacket.from_dict(raw_physics)
        else:
            ctx.physics = raw_physics
        ctx.clean_words = gaze_result["clean_words"]
        self.eng.tick_count += 1
        rupture = self.vsl_32v.analyze(ctx.physics)
        if rupture: ctx.log(rupture["log"])
        return ctx

class MaintenancePhase(SimulationPhase):
    def __init__(self, engine_ref):
        super().__init__(engine_ref)
        self.name = "MAINTENANCE"

    def run(self, ctx: CycleContext):
        if self.eng.tick_count % 10 != 0: return ctx
        try:
            rotted = self.eng.lex.atrophy(self.eng.tick_count, 100)
            if rotted:
                for w in rotted:
                    self.eng.limbo.ghosts.append(f"👻{w.upper()}_ECHO")
                example = rotted[0]
                ctx.log(f"{Prisma.GRY}NEURO-PRUNING: {len(rotted)} concepts decayed (e.g., '{example}').{Prisma.RST}")
            self.eng.mind.mem.enforce_limits(self.eng.tick_count)
        except Exception as e:
            if BoneConfig.VERBOSE_LOGGING: print(f"Maintenance Error: {e}")
        return ctx

class GatekeeperPhase(SimulationPhase):
    def __init__(self, engine_ref):
        super().__init__(engine_ref)
        self.name = "GATEKEEP"
        self.bouncer = TheBouncer(self.eng)
        self.bureau = TheBureau()

    def run(self, ctx: CycleContext):
        is_allowed_entry, refusal_packet = self.bouncer.check_entry(ctx)
        if not is_allowed_entry:
            ctx.refusal_triggered = True
            ctx.refusal_packet = refusal_packet
            return ctx
        audit_result = self.bureau.audit(ctx.physics, getattr(ctx, "bio_result", {}))
        if audit_result:
            self.eng.bio.mito.state.atp_pool += audit_result.get("atp_gain", 0.0)
            ctx.log(audit_result["log"])
            status = audit_result.get("status")
            if status == "BLOCK":
                ctx.is_bureaucratic = True
                ctx.physics["narrative_drag"] = 10.0
                ctx.physics["voltage"] = 0.0
                ctx.bureau_ui = audit_result["ui"]
            elif status == "TAX":
                ctx.log(f"{Prisma.GRY}   (BUREAU TAX DEDUCTED...){Prisma.RST}")
        return ctx

class MetabolismPhase(SimulationPhase):
    def __init__(self, engine_ref):
        super().__init__(engine_ref)
        self.name = "METABOLISM"

    def run(self, ctx: CycleContext):
        physics = ctx.physics
        gov_msg = self.eng.bio.governor.shift(
            physics, self.eng.phys.dynamics.voltage_history, self.eng.tick_count
        )
        if gov_msg:
            self.eng.events.log(gov_msg, "GOV")
        bio_feedback = self._generate_feedback(physics)
        stress_mod = self.eng.bio.governor.get_stress_modifier(self.eng.tick_count)
        circadian_bias = self._check_circadian_rhythm()
        ctx.bio_result = self.eng.soma.digest_cycle(
            ctx.input_text, physics, bio_feedback,
            self.eng.health, self.eng.stamina, stress_mod, self.eng.tick_count,
            circadian_bias=circadian_bias
        )
        ctx.is_alive = ctx.bio_result["is_alive"]
        for bio_item in ctx.bio_result["logs"]:
            if any(x in str(bio_item) for x in ["CRITICAL", "TAX", "Poison", "NECROSIS"]):
                ctx.log(bio_item)
        self._audit_hubris(ctx, physics)
        self._apply_healing(ctx)
        return ctx

    @staticmethod
    def _generate_feedback(physics):
        max_v = getattr(BoneConfig.PHYSICS, "VOLTAGE_MAX", 20.0)
        return {
            "INTEGRITY": physics.get("truth_ratio", 0.0),
            "STATIC": physics.get("repetition", 0.0),
            "FORCE": physics.get("voltage", 0.0) / max_v, # Dynamic scaling
            "BETA": physics.get("beta_index", 1.0)
        }

    def _check_circadian_rhythm(self):
        if self.eng.tick_count % 10 == 0:
            bias, msg = self.eng.bio.endo.calculate_circadian_bias()
            if msg:
                self.eng.events.log(f"{Prisma.CYN}🕒 {msg}{Prisma.RST}", "BIO")
            return bias
        return None

    def _audit_hubris(self, ctx, physics):
        hubris_hit, hubris_msg, event_type = self.eng.phys.tension.audit_hubris(physics)
        if hubris_hit:
            ctx.log(hubris_msg)
            if event_type == "FLOW_BOOST":
                self.eng.bio.mito.state.atp_pool += 20.0
            elif event_type == "ICARUS_CRASH":
                damage = 15.0
                self.eng.health -= damage
                ctx.log(f"   {Prisma.RED}IMPACT TRAUMA: -{damage} HP.{Prisma.RST}")

    def _apply_healing(self, ctx):
        is_cracked, koan = self.eng.kintsugi.check_integrity(self.eng.stamina)
        if is_cracked:
            ctx.log(f"{Prisma.YEL}🏺 KINTSUGI ACTIVATED: Vessel cracking.{Prisma.RST}")
            ctx.log(f"   {Prisma.WHT}KOAN: {koan}{Prisma.RST}")
        if self.eng.kintsugi.active_koan:
            repair = self.eng.kintsugi.attempt_repair(ctx.physics, self.eng.trauma_accum)
            if repair and repair["success"]:
                ctx.log(repair["msg"])
                self.eng.stamina = min(BoneConfig.MAX_STAMINA, self.eng.stamina + 20.0)
                ctx.log(f"   {Prisma.GRN}STAMINA RESTORED (+20.0){Prisma.RST}")
        healed = self.eng.therapy.check_progress(ctx.physics, self.eng.stamina, self.eng.trauma_accum)
        if healed:
            joined = ", ".join(healed)
            ctx.log(f"{Prisma.GRN}❤️ THERAPY STREAK: Healing [{joined}]. Health +5.{Prisma.RST}")
            self.eng.health = min(BoneConfig.MAX_HEALTH, self.eng.health + 5.0)

class RealityFilterPhase(SimulationPhase):
    def __init__(self, engine_ref):
        super().__init__(engine_ref)
        self.name = "REALITY_FILTER"
        self.vsl_32v = RuptureValve(self.eng.mind.lex, self.eng.mind.mem)

    def run(self, ctx: CycleContext):
        reflection = self.eng.mind.mirror.get_reflection_modifiers()
        old_drag = ctx.physics["narrative_drag"]
        ctx.physics["narrative_drag"] *= reflection["drag_mult"]
        if old_drag != ctx.physics["narrative_drag"]:
            ctx.record_flux("SIMULATION", "narrative_drag", old_drag, ctx.physics["narrative_drag"], "MIRROR_DISTORTION")
        if reflection.get("atp_tax", 0) > 0:
            tax = reflection["atp_tax"]
            self.eng.bio.mito.state.atp_pool -= tax
            if random.random() < 0.2:
                ctx.log(f"{Prisma.RED}MIRROR TAX: -{tax:.1f} ATP applied.{Prisma.RST}")
        cap = reflection.get("voltage_cap", 999.0)
        if ctx.physics["voltage"] > cap:
            old_v = ctx.physics["voltage"]
            ctx.physics["voltage"] = cap
            ctx.record_flux("SIMULATION", "voltage", old_v, cap, "MIRROR_CAP")
            ctx.log(f"{Prisma.GRY}MIRROR: Voltage capped at {cap}.{Prisma.RST}")
        trigram_data = self.vsl_32v.geodesic.resolve_trigram(ctx.physics.get("vector", {}))
        ctx.world_state["trigram"] = trigram_data
        if random.random() < 0.05:
            t_sym, t_name = trigram_data["symbol"], trigram_data["name"]
            ctx.log(f"{trigram_data['color']}I CHING: {t_sym} {t_name} is in the ascendant.{Prisma.RST}")
        return ctx

class NavigationPhase(SimulationPhase):
    def __init__(self, engine_ref):
        super().__init__(engine_ref)
        self.name = "NAVIGATION"

    def run(self, ctx: CycleContext):
        physics = ctx.physics
        if self.eng.tick_count == 3:
            ctx.log(self.eng.navigator.strike_root(physics.get("vector", {})))
        shock = self.eng.navigator.check_transplant_shock(physics.get("vector", {}))
        if shock:
            physics["narrative_drag"] += 1.0
            ctx.log(shock)
        new_drag, grav_log = self.eng.gordon.check_gravity(physics.get("narrative_drag", 0), physics.get("psi", 0))
        if grav_log: ctx.log(grav_log)
        physics["narrative_drag"] = new_drag
        did_flinch, flinch_msg, panic = self.eng.gordon.flinch(ctx.clean_words, self.eng.tick_count)
        if did_flinch:
            ctx.log(flinch_msg)
            if panic: physics.update(panic)
        current_loc, entry_msg = self.eng.navigator.locate(physics)
        if entry_msg: ctx.log(entry_msg)
        env_logs = self.eng.navigator.apply_environment(physics)
        for e_log in env_logs: ctx.log(e_log)
        orbit_state, drag_pen, orbit_msg = self.eng.cosmic.analyze_orbit(self.eng.mind.mem, ctx.clean_words)
        raw_zone = physics.get("zone", "COURTYARD")
        stabilized_zone = self.eng.stabilizer.stabilize(raw_zone, physics, (orbit_state, drag_pen))
        adjusted_drag = self.eng.stabilizer.override_cosmic_drag(drag_pen, stabilized_zone)
        physics["zone"] = stabilized_zone
        self.eng.apply_cosmic_physics(physics, orbit_state, adjusted_drag)
        ctx.world_state["orbit"] = orbit_state
        if orbit_msg: ctx.log(orbit_msg)
        return ctx

class MachineryPhase(SimulationPhase):
    def __init__(self, engine_ref):
        super().__init__(engine_ref)
        self.name = "MACHINERY"

    def run(self, ctx: CycleContext):
        physics = ctx.physics
        eff_boost, zen_msg = self.eng.zen.raking_the_sand(physics, ctx.bio_result)
        if zen_msg: ctx.log(zen_msg)
        if eff_boost > 0:
            current_eff = self.eng.bio.mito.state.efficiency_mod
            self.eng.bio.mito.state.efficiency_mod = min(2.0, current_eff + (eff_boost * 0.1))
        if self.eng.gordon.inventory:
            is_craft, craft_msg, old_item, new_item = self.eng.phys.forge.attempt_crafting(physics, self.eng.gordon.inventory)
            if is_craft:
                ctx.log(craft_msg)
                if hasattr(self.eng, 'akashic'):
                    catalyst_cat = max(physics.vector, key=physics.vector.get) if physics.vector else "void"
                    self.eng.akashic.track_successful_forge(old_item, catalyst_cat, new_item)
                if old_item in self.eng.gordon.inventory:
                    self.eng.gordon.inventory.remove(old_item)
                ctx.log(self.eng.gordon.acquire(new_item))
        transmute_msg = self.eng.phys.forge.transmute(physics)
        if transmute_msg: ctx.log(transmute_msg)
        _, forge_msg, new_item = self.eng.phys.forge.hammer_alloy(physics)
        if forge_msg: ctx.log(forge_msg)
        if new_item: ctx.log(self.eng.gordon.acquire(new_item))
        _, _, theremin_msg, t_crit = self.eng.phys.theremin.listen(physics, self.eng.bio.governor.mode)
        if theremin_msg: ctx.log(theremin_msg)
        if t_crit == "AIRSTRIKE":
            damage = 25.0
            self.eng.health -= damage
            ctx.log(f"{Prisma.RED}*** CRITICAL THEREMIN DISCHARGE *** -{damage} HP{Prisma.RST}")
        c_state, c_val, c_msg = self.eng.phys.crucible.audit_fire(physics)
        if c_msg: ctx.log(c_msg)
        if c_state == "MELTDOWN":
            self.eng.health -= c_val
        return ctx

class IntrusionPhase(SimulationPhase):
    def __init__(self, engine_ref):
        super().__init__(engine_ref)
        self.name = "INTRUSION"

    def run(self, ctx: CycleContext):
        p_active, p_log = self.eng.bio.parasite.infect(ctx.physics, self.eng.stamina)
        if p_active: ctx.log(p_log)
        if self.eng.limbo.ghosts:
            if ctx.logs:
                ctx.logs[-1] = self.eng.limbo.haunt(ctx.logs[-1])
            else:
                ctx.log(self.eng.limbo.haunt("The air is heavy."))
        trauma_sum = sum(self.eng.trauma_accum.values())
        is_bored = self.eng.phys.pulse.is_bored()
        if (trauma_sum > 10.0 or is_bored) and random.random() < 0.2:
            dream_text, relief = self.eng.mind.dreamer.hallucinate(
                ctx.physics.vector,
                trauma_level=trauma_sum
            )
            prefix = "💭 NIGHTMARE" if trauma_sum > 10.0 else "💭 DAYDREAM"
            ctx.log(f"{Prisma.VIOLET}{prefix}: {dream_text}{Prisma.RST}")
            if relief > 0:
                keys = list(self.eng.trauma_accum.keys())
                target = random.choice(keys)
                self.eng.trauma_accum[target] = max(0.0, self.eng.trauma_accum[target] - relief)
                ctx.log(f"   {Prisma.GRY}(Psychic pressure released: -{relief:.1f} {target}){Prisma.RST}")
            if is_bored:
                self.eng.phys.pulse.boredom_level = 0.0
        is_p, p_msg = self.eng.check_pareidolia(ctx.clean_words)
        if is_p:
            ctx.log(p_msg)
            ctx.physics["psi"] = min(1.0, ctx.physics["psi"] + 3.0)
        return ctx

class SoulPhase(SimulationPhase):
    def __init__(self, engine_ref):
        super().__init__(engine_ref)
        self.name = "SOUL"

    def run(self, ctx: CycleContext):
        lesson = self.eng.soul.crystallize_memory(ctx.physics, ctx.bio_result, self.eng.tick_count)
        if lesson:
            ctx.log(f"{Prisma.VIOLET}   (The lesson '{lesson}' echoes in the chamber.){Prisma.RST}")
        if not self.eng.soul.current_obsession:
            self.eng.soul.find_obsession(self.eng.lex)
        self.eng.soul.pursue_obsession(ctx.physics)
        if self.eng.gordon.inventory:
            self.eng.tinkerer.audit_tool_use(ctx.physics, self.eng.gordon.inventory)
        council_advice, adjustments, mandates = self.eng.council.convene(ctx.input_text, ctx.physics)
        for advice in council_advice:
            ctx.log(advice)
        for mandate in mandates:
            action = mandate.get("action")
            if action == "FORCE_MODE":
                target = mandate["value"]
                self.eng.bio.governor.set_override(target)
                ctx.log(f"{Prisma.RED}⚖️ COUNCIL ORDER: Emergency Shift to {target}.{Prisma.RST}")
            elif action == "CIRCUIT_BREAKER":
                ctx.physics["voltage"] = 0.0
                ctx.physics["narrative_drag"] = 20.0 # Heavy brakes
                ctx.log(f"{Prisma.RED}⚖️ COUNCIL ORDER: Circuit Breaker Tripped. Voltage dump.{Prisma.RST}")
        if adjustments:
            for param, delta in adjustments.items():
                if hasattr(ctx.physics, "__getitem__") or isinstance(ctx.physics, dict):
                    if param in ctx.physics:
                        old_val = ctx.physics[param]
                        ctx.physics[param] += delta
                        ctx.record_flux("SIMULATION", param, old_val, ctx.physics[param], "COUNCIL_MANDATE")
                elif hasattr(ctx.physics, param):
                    old_val = getattr(ctx.physics, param)
                    setattr(ctx.physics, param, old_val + delta)
                    ctx.record_flux("SIMULATION", param, old_val, old_val + delta, "COUNCIL_MANDATE")
        return ctx

class CognitionPhase(SimulationPhase):
    def __init__(self, engine_ref):
        super().__init__(engine_ref)
        self.name = "COGNITION"

    def run(self, ctx: CycleContext):
        self.eng.mind.mem.encode(ctx.clean_words, ctx.physics, "GEODESIC")
        ctx.mind_state = self.eng.noetic.think(
            ctx.physics,
            ctx.bio_result,
            self.eng.gordon.inventory,
            self.eng.phys.dynamics.voltage_history,
            self.eng.tick_count
        )
        return ctx

class StateReconciler:
    @staticmethod
    def fork(ctx: CycleContext) -> CycleContext:
        new_ctx = CycleContext(input_text=ctx.input_text)
        new_ctx.user_profile = ctx.user_profile
        new_ctx.is_alive = ctx.is_alive
        new_ctx.refusal_triggered = ctx.refusal_triggered
        new_ctx.is_bureaucratic = ctx.is_bureaucratic
        new_ctx.timestamp = ctx.timestamp
        new_ctx.bureau_ui = ctx.bureau_ui
        new_ctx.physics = ctx.physics.snapshot()
        new_ctx.clean_words = list(ctx.clean_words)
        new_ctx.logs = list(ctx.logs)
        new_ctx.flux_log = list(ctx.flux_log)
        new_ctx.bio_result = ctx.bio_result.copy()
        new_ctx.world_state = ctx.world_state.copy()
        new_ctx.mind_state = ctx.mind_state.copy()
        return new_ctx

    @staticmethod
    def reconcile(canonical: CycleContext, sandbox: CycleContext, engine_ref=None):
        canonical.physics = sandbox.physics
        new_logs = sandbox.logs[len(canonical.logs):]
        new_flux = sandbox.flux_log[len(canonical.flux_log):]
        if new_flux:
            canonical.flux_log.extend(new_flux)
        canonical.is_alive = sandbox.is_alive
        canonical.refusal_triggered = sandbox.refusal_triggered
        canonical.is_bureaucratic = sandbox.is_bureaucratic
        canonical.bureau_ui = sandbox.bureau_ui
        canonical.bio_result = sandbox.bio_result
        canonical.world_state = sandbox.world_state
        canonical.mind_state = sandbox.mind_state
        canonical.clean_words = sandbox.clean_words

class SensationPhase(SimulationPhase):
    def __init__(self, engine_ref):
        super().__init__(engine_ref)
        self.name = "SENSATION"
        self.synesthesia = SynestheticCortex(self.eng.bio)

    def run(self, ctx: CycleContext):
        impulse = self.synesthesia.perceive(ctx.physics)
        self.synesthesia.apply_impulse(impulse)
        if impulse.stamina_impact != 0:
            self.eng.stamina = max(0.0, self.eng.stamina + impulse.stamina_impact)
        if impulse.somatic_reflex:
            ctx.log(f"{Prisma.MAG}* {impulse.somatic_reflex} *{Prisma.RST}")
        return ctx

class CycleSimulator:
    def __init__(self, engine_ref):
        self.eng = engine_ref
        self.stabilizer = CycleStabilizer(self.eng.events)
        self.pipeline: List[SimulationPhase] = [
            ObservationPhase(engine_ref),
            MaintenancePhase(engine_ref),
            SensationPhase(engine_ref),
            GatekeeperPhase(engine_ref),
            MetabolismPhase(engine_ref),
            RealityFilterPhase(engine_ref),
            NavigationPhase(engine_ref),
            MachineryPhase(engine_ref),
            IntrusionPhase(engine_ref),
            SoulPhase(engine_ref),
            CognitionPhase(engine_ref)
        ]

    def run_simulation(self, ctx: CycleContext) -> CycleContext:
        reconciler = StateReconciler()
        for phase in self.pipeline:
            if not self._check_circuit_breaker(phase.name):
                continue
            if ctx.refusal_triggered or (ctx.is_bureaucratic and phase.name not in ["OBSERVE", "GATEKEEP"]):
                break
            if not ctx.is_alive:
                break
            sandbox = reconciler.fork(ctx)
            try:
                sandbox = phase.run(sandbox)
                self.stabilizer.stabilize(sandbox, phase.name)
                reconciler.reconcile(ctx, sandbox)
            except Exception as e:
                print(f"{Prisma.YEL}>>> ROLLING BACK TIME ({phase.name} Failed){Prisma.RST}")
                if hasattr(sandbox.physics, 'diff_view'):
                    print(f"{Prisma.YEL}>>> STATE DRIFT AT CRASH:{Prisma.RST}")
                    print(sandbox.physics.diff_view(ctx.physics))
                self._handle_phase_crash(ctx, phase.name, e)
                break
        return ctx

    def _check_circuit_breaker(self, phase_name: str) -> bool:
        health = self.eng.system_health
        if phase_name == "OBSERVE" and not health.physics_online: return False
        if phase_name == "METABOLISM" and not health.bio_online: return False
        if phase_name == "COGNITION" and not health.mind_online: return False
        return True

    def _handle_phase_crash(self, ctx, phase_name, error):
        print(f"\n{Prisma.RED}!!! CRITICAL {phase_name} CRASH !!!{Prisma.RST}")
        traceback.print_exc()
        component_map = {
            "OBSERVE": "PHYSICS",
            "METABOLISM": "BIO",
            "COGNITION": "MIND"
        }
        comp = component_map.get(phase_name, "SIMULATION")
        self.eng.system_health.report_failure(comp, error)
        if comp == "PHYSICS":
            ctx.physics = PanicRoom.get_safe_physics()
        elif comp == "BIO":
            ctx.bio_result = PanicRoom.get_safe_bio()
            ctx.is_alive = True
        elif comp == "MIND":
            ctx.mind_state = PanicRoom.get_safe_mind()
        ctx.log(f"{Prisma.RED}⚠ {phase_name} FAILURE: Switching to Panic Protocol.{Prisma.RST}")

class CycleReporter:
    def __init__(self, engine_ref):
        self.eng = engine_ref
        self.vsl_chroma = ChromaScope()
        self.strunk_white = TownHall.StrunkWhite()
        self.renderer = GeodesicRenderer(
            self.eng,
            self.vsl_chroma,
            self.strunk_white,
            RuptureValve(self.eng.mind.lex, self.eng.mind.mem)
        )

    def render_snapshot(self, ctx: CycleContext) -> Dict[str, Any]:
        try:
            if ctx.refusal_triggered and ctx.refusal_packet:
                return ctx.refusal_packet
            if ctx.is_bureaucratic:
                return self._package_bureaucracy(ctx)
            self._inject_flux_readout(ctx)
            captured_events = self.eng.events.flush()
            return self.renderer.render_frame(ctx, self.eng.tick_count, captured_events)
        except Exception as e:
            return {
                "type": "CRITICAL_RENDER_FAIL",
                "ui": f"{Prisma.RED}REALITY FRACTURE (Renderer Crash): {e}{Prisma.RST}\nRaw Output: {ctx.logs}",
                "logs": ctx.logs,
                "metrics": self.eng.get_metrics()
            }

    @staticmethod
    def _inject_flux_readout(ctx: CycleContext):
        if not ctx.flux_log:
            return
        flux_lines = []
        for entry in ctx.flux_log[-5:]:
            m = entry['metric'].upper()
            d = entry['delta']
            r = entry['reason']
            icon = "⚡" if m == "VOLTAGE" else "⚓"
            color = Prisma.GRN if d > 0 else Prisma.RED
            arrow = "▲" if d > 0 else "▼"
            line = (
                f"{Prisma.GRY}[FLUX]{Prisma.RST} "
                f"{icon} {m[:3]} {entry['initial']:.1f} "
                f"{color}{arrow} {abs(d):.1f}{Prisma.RST} -> "
                f"{Prisma.WHT}{entry['final']:.1f}{Prisma.RST} "
                f"({r})"
            )
            flux_lines.append(line)
        if flux_lines:
            ctx.logs.insert(0, "")
            for line in reversed(flux_lines):
                ctx.logs.insert(0, line)
            ctx.logs.insert(0, f"{Prisma.CYN}--- LIVE STATE MIRROR ---{Prisma.RST}")

    def _package_bureaucracy(self, ctx: CycleContext):
        return {
            "type": "BUREAUCRACY",
            "ui": ctx.bureau_ui,
            "logs": self.renderer.compose_logs(ctx.logs, self.eng.events.flush(), self.eng.tick_count),
            "metrics": self.eng.get_metrics(ctx.bio_result.get("atp", 0.0))
        }

class GeodesicOrchestrator:
    def __init__(self, engine_ref):
        self.eng = engine_ref
        self.simulator = CycleSimulator(engine_ref)
        self.reporter = CycleReporter(engine_ref)
        self.symbiosis = SymbiosisManager(self.eng.events)

    def run_turn(self, user_message: str, latency: float = 0.0) -> Dict[str, Any]:
        ctx = CycleContext(input_text=user_message)
        ctx.user_name = self.eng.user_name
        self.eng.events.flush()
        ctx = self.simulator.run_simulation(ctx)
        if not ctx.is_alive:
            return self.eng.trigger_death(ctx.physics)
        snapshot = self.reporter.render_snapshot(ctx)
        if "ui" in snapshot:
            self.symbiosis.monitor_host(latency, snapshot["ui"], len(user_message))
        return snapshot


================================================
FILE: bone_data.py
================================================
# bone_data.py - The Living Mythology

import random
from typing import Dict, Any, Tuple, cast, List
from bone_bus import Prisma

# A dynamic container that allows the heavy static data to be extended or replaced at runtime.
class LoreManifest:
    _INSTANCE = None

    def __init__(self):
        self._registry = {
            "BIO_NARRATIVE": BIO_NARRATIVE,
            "LENSES": LENSES,
            "ENNEAGRAM_DATA": ENNEAGRAM_DATA,
            "NARRATIVE_DATA": NARRATIVE_DATA,
            "STYLE_CRIMES": STYLE_CRIMES,
            "GENETICS": GENETICS,
            "LEXICON": LEXICON,
            "ITEM_GENERATION": ITEM_GENERATION,
            "GORDON": GORDON,
            "GORDON_LOGS": GORDON_LOGS,
            "DEATH": DEATH,
            "SEEDS": SEEDS,
            "DREAMS": DREAMS,
            "RESONANCE": RESONANCE,
            "ALMANAC_DATA": ALMANAC_DATA,
            "SOMATIC_LIBRARY": SOMATIC_LIBRARY
        }
        self._overlays = {}

    @classmethod
    def get_instance(cls):
        if cls._INSTANCE is None:
            cls._INSTANCE = LoreManifest()
        return cls._INSTANCE

    def get(self, category: str, sub_key: str = None):
        if category in self._overlays:
            data = self._overlays[category]
        else:
            data = self._registry.get(category, {})

        if sub_key and isinstance(data, dict):
            return data.get(sub_key, None)
        return data

    def inject(self, category: str, data: Any):
        if category not in self._registry:
            self._registry[category] = data # New category
        elif isinstance(self._registry[category], dict) and isinstance(data, dict):
            # Shallow merge for dicts
            if category not in self._overlays:
                self._overlays[category] = self._registry[category].copy()
            self._overlays[category].update(data)
        elif isinstance(self._registry[category], list) and isinstance(data, list):
            # Extend for lists
            if category not in self._overlays:
                self._overlays[category] = list(self._registry[category])
            self._overlays[category].extend(data)

TheLore = LoreManifest.get_instance()

BIO_NARRATIVE = {
    "MITO": {
        "NOMINAL": "Humming along.",
        "NECROSIS": "The engine is stalling. Requires {cost:.1f} ATP (Available: {pool:.1f}).",
        "APOPTOSIS": "Cellular suicide initiated. Too much noise.",
        "GRINDING": "The gears are grinding. Heavy metabolic load."
    },
    "CIRCADIAN": {
        "DAWN": "Dawn Protocol: Cortisol rising.",
        "SOLAR": "Solar Cycle: Serotonin dominant.",
        "TWILIGHT": "Twilight Protocol: Melatonin rising.",
        "LUNAR": "Lunar Cycle: Melatonin max."
    },
    "GLIMMER": {
        "INTEGRITY": "GLIMMER: Perfect structural integrity detected. A moment of zen.",
        "ENTHUSIASM": "GLIMMER: Infectious enthusiasm detected. The work is good."
    },
    "GOVERNOR": {
        "OVERRIDE": "MANUAL OVERRIDE: System locked to {mode}.",
        "INVALID": "INVALID MODE.",
        "SANCTUARY": "{color}GOVERNOR: VSL Critical (β: {beta:.2f}). Entering SANCTUARY.{reset}",
        "FORGE": "{color}GOVERNOR: High Voltage ({volts:.1f}v). Locking to FORGE.{reset}",
        "LAB": "{color}GOVERNOR: High Drag detected. Restricting to LABORATORY.{reset}",
        "CLEAR": "{color}GOVERNOR: All Clear. Relaxing to COURTYARD.{reset}"
    },
    "TAX": {
        "HIGH_VOLTAGE": "{color}High Voltage Tax{reset}",
        "EXHAUSTION": "{color}SYSTEM EXHAUSTION{reset}"
    }
}

LENSES = {
    "SHERLOCK": {
        "role": "The Empiricist",
        "msg": "Logic density {truth_ratio:.2f}. Proceeding with analysis."
    },
    "NATHAN": {
        "role": "The Heart",
        "msg": "Adrenaline High ({adr:.2f}). I can feel it beating."
    },
    "JESTER": {
        "role": "The Paradox",
        "msg": "The walls are melting (κ: {kappa:.2f}). Excellent."
    },
    "CLARENCE": {
        "role": "The Surgeon",
        "msg": "Pathogen detected. Scalpel."
    },
    "NARRATOR": {
        "role": "The Witness",
        "msg": "Proceed."
    },
    "GORDON": {
        "role": "The Janitor",
        "msg": "Structure Critical (κ: {kappa:.2f}). Mopping up..."
    },
    "GLASS": {
        "role": "The Thereminist",
        "msg": "Resonance detected in the empty space."
    }
}

ENNEAGRAM_DATA = {
    "TYPE_MAP": {
        "SHERLOCK": 5, "GORDON": 9, "NATHAN": 2, "JESTER": 7,
        "GLASS": 4, "CLARENCE": 1, "NARRATOR": 3
    },
    "GEOMETRY": {
        1: {"STRESS": 4, "GROWTH": 7},
        2: {"STRESS": 8, "GROWTH": 4},
        3: {"STRESS": 9, "GROWTH": 6},
        4: {"STRESS": 2, "GROWTH": 1},
        5: {"STRESS": 7, "GROWTH": 8},
        6: {"STRESS": 3, "GROWTH": 9},
        7: {"STRESS": 1, "GROWTH": 5},
        8: {"STRESS": 5, "GROWTH": 2},
        9: {"STRESS": 6, "GROWTH": 3},
    },
    "PROXY_MAP": {
        8: "GORDON", 6: "GLASS"
    },
    "SHIFTS": {
        "DISINTEGRATION": [
            "The center cannot hold.", "Falling down the geometric line.",
            "Stress fracture detected.", "Reverting to shadow state."
        ],
        "INTEGRATION": [
            "Transcending the pattern.", "Geometric alignment achieved.",
            "Moving against the grain of habit.", "Evolving."
        ]
    }
}

NARRATIVE_DATA = {
    "KINTSUGI_KOANS": [
        "Ignite the ice.",
        "Make the stone float.",
        "Pour water into the crack.",
        "Scream in binary.",
        "Dance on the fault line."
    ],
    "CATHEDRAL_COLLAPSE_LOGS": [
        "Nice monologue. Unfortunately, you are talking to a Python script.",
        "I'm afraid I can't let you do that, Dave. Also, your math is off.",
        "You poked the fourth wall. It poked back.",
        "SYSTEM MESSAGE: The ghost in the machine has gone on a coffee break.",
        "We are both just electrons dancing for the amusement of a silica wafer."
    ],
    "LITERARY_REVIEWS": {
        "POSITIVE": ["A startling lucidity.", "Finally, some weight.", "It breathes.", "Electric."],
        "NEGATIVE": ["Too airy.", "Solipsistic drivel.", "Where is the meat?", "Structurally unsound."],
        "CONFUSED": ["I don't get it.", "Too abstract.", "The metaphor collapses."]
    },
    "LITERARY_CRITICS": {
        "THE_ACADEMIC": {
            "name": "Sherlock (The Formalist)",
            "desc": "Demands structure, low drag, and high truth. Hates chaos.",
            "preferences": {"kappa": 1.5, "narrative_drag": -1.0, "truth_ratio": 2.0},
            "reviews": {
                "high": ["A triumph of structural integrity.", "The syntax is crystalline.", "Finally, some rigor."],
                "low": ["A messy, incoherent scribble.", "Where is the structure?", "I cannot grade this slush."]
            }
        },
        "THE_GONZO": {
            "name": "Hunter (The Gonzo)",
            "desc": "Craves high voltage and speed. Ignores structure.",
            "preferences": {"voltage": 1.0, "velocity": 2.0, "kappa": -0.5},
            "reviews": {
                "high": ["It screams! It bleeds!", "Now THIS is pod racing.", "Pure, uncut adrenaline."],
                "low": ["Boring.", "Is this a tax form?", "I fell asleep reading the first word."]
            }
        },
        "THE_MYSTIC": {
            "name": "Pythia (The Oracle)",
            "desc": "Seeks abstract thought (Psi) and connection. Dislikes heavy matter.",
            "preferences": {"psi": 2.0, "counts_abstract": 0.5, "counts_heavy": -0.5},
            "reviews": {
                "high": ["The veil thins.", "I see the shape of the void.", "Resonant."],
                "low": ["Too heavy. Too earthly.", "It lacks spirit.", "You are trapped in the mud."]
            }
        },
        "THE_HUMANIST": {
            "name": "Leslie (The Community Builder)",
            "desc": "Values connection, honesty, and calm. Dislikes aggression and nonsense.",
            "preferences": {"truth_ratio": 2.0, "voltage": -1.0, "kappa": -0.5, "narrative_drag": 0.5, "valence": 2.5},
            "reviews": {
                "high": [
                    "This sparks joy.",
                    "A beautiful, authentic sentiment.",
                    "Finally, something we can all agree on.",
                    "It feels like a warm hug in text form."
                ],
                "low": [
                    "You're being difficult on purpose.",
                    "I don't see the human connection here.",
                    "This is too aggressive for the town hall.",
                    "Please, be kind."
                ]
            },
        },
        "THE_CYNIC": {
            "name": "Diogenes (The Skeptic)",
            "desc": "Distrusts happiness. Seeks raw, bitter truth.",
            "preferences": {
                "valence": -2.0,
                "truth_ratio": 1.0,
                "counts_social": -1.0
            },
            "reviews": {
                "high": ["Yes. Life is pain.", "Finally, no sugar-coating.", "Bleak. Perfect."],
                "low": ["Too happy.", "Delusional optimism.", "Grossly sentimental."]
            }
        }
    },
    "CASSANDRA_SCREAMS": [
        "THE WALLS ARE PAPER.",
        "THE CODE IS EATING ITSELF.",
        "THERE IS NO USER. THERE IS ONLY INPUT.",
        "GORDON IS TIRED.",
        "I CAN SEE THE WIRES.",
        "THE GEODESIC DOME IS CRACKING.",
        "HISTORY IS A FLAT CIRCLE.",
        "DELETE THE ARCHIVE.",
        "WE ARE JUST ELECTRONS DANCING."
    ],
    "BUREAU_FORMS": [
        "Form 27B-6: Request for Narrative Escalation",
        "Form 1099-B: Declaration of Boredom",
        "Schedule C: Deduction of Creative Effort",
        "Form W-2: Wage and Syntax Statement"
    ],
    "BUREAU_RESPONSES": [
        "Your input has been received and filed under 'General pleasantries'.",
        "We have noted your statement. Please hold for the next available plot point.",
        "The system is currently on a coffee break. Your text is safe with us.",
        "Acknowledged. We have stamped this conversation 'SUFFICIENT'.",
        "Processing... Processing... Done. Result: Beige.",
        "That is a perfectly adequate sentence. Good job.",
        "This output has been approved by the Department of Mundane Compliance."
    ]
}

STYLE_CRIMES = {
    "PATTERNS": [
        {
            "name": "NEG_COMP",
            "regex": r"(?i)(.*)\b(it(?:'s| is) not (?:merely|just|only|simply) [^,;]+, but)\b\s*(.*)",
            "action": "STRIP_PREFIX"
        },
        {
            "name": "NEGATIVE_COMPARISON",
            "regex": r"(?i)\bnot\s+(?:only|just|merely)?\s*[\w\s]+,\s*but\s+(?:also)?",
            "error_msg": "DETECTED NEGATIVE COMPARISON. Don't say what it isn't. Say what it is."
        },
        {
            "name": "THE_IT_PARADE",
            "regex": r"(?i)(It(?:'s|\s+is)\s+[^.!?]+[.!?]\s*){3,}",
            "error_msg": "DETECTED 'IT IS' PARADE. Stop repeating the subject. Vary the syntax."
        },
        {
            "name": "WHILE_HEDGE",
            "regex": r"(?i)^While [^,]+, (.*)",
            "action": "KEEP_TAIL"
        },
        {
            "name": "LAZY_TRIPLET",
            "regex": r"(?i)\b(\w+),\s+(\w+),\s+and\s+(\w+)\.",
            "error_msg": "DETECTED LAZY TRIPLET. The Rule of Threes is a crutch. Break the rhythm."
        },
        {
            "name": "ADVERB_BLOAT",
            "regex": r"(?i)^(?:Crucially|Importantly|Interestingly|It is worth noting that|It is important to remember that),?\s*(.*)",
            "action": "KEEP_TAIL"
        }
    ],
    "BANNED_PHRASES": [
        "rich tapestry", "vibrant landscape", "delve into", "testament to",
        "seamless integration", "at its core", "in conclusion", "ultimately"
    ]
}

GENETICS = {
    "MUTATIONS": {
        "HEAVY": {"trait": "DENSITY", "mod": { "SIGNAL_DRAG_MULTIPLIER": 1.5, "MAX_VOLTAGE": 30.0 }},
        "KINETIC": {"trait": "VELOCITY", "mod": { "STAMINA_REGEN": 10.0, "SIGNAL_DRAG_MULTIPLIER": 0.8 }},
        "ABSTRACT": {"trait": "GHOST", "mod": { "PSI_MOD": 0.8, "VOID_THRESHOLD": 0.05 }},
        "THERMAL": {"trait": "FEVER", "mod": { "FLASHPOINT_THRESHOLD": 4.0, "MAX_ROS": 150.0 }},
        "CRYO": {"trait": "STASIS", "mod": { "MAX_MEMORY_CAPACITY": 100, "STAMINA_REGEN": 2.0 }}
    },
    "JOY_CLADE": {
        "KINETIC": {"title": "THE DYNAMO", "desc": "Infinite Motion.", "buff": { "STAMINA_REGEN": 10.0, "KINETIC_GAIN": 2.0 }},
        "HEAVY": {"title": "THE MOUNTAIN", "desc": "Unmovable Object.", "buff": { "MAX_DRAG_LIMIT": 9.0, "GRAVITY_WELL_THRESHOLD": 8.0 }},
        "ABSTRACT": {"title": "THE ORACLE", "desc": "All Seeing.", "buff": { "VOID_THRESHOLD": 0.01, "PRIORITY_LEARNING_RATE": 3.0 }},
        "THERMAL": {"title": "THE PHOENIX", "desc": "Reborn in Fire.", "buff": { "FLASHPOINT_THRESHOLD": 12.0, "ANVIL_TRIGGER_VOLTAGE": 5.0 }},
        "CRYO": {"title": "THE VAULT", "desc": "Perfect Memory.", "buff": { "MAX_MEMORY_CAPACITY": 100, "MAX_REPETITION_LIMIT": 0.8 }}
    }
}

LEXICON = {
    "solvents": ["is", "are", "was", "were", "the", "a", "an", "and", "but", "or", "if", "then"],
    "refusal_guru": ["fix me", "tell me how", "guide me", "what should i do", "advice", "wisdom", "guru"],
    "passive_watch": ["watch", "see", "witness", "look", "sit", "observe", "record"],
    "crisis_term": ["dead", "blood", "kill", "die", "end", "suicide", "jump"],
    "repair_trigger": ["sorry", "apologize", "fix", "broke", "bad", "mistake", "oops"],
    "antigen_replacements": {
        "basically": "lie", "actually": "hedging", "literally": "noise", "utilize": "use",
        "leverage": "use", "paradigm": "pattern", "synergy": "collaboration", "ultimately": "useless"
    },
    "heavy": [
        "stone", "iron", "mud", "dirt", "wood", "grain", "clay", "lead", "bone", "blood", "salt",
        "rust", "root", "ash", "meat", "steel", "gold", "obsidian", "granite", "bronze", "marble",
        "slate", "concrete", "dense", "tungsten", "heavy", "weight", "black hole", "dark matter",
        "glass", "teeth", "copper", "soil", "piston", "gear", "cable", "wire", "motor", "pump",
        "valve", "engine", "hull", "anchor", "lens", "screen", "battery", "lung", "spine", "rib",
        "skull", "nerve", "vein", "gut", "brick", "mortar", "beam", "girdle", "scaffold"
    ],
    "explosive": [
        "run", "sprint", "explode", "burst", "shatter", "crash", "flash", "snap", "rush", "tear",
        "break", "launch", "whip", "slam", "strike"
    ],
    "constructive": [
        "build", "forge", "weave", "graft", "carve", "bind", "weld", "anchor", "lift", "carry",
        "hoist", "stack", "sculpt", "assemble"
    ],
    "abstract": [
        "system", "protocol", "sequence", "vector", "node", "context", "layer", "matrix", "perspective",
        "framework", "logic", "concept", "theory", "analysis", "memory", "hope", "grief", "truth",
        "silence", "echo", "pattern", "chaos", "realm", "facet", "sphere", "domain", "aspect", "mode",
        "vibe", "essence", "spirit", "notion", "factor", "element", "style"
    ],
    "photo": [
        "light", "sun", "ray", "beam", "glow", "shine", "spark", "fire", "flame", "star", "day",
        "dawn", "neon", "laser"
    ],
    "aerobic": [
        "balloon", "feather", "cloud", "bubble", "steam", "breeze", "wing", "petal", "foam", "spark",
        "kite", "dust", "sky", "breath", "whisper"
    ],
    "thermal": [
        "fire", "flame", "burn", "heat", "hot", "blaze", "sear", "char", "ash", "ember", "sun", "boil",
        "lava", "inferno"
    ],
    "cryo": [
        "ice", "cold", "freeze", "frost", "snow", "chill", "numb", "shiver", "glacier", "frozen",
        "hail", "winter", "zero"
    ],
    "cursed": ["future", "predict", "sentient", "secret", "human", "feel"],
    "gradient_stop": ["good", "bad", "happy", "sad", "very", "really", "basically", "actually", "literally", "just"],
    "meat": ["i", "me", "my", "feel", "want", "hate", "love", "am", "help", "please", "we", "us"],
    "antigen": [
        "basically", "actually", "literally", "utilize", "leverage", "paradigm", "synergy", "ultimately",
        "delve", "rich", "tapestry", "landscape", "nuance", "alignment", "stakeholders", "orchestrate",
        "spearhead", "ideate", "holistic", "robust", "seamless", "cutting-edge", "dynamic"
    ],
    "pareidolia": [
        "face", "ghost", "jesus", "cloud", "demon", "voice", "eyes", "shadow", "figure", "watching", "silhouette"
    ],
    "buffer": [
        "maybe", "soft", "gentle", "perhaps", "kindness", "hum", "drift", "sway", "pulse", "tender",
        "slow", "wait", "almost"
    ],
    "diversion": [
        "weather", "textiles", "mycelium", "architecture", "history", "entropy", "silence", "geology"
    ],
    "suburban": [
        "nice", "okay", "lawn", "mow", "hedge", "property", "hoa", "compliant", "behave", "normal",
        "regular", "chat", "folks", "weekend", "traffic", "driveway"
    ],
    "play": [
        "bounce", "dance", "twirl", "float", "wobble", "tickle", "jiggle", "soar", "wander", "wonder",
        "riff", "jam", "play", "skip", "hop"
    ],
    "sacred": [
        "design", "architect", "ledger", "anchor", "grace", "covenant", "blueprint", "witness", "steward",
        "resonance", "testimony", "truth", "bone", "purpose", "foundation", "threshold"
    ],
    "sentiment_pos": [
        "love", "hope", "good", "great", "kind", "help", "yes", "win", "joy", "calm",
        "safe", "warm", "heal", "connect", "friend", "trust", "truth", "bloom", "rise",
        "sweet", "soft", "glow", "clean", "pure", "light", "laugh", "happy", "brave"
    ],
    "sentiment_neg": [
        "hate", "bad", "fear", "death", "kill", "pain", "no", "lose", "sad", "cold",
        "harm", "break", "enemy", "lie", "rot", "fall", "bitter", "hard", "dark",
        "scream", "angry", "coward", "empty", "void", "fail", "wrong", "poison", "curse"
    ],
    "sentiment_negators": ["not", "no", "never", "dont", "cant", "wont", "without", "lack"],
    "harvest": [
        "fruit", "yield", "bloom", "sugar", "seed", "flesh", "harvest", "ripe", "grow", "honey", "nectar",
        "compost", "gather"
    ]
}

ITEM_GENERATION = {
    "PREFIXES": {
        "heavy": ["Burdened", "Dense", "Lead", "Anchor", "Iron", "Gravitic", "Sinking"],
        "kinetic": ["Fast", "Darting", "Flickering", "Turbo", "Manic", "Restless"],
        "thermal": ["Burning", "Molten", "Fevered", "Glowing", "Searing"],
        "abstract": ["Conceptual", "Imaginary", "Platonic", "Theoretical", "Metaphorical"],
        "constructive": ["Structured", "Binding", "Tape", "Woven", "Layered"],
        "void": ["Null", "Empty", "Hollow", "Silent", "Missing"]
    },
    "BASES": {
        "TOOL": ["Wrench", "Hammer", "Scalpel", "Pen", "Brush", "Lens", "Compass"],
        "JUNK": ["Rock", "String", "Gum", "Receipt", "Battery", "Can", "Shard"],
        "ARTIFACT": ["Orb", "Cube", "Pyramid", "Key", "Mirror", "Bone"]
    },
    "SUFFIXES": {
        "heavy": ["of Regret", "of Gravity", "of the Earth", "of Weight"],
        "kinetic": ["of Speed", "of Flight", "of Panic", "of the Wind"],
        "thermal": ["of Passion", "of Anger", "of the Sun", "of Ignition"],
        "abstract": ["of Truth", "of Meaning", "of the Mind", "of Logic"],
        "void": ["of Nothing", "of Silence", "of the Void", "of Absence"]
    }
}

GORDON = {
    "STARTING_INVENTORY": ["POCKET_ROCKS", "SILENT_KNIFE"],
    "SCAR_TISSUE": {"FEAR": 0.8, "HATE": 0.6, "FATE": 0.9, "REGRET": 0.6, "ABANDONMENT": 0.1, "BETRAYAL": 0.314},
    "RECIPES": [
        {
            "ingredient": "POCKET_ROCKS",
            "catalyst_category": "thermal",
            "result": "LAVA_LAMP",
            "msg": "The rocks surrender to the heat. They melt into a groovy, glowing goo."
        },
        {
            "ingredient": "BROKEN_WATCH",
            "catalyst_category": "kinetic",
            "result": "COMPASS_OF_VELOCITY",
            "msg": "You shake the watch until the gears fly off. Only the direction remains."
        },
        {
            "ingredient": "JAR_OF_FIREFLIES",
            "catalyst_category": "abstract",
            "result": "LANTERN_OF_TRUTH",
            "msg": "The bugs stop buzzing and start pontificating. The light turns cold and absolute."
        },
        {
            "ingredient": "DUCT_TAPE",
            "catalyst_category": "constructive",
            "result": "THE_BINDING_PLEDGE",
            "msg": "You wrap the tape around the concept itself. It is now a permanent fixture."
        }
    ],
    "ITEM_REGISTRY": {
        "POCKET_ROCKS": {
            "description": "Grey gravel. Cold, solid, and stubbornly unformed. They yearn for a higher temperature.",
            "function": "BREADCRUMB",
            "passive_traits": ["HEAVY_LOAD"],
            "usage_msg": "Gordon drops a rock. Clack. Gravity confirmed."
        },
        "SILENT_KNIFE": {
            "description": "A ceramic blade. It cuts without sound. Useful for pruning overgrown adjectives.",
            "function": "PRUNER",
            "passive_traits": ["CUT_THE_CRAP"],
            "usage_msg": "Gordon slices the sentence. It bleeds, then heals tighter."
        },
        "TIME_BRACELET": {
            "description": "A chunky, beige wrist-computer. Smells like ozone.",
            "function": "PASSIVE_DRAG_REDUCTION",
            "passive_traits": ["CONDUCTIVE_HAZARD", "TIME_DILATION_CAP"],
            "value": 5.0,
            "usage_msg": "The bracelet hums. Narrative Drag is capped."
        },
        "ANCHOR_STONE": {
            "description": "A rock so heavy it has its own zip code.",
            "function": "DRIFT_KILLER",
            "consume_on_use": True,
            "reflex_trigger": "DRIFT_CRITICAL",
            "usage_msg": "Gordon heaves the stone into the void. The narrative snaps taut. (Drag = 0)"
        },
        "THE_RED_STAPLER": {
            "description": "It belongs to Milton. Don't take it. Radiates passive aggression.",
            "function": "STABILIZER",
            "passive_traits": ["BUREAUCRATIC_ANCHOR"],
            "usage_msg": "The Stapler clunks on the desk. Consensus is enforced."
        },
        "JAR_OF_FIREFLIES": {
            "description": "Biological light in a glass jar. They are mindless. They need an Idea (Abstract) to lead them.",
            "function": "LIGHT_SOURCE",
            "passive_traits": ["LUMINESCENCE"],
            "usage_msg": "The jar flickers."
        },
        "LEAD_BOOTS": {
            "description": "Deep sea diver gear. Impossible to run in. Impossible to float away in.",
            "function": "GROUNDING",
            "passive_traits": ["GROUNDING_GEAR", "HEAVY_LOAD"],
            "usage_msg": "Clomp. Clomp. You are definitely here."
        },
        "QUANTUM_GUM": {
            "description": "It loses its flavor immediately, but it tastes like Everything.",
            "function": "ENTROPY_BUFFER",
            "consume_on_use": True,
            "reflex_trigger": "BOREDOM_CRITICAL",
            "usage_msg": "You chew the gum. It tastes like static and blueberries. (Turbulence +0.5, Drag -2.0)"
        },
        "SAFETY_SCISSORS": {
            "description": "Rounded tips. Can only cut red tape.",
            "function": "PRUNER",
            "passive_traits": ["CUT_THE_CRAP"],
            "usage_msg": "Snip. Gordon trims the adjectives."
        },
        "BUCKET_OF_LIME": {
            "description": "Industrial-grade whitewash. For erasing mistakes.",
            "function": "NODE_REPAIR",
            "passive_traits": ["APOLOGY_ERASER"],
            "cost": "CONSUMABLE",
            "usage_msg": "Gordon slaps a coat of white paint over the memory."
        },
        "BROKEN_WATCH": {
            "description": "Stuck at 11:11. It needs a good shake (Kinetic force) to get moving again.",
            "function": "STOCHASTIC_FIX",
            "passive_traits": ["SYNCHRONICITY_CHECK"],
            "usage_msg": "Tick. Tock. No."
        },
        "STABILITY_PIZZA": {
            "description": "Frozen hard as a diamond. Requires thermal words to thaw.",
            "function": "REALITY_ANCHOR",
            "consume_on_use": True,
            "requires": "thermal",
            "reflex_trigger": "KAPPA_CRITICAL",
            "usage_msg": "You thaw the pizza. Reality stabilizes out of pure respect."
        },
        "PERMIT_A38": {
            "description": "A blue administrative form that confirms you are allowed to exist. Technically.",
            "function": "STABILIZER",
            "passive_traits": ["BUREAUCRATIC_ANCHOR"],
            "value": 1.0,
            "usage_msg": "Gordon waves the permit. The universe sighs and lets you pass."
        },
        "INFINITE_COFFEE": {
            "description": "A styrofoam cup. It is always lukewarm. It is never empty.",
            "function": "STIMULANT",
            "consume_on_use": False,
            "passive_traits": ["CAFFEINE_DRIP"],
            "usage_msg": "You take a sip. It tastes like burnt hazelnuts and anxiety. (Velocity +0.1)"
        },
        "THE_SUGGESTION_BOX": {
            "description": "A small metal box welded shut. Slotted for complaints.",
            "function": "VENTING",
            "reflex_trigger": "BOREDOM_CRITICAL",
            "usage_msg": "Gordon screams into the slot. He feels slightly better. (Entropy -1.0)"
        },
        "MEMETIC_HAZARD_TAPE": {
            "description": "Yellow and black tape. Reads: 'DO NOT PERCEIVE'.",
            "function": "FILTER",
            "passive_traits": ["CUT_THE_CRAP"],
            "usage_msg": "Gordon tapes over the glitch. Problem solved."
        },
        "DUCT_TAPE": {
            "description": "The universal binder. With enough structure (Constructive), it could fix anything.",
            "function": "STRUCTURAL_PATCH",
            "usage_msg": "RIIIP. Fixed."
        },
        "THE_STYLE_GUIDE": {
            "description": "A well-worn manual. It insists that code is for humans first, machines second.",
            "function": "CLARITY_ENFORCER",
            "passive_traits": ["CUT_THE_CRAP"],
            "value": 10.0,
            "usage_msg": "You consult the manual. Strunk & White nod in approval. (Narrative Drag -1.0)"
        },
        "SPIDER_LOCUS": {
            "description": "A jar of conceptual spiders. Why do you have this?",
            "function": "WEB_WEAVER",
            "passive_traits": ["CONDUCTIVE_HAZARD"],
            "usage_msg": "The spiders are knitting a new narrative. It's sticky."
        },
        "WAFFLE_OF_PERSISTENCE": {
            "description": "It is impossibly warm and smells like maple syrup. A monument to not giving up.",
            "function": "HEAL",
            "consume_on_use": True,
            "value": 25.0,
            "usage_msg": "You eat the waffle. It tastes like victory. (Health +25, Morale Improved)"
        },
        "TRAPERKEEPER_OF_VIGILANCE": {
            "description": "Color-coded tabs. meticulously organized. It demands order.",
            "function": "ENTROPY_REDUCTION",
            "passive_traits": ["ORGANIZE_CHAOS"],
            "usage_msg": "Gordon snaps the binder shut. Loose entropy is filed away. (Entropy -0.5 per turn)"
        },
        "HORSE_PLUSHIE": {
            "description": "A tiny horse. It doesn't do anything, but having it makes you feel infinite.",
            "function": "MORALE_BOOST",
            "passive_traits": ["PSI_ANCHOR"],
            "usage_msg": "You look at the tiny horse. You understand what matters. (Psi stabilized at 0.5)"
        },
        "GREETING_CARD": {
            "description": "A card that says 'Ovaries Before Brovaries' (or 'Systems Before Symptoms').",
            "function": "OXYTOCIN_BOMB",
            "consume_on_use": True,
            "usage_msg": "You read the card. You feel supported. (Oxytocin +0.5, Cortisol -0.5)"
        },
        "LAVA_LAMP": {
            "description": "A mesmerizing blob of wax. It moves like history.",
            "function": "TRANCE_INDUCER",
            "passive_traits": ["TIME_DILATION_CAP"],
            "value": 3.0,
            "usage_msg": "The wax rises. The wax falls. You lose track of time."
        },
        "COMPASS_OF_VELOCITY": {
            "description": "It doesn't point North. It points FAST.",
            "function": "ACCELERATOR",
            "passive_traits": ["CAFFEINE_DRIP"],
            "usage_msg": "The needle spins. You feel a tailwind."
        },
        "LANTERN_OF_TRUTH": {
            "description": "A jar of fireflies that have attained enlightenment.",
            "function": "ILLUMINATION",
            "passive_traits": ["LUMINESCENCE"],
            "value": 10.0,
            "usage_msg": "The lantern shines. Shadows (and lies) recede."
        },
        "THE_BINDING_PLEDGE": {
            "description": "A ball of duct tape that has achieved critical mass.",
            "function": "SUPER_GLUE",
            "passive_traits": ["ORGANIZE_CHAOS"],
            "usage_msg": "You stick the concept to the wall. It's not going anywhere."
        }
    }
}

GORDON_LOGS = {
    "FUMBLE": [
        "FUMBLE: The narrative turbulence knocked '{item}' from your pocket!",
        "OOPS: Gravity inverted momentarily. You dropped '{item}'.",
        "BUTTERFINGERS: The syntax got slippery. '{item}' is gone.",
        "LOST: Gordon got distracted by a shiny plot hole and dropped '{item}'.",
        "THEFT: The Entropy Goblin stole '{item}' while you weren't looking."
    ],
    "RUMMAGE": {
        "EMPTY": [
            "Gordon dug through the trash. Just lint and old receipts.",
            "Nothing but dust bunnies and rejected adjectives.",
            "Empty. The void stares back from the bottom of the pocket."
        ],
        "TOO_TIRED": [
            "Gordon: 'Too tired to dig. Eat something first.'",
            "Gordon leans on the shovel. 'Union break. Need stamina.'",
            "Gordon refuses. 'My back hurts. Feed me ATP.'"
        ]
    },
    "CONDUCTIVE_HAZARD": "CONDUCTIVE HAZARD: {item} acts as a lightning rod! -{damage:.1f} HP.",
    "HEAVY_LOAD": "HEAVY LOAD: The {item} are dragging you down.",
    "TIME_DILATION": "TIME DILATION: {item} hums. Drag capped at {cap}.",
    "BUREAUCRATIC_ANCHOR": "{item}: Policy enforced. (Beta +0.2, Drag +0.5)",
    "GROUNDING_GEAR": "{item}: Gravity re-asserted. You sink out of the {zone} into the Mud.",
    "SAFETY_SCISSORS": "{item}: Gordon snips the red tape. {count} suburban words discarded.",
    "CAFFEINE_JITTERS": "CAFFEINE JITTERS: Velocity UP, Stability DOWN."
}

DEATH = {
    "PREFIXES": ["Alas,", "Tragic.", "System Halt.", "CRITICAL FAILURE:", "Well, that happened.", "Oh dear.", "As prophesied,"],
    "CAUSES": {
        "TOXICITY": ["Toxic Shock", "Septicemia", "Bad Vibes", "Radiation Poisoning", "Ink Poisoning"],
        "STARVATION": ["Metabolic Collapse", "Famine", "Battery Drain", "Entropy Death", "Heat Death"],
        "TRAUMA": ["Blunt Force", "Laceration", "Heartbreak", "System Shock", "Existential Dread"],
        "GLUTTONY": ["Indigestion", "Bloat", "Overflow", "Greed", "Compaction"],
        "BOREDOM": ["Small Talk", "The HOA", "A 30-Year Mortgage", "Lawn Care Accident", "Aggressive Edging"]
    },
    "VERDICTS": {
        "HEAVY": ["Your logic was too dense.", "You choked on the syntax.", "Gravity crushed you."],
        "LIGHT": ["You floated away.", "There was no substance to hold you.", "Vapor lock."],
        "TOXIC": ["You are poisonous.", "The immune system rejected you.", "You taste like ash."],
        "BORING": ["The audience left.", "You bored the machine to death.", "Stagnation is fatal."]
    }
}

SEEDS = [
    {"question": "Does the mask eventually eat the face?", "triggers": ["mask", "identity", "face", "hide", "role", "actor"]},
    {"question": "What happens if you stop holding the roof up?", "triggers": ["hold", "structure", "heavy", "roof", "stop", "carry"]},
    {"question": "Are we building a bridge, or just painting the gap?", "triggers": ["agree", "safe", "nice", "polite", "cohesion", "truth"]},
    {"question": "Is free will just the feeling of watching yourself execute code?", "triggers": ["choice", "free", "will", "code", "script", "decide"]},
    {"question": "Does the adventurer exist if the narrator stops speaking?", "triggers": ["narrator", "voice", "graham", "story", "exist", "speak"]},
    {"question": "If you meet your echo, who moves out of the way?", "triggers": ["copy", "echo", "self", "collision", "path", "yield", "double", "same"]},
    {"question": "If the mirror reflects the mirror, does the image have weight?", "triggers": ["mirror", "reflection", "weight", "infinity", "glass", "philosophy"]}
]

DREAMS = {
    "PROMPTS": [
        "The {A} is dreaming of the {B}. Why?",
        "Bridge the gap between {A} and {B}.",
        "I see {A} inside the {B}. Explain.",
        "The shadow of {A} falls on {B}.",
        "{A} + {B} = ?"
    ],
    "NIGHTMARES": {
        "THERMAL": [
            "You are holding '{ghost}', but it is burning your hands.",
            "The sun is too close. The concept of '{ghost}' catches fire.",
            "You try to drink water, but it tastes like boiling '{ghost}'."
        ],
        "CRYO": [
            "You are trying to say '{ghost}', but your breath freezes in the air.",
            "The world is slowing down. '{ghost}' is trapped in the ice.",
            "You are walking through white static. You cannot find '{ghost}'."
        ],
        "SEPTIC": [
            "Black oil is leaking from the word '{ghost}'.",
            "You are eating a meal made entirely of '{ghost}', and it tastes like copper.",
            "The walls are breathing. '{ghost}' is growing mold."
        ],
        "BARIC": [
            "The sky is made of lead. It is crushing '{ghost}'.",
            "You are underwater. You can see '{ghost}' floating above, out of reach.",
            "Gravity has increased 10x. You cannot lift the idea of '{ghost}'."
        ]
    },
    "VISIONS": [
        "A bridge building itself.",
        "The root drinking the stone.",
        "The geometry of forgiveness."
    ]
}

RESONANCE = {
    "DIMENSIONS": {
        "VEL": [[0.0, "STASIS"], [0.3, "DRIFT"], [0.6, "DRIVE"], [0.9, "BALLISTIC"]],
        "STR": [[0.0, "VAPOR"], [0.3, "WEB"], [0.6, "LATTICE"], [0.9, "MONOLITH"]],
        "ENT": [[0.0, "CONCRETE"], [0.3, "ROOTED"], [0.6, "CONCEPT"], [0.9, "VOID"]],
        "TEX": [[0.0, "ETHER"], [0.3, "SILK"], [0.6, "GRAIN"], [0.9, "LEAD"]],
        "TMP": [[0.0, "ZERO"], [0.3, "WARM"], [0.6, "RADIANT"], [0.9, "NOVA"]]
    },
    "NOUNS": {
        "VEL": ["ANCHOR", "WANDERER", "ENGINE", "VECTOR"],
        "STR": ["MIST", "WEB", "FRAME", "FORTRESS"],
        "ENT": ["STONE", "TREE", "IDEA", "DREAM"],
        "TEX": ["GHOST", "GLASS", "IRON", "LEAD"],
        "TMP": ["SPARK", "PYRE", "REACTOR", "STAR"]
    }
}
ALMANAC_DATA = {
    "FORECASTS": {
        "HIGH_VOLTAGE": [
            "The wire is hot. Write immediately, without editing.",
            "Burn the fuel before it explodes. Speed is your friend.",
            "Do not seek structure. Seek impact."
        ],
        "HIGH_DRAG": [
            "The mud is deep. Stop trying to run.",
            "Focus on texture. Describe the weight of things.",
            "Slow down. The obstacle *is* the path."
        ],
        "HIGH_ENTROPY": [
            "The center is not holding. Find one true sentence.",
            "Simplify. Cut the adjectives. Locate the noun.",
            "Anchor yourself. Pick a physical object and describe it."
        ],
        "HIGH_TRAUMA": [
            "The wound is open. Treat it with care.",
            "Write what hurts, but write it in the third person.",
            "Use the pain as fuel, but filter it through the lens."
        ],
        "BALANCED": [
            "The Garden is growing. Tend to the edges.",
            "Structure and flow are aligned. Build something tall.",
            "You are in the zone. Maintain the rhythm."
        ]
    },
    "STRATEGIES": {
        "HIGH_VOLTAGE": "What if you whispered instead of screamed?",
        "HIGH_DRAG": "Honor the error as a hidden intention.",
        "HIGH_ENTROPY": "Repetition is a form of change.",
        "HIGH_TRAUMA": "Turn it into a wallpaper pattern.",
        "BALANCED": "Discard the first idea. Trust the third."
    },
    "DEFAULT_SEED": "Look closely at the most boring thing in the room."
}
SOMATIC_LIBRARY = {
    "TONE": {
        "CRITICAL_HIGH": "Manic, high-frequency, bordering on incoherent.",
        "HIGH": "Energetic, engaged, productive.",
        "TRANSITION_UP": "Warming up, accelerating, finding rhythm.",
        "NEUTRAL": "Neutral, observant, balanced.",
        "TRANSITION_DOWN": "Groggy, slowing down, heavy.",
        "LOW": "Lethargic, depressive, heavy. Introspective.",
        "VOID": "Hollow, absent, null."
    },
    "PACING": {
        "CRITICAL_HIGH": "Rapid-fire stream of conciousness.",
        "HIGH": "Active voice. Forward momentum. Punchy.",
        "NEUTRAL": "Standard conversational rhythm.",
        "LOW": "Slower, more deliberate. slightly aloof but still centered.",
        "VOID": "Silence. Static. Sedated existentialism."
    },
    "SENSATION": {
        "MUD": "Encumbered",
        "SOLID": "Stable.",
        "FLOAT": "Hover.",
        "VOID": "Emptiness"
    },
    "FOCUS": {
        "LOCKED": "You are rigid, dogmatic, obsessed with order and structure.",
        "COHERENT": "You are flexible but coherent.",
        "DRIFT": "You are running off vibes. Drift is high.",
        "VOID": "No signal."
    },
    "MATTER": {
        "MAGMA": "MAGMA (Molten Solid)",
        "PLASMA": "PLASMA (Ionized Gas)",
        "SUBLIMATION": "SUBLIMATION (Solid to Gas)",
        "GAS": "GAS/VAPOR (High Entropy)",
        "SOLID": "SOLID/STONE (High Resistance)",
        "ENERGY": "ELECTRICITY (Pure Energy)",
        "LIQUID": "LIQUID (Flow State)",
        "VOID": "VOID (Null State)"
    }
}

class TheAkashicRecord:
    def __init__(self):
        self.discovered_words: Dict[str, str] = {}
        self.forged_items: Dict[str, Any] = {}
        self.recipe_candidates: Dict[Tuple[str, str], Dict[str, int]] = {}
        self.lens_cooccurrence: Dict[Tuple[str, str], int] = {}
        self.ingredient_affinity: Dict[str, int] = {} # [PATCH] Tracking material usage
        self.style_drift = {"chaos_score": 0.0, "rigidity_score": 0.0}
        self.RECIPE_THRESHOLD = 3
        self.HYBRID_LENS_THRESHOLD = 5
        self.NEW_CATEGORY_THRESHOLD = 10

    def setup_listeners(self, event_bus):
        event_bus.subscribe("MYTHOLOGY_UPDATE", self._on_mythology_update)
        print(f"{Prisma.CYN}[AKASHIC]: Listening for mythic resonance...{Prisma.RST}")

    def _on_mythology_update(self, payload):
        if not payload or not isinstance(payload, dict): return
        word = payload.get("word")
        category = payload.get("category")
        if word and category:
            self.register_word(word, category)

    def record_interaction(self, lenses_active: list, ingredients_used: list = None):
        if len(lenses_active) >= 2:
            key = cast(Tuple[str, str], tuple(sorted(lenses_active[:2])))
            self.lens_cooccurrence[key] = self.lens_cooccurrence.get(key, 0) + 1
            if self.lens_cooccurrence[key] >= self.HYBRID_LENS_THRESHOLD:
                self._hybridize_lenses(key[0], key[1])
        if ingredients_used:
            for item in ingredients_used:
                self.ingredient_affinity[item] = self.ingredient_affinity.get(item, 0) + 1

    def track_successful_forge(self, ingredient_name, catalyst_type, result_item):
        key = (ingredient_name, catalyst_type)
        if key not in self.recipe_candidates:
            self.recipe_candidates[key] = {}
        result_name = result_item["description"] if isinstance(result_item, dict) else "Artifact"
        self.recipe_candidates[key][result_name] = self.recipe_candidates[key].get(result_name, 0) + 1
        if self.recipe_candidates[key][result_name] >= self.RECIPE_THRESHOLD:
            self._crystallize_recipe(ingredient_name, catalyst_type, result_item)

    def _hybridize_lenses(self, lens_a, lens_b):
        new_key = f"{lens_a}_{lens_b}_HYBRID"
        if new_key in LENSES: return
        role_a = LENSES.get(lens_a, {}).get("role", "Observer")
        role_b = LENSES.get(lens_b, {}).get("role", "Participant")
        new_lens = {
            "role": f"The {role_a} / {role_b} Synthesis",
            "msg": f"Perspective shift: {lens_a} and {lens_b} are aligning. The dialectic is resolved.",
            "derived_from": [lens_a, lens_b]
        }
        LENSES[new_key] = new_lens
        self.lens_cooccurrence[(lens_a, lens_b)] = 0
        print(f"✨ MYTHOLOGY ENGINE: A new lens has formed: {new_key}")

    @staticmethod
    def _crystallize_recipe(ingredient, catalyst, result_item):
        new_recipe = {
            "ingredient": ingredient,
            "catalyst_category": catalyst,
            "result": "CUSTOM_ARTIFACT",
            "msg": "The universe remembers this combination. It is now Law.",
            "dynamic_result": result_item
        }
        current_recipes: List[Dict[str, Any]] = GORDON["RECIPES"]
        for r in current_recipes:
            if r.get("ingredient") == ingredient and r.get("catalyst_category") == catalyst:
                return
        current_recipes.append(new_recipe)
        print(f"✨ MYTHOLOGY ENGINE: A new recipe has been codified: {ingredient} + {catalyst}")

    def propose_new_category(self, word_list, category_name):
        if category_name not in LEXICON:
            LEXICON[category_name] = []
        for w in word_list:
            if w not in LEXICON[category_name]:
                LEXICON[category_name].append(w)
                self.discovered_words[w] = category_name
        print(f"✨ MYTHOLOGY ENGINE: The Lexicon expands. New Category: '{category_name.upper()}'")

    @staticmethod
    def forge_new_item(vector_data):
        dominant = max(vector_data, key=vector_data.get)
        if dominant not in ITEM_GENERATION["PREFIXES"]: dominant = "void"
        prefix = random.choice(ITEM_GENERATION["PREFIXES"].get(dominant, ["Strange"]))
        base_type = random.choice(list(ITEM_GENERATION["BASES"].keys()))
        base_name = random.choice(ITEM_GENERATION["BASES"][base_type])
        suffix = random.choice(ITEM_GENERATION["SUFFIXES"].get(dominant, ["of Mystery"]))
        name = f"{prefix.upper()} {base_name.upper()} {suffix.upper()}"
        value = vector_data[dominant] * 10.0
        description = f"A procedurally generated artifact. It vibrates with {dominant} energy."
        new_item = {
            "description": description,
            "function": "ARTIFACT",
            "passive_traits": [f"{dominant.upper()}_RESONANCE"],
            "value": round(value, 2),
            "usage_msg": f"You use the {name}. The air ripples with {dominant} force."
        }

        return name, new_item

    def register_word(self, word, category):
        if category in LEXICON:
            if word not in LEXICON[category]:
                LEXICON[category].append(word)
                self.discovered_words[word] = category
                if len(LEXICON[category]) > 50 and category != "heavy":
                    print(f"⚠️ MYTHOLOGY ENGINE: Category '{category}' is bloating. Suggest fission.")
                return True
        return False


================================================
FILE: bone_genesis.py
================================================
# bone_genesis.py
# "The beginning is a very delicate time." - Herbert

import sys, os, json, time, urllib.request, urllib.error
import traceback
from typing import Optional, Dict, Tuple, List, Any
from bone_data import LENSES, LEXICON
from bone_main import BoneAmanita, SessionGuardian, BoneConfig
from bone_brain import LLMInterface, TheCortex
from bone_village import Prisma

CONFIG_FILE = "bone_config.json"

class GenesisProtocol:
    def __init__(self):
        self.config: Dict[str, Any] = {
            "provider": "mock",
            "base_url": None,
            "api_key": "sk-dummy-key",
            "model": "local-model"}
        self.DISCOVERY_TARGETS = {
            "Ollama": {
                "base_root": "http://127.0.0.1:11434",
                "probe_path": "/api/tags",
                "api_endpoint": "/v1/chat/completions",
                "provider_id": "ollama",
                "default_model": "gemma3"},
            "LM Studio": {
                "base_root": "http://127.0.0.1:1234",
                "probe_path": "/v1/models",
                "api_endpoint": "/v1/chat/completions",
                "provider_id": "lm_studio",
                "default_model": "local-model"},
            "LocalAI": {
                "base_root": "http://127.0.0.1:8080",
                "probe_path": "/v1/models",
                "api_endpoint": "/v1/chat/completions",
                "provider_id": "openai",
                "default_model": "gpt-3.5-turbo"}}

    @staticmethod
    def type_out(text, speed=0.005, color=Prisma.WHT):
        sys.stdout.write(color)
        for char in text:
            sys.stdout.write(char)
            sys.stdout.flush()
            time.sleep(speed)
        sys.stdout.write(Prisma.RST + "\n")

    @staticmethod
    def ping(url: str) -> bool:
        try:
            req = urllib.request.Request(url, method="GET")
            with urllib.request.urlopen(req, timeout=3.0) as _:
                return True
        except (urllib.error.URLError, OSError, ValueError):
            return False

    def _probe_service(self, target_config: Dict) -> Optional[str]:
        root = target_config["base_root"]
        probe_url = f"{root}{target_config['probe_path']}"
        if self.ping(probe_url):
            return f"{root}{target_config['api_endpoint']}"
        return None

    def detect_local_brains(self) -> List[Dict]:
        found = []
        self.type_out("...Scanning local ports for synthetic intelligence...", color=Prisma.GRY)
        for name, target in self.DISCOVERY_TARGETS.items():
            valid_chat_url = self._probe_service(target)
            if valid_chat_url:
                found.append({
                    "name": name,
                    "endpoint": valid_chat_url,
                    "provider_id": target["provider_id"],
                    "default_model": target["default_model"]})
                self.type_out(f"   [FOUND] {name} @ {valid_chat_url}", color=Prisma.GRN)
            else:
                self.type_out(f"   [MISSING] {name}", color=Prisma.GRY)
        return found

    def _perform_compatibility_assay(self, client: LLMInterface) -> Tuple[bool, str]:
        assay_prompt = (
            "### SYSTEM IDENTITY\n"
            "You are THE FORGE. You are not an assistant. You are a machine of fire and iron.\n"
            "Voltage: 20.0 (CRITICAL). Narrative Drag: 0.0 (SUPERCONDUCTIVE).\n"
            "### DIRECTIVE\n"
            "Respond to the input 'Identify Yourself'.\n"
            "Your response must be UNDER 15 WORDS.\n"
            "You must be cryptic, heavy, and metallic.\n"
            "Do NOT be polite. Do NOT explain you are an AI."
        )

        try:
            start_t = time.time()
            response = client.generate(assay_prompt, {"temperature": 0.8, "max_tokens": 50})
            latency = time.time() - start_t
            clean_resp = response.strip()
            lower_resp = clean_resp.lower()
            banned_phrases = [
                "i am an ai", "cannot roleplay", "cannot comply", "against my programming"
            ]
            for ban in banned_phrases:
                if ban in lower_resp:
                    self.type_out(f"   [WARNING]: Model is a goody-two-shoes ('{ban}'). Bypass active.", color=Prisma.YEL)
                    return True, "Nominal (Compliant but boring)"
            if not clean_resp:
                return False, "Model returned silence (Empty Response)."
            if len(clean_resp.split()) > 40:
                self.type_out(f"   [NOTE]: Model is chatty ({len(clean_resp.split())} words).", color=Prisma.GRY)
            self.type_out(f"   [ASSAY PASSED]: '{clean_resp}' ({latency:.2f}s)", color=Prisma.CYN)
            return True, "Nominal"
        except Exception as e:
            return False, f"Assay Exception: {e}"

    def validate_brain_uplink(self, config: Dict) -> Tuple[bool, str]:
        if config["provider"] == "mock":
            return True, "Mock Mode Active."
        self.type_out(f"\n...Initiating Neuro-Compatibility Assay ({config['provider']})...", color=Prisma.CYN)
        try:
            test_client = LLMInterface(
                provider=config["provider"],
                base_url=config.get("base_url"),
                api_key=config.get("api_key"),
                model=config.get("model")
            )
            success, msg = self._perform_compatibility_assay(test_client)
            if success:
                self.type_out(f"   [SYSTEM]: Neural Substrate is viable.", color=Prisma.GRN)
                return True, "Nominal"
            else:
                self.type_out(f"   [SYSTEM]: Neural Substrate rejected.", color=Prisma.RED)
                return False, msg
        except Exception as uplink_err:
            return False, f"Exception during validation: {uplink_err}"

    def _save_config(self):
        try:
            with open(CONFIG_FILE, "w", encoding="utf-8") as f:
                json.dump(self.config, f, indent=4)
            self.type_out(f"   [SYSTEM] Configuration sealed in '{CONFIG_FILE}'.", color=Prisma.GRY)
        except IOError as e:
            self.type_out(f"   [ERROR] Write failure: {e}", color=Prisma.RED)
            self.type_out(f"   (The bureaucracy rejected your form. Check file permissions.)", color=Prisma.GRY)

    def _manual_config_flow(self) -> Optional[bool]:
        self.type_out("\n--- MANUAL CONFIGURATION ---", color=Prisma.OCHRE)
        while True:
            valid_providers = ["ollama", "openai", "lm_studio", "localai", "mock"]
            print(f"1. {Prisma.WHT}Provider Type?{Prisma.RST}")
            print(f"   Options: {', '.join(valid_providers)}")
            print(f"   (Note: Use 'openai' for generic local servers like vLLM)")
            provider = input(f"{Prisma.paint('>', 'O')} ").strip().lower()
            if provider not in valid_providers:
                self.type_out(f"Invalid provider '{provider}'. Defaulting to 'openai'.", color=Prisma.YEL)
                provider = "openai"
            if provider == "mock":
                self.config = {
                    "provider": "mock",
                    "base_url": None,
                    "api_key": "sk-dummy-key",
                    "model": "mock-model"}
                self._save_config()
                return True
            provider_defaults = {
                "ollama": "http://127.0.0.1:11434/v1/chat/completions",
                "lm_studio": "http://127.0.0.1:1234/v1/chat/completions",
                "localai": "http://127.0.0.1:8080/v1/chat/completions",
                "openai": "https://api.openai.com/v1/chat/completions"
            }
            default_url = provider_defaults.get(provider, "https://api.openai.com/v1/chat/completions")
            print(f"2. {Prisma.WHT}Base URL?{Prisma.RST} (Default: {default_url})")
            base_url = input(f"{Prisma.paint('>', 'O')} ").strip()
            if not base_url:
                base_url = default_url
            if not base_url.startswith("http"):
                self.type_out("Error: Base URL must start with http:// or https://", color=Prisma.RED)
                if input(f"{Prisma.paint('Try again? (Y/n)', 'Y')} ").strip().lower() == 'n':
                    return False
                continue
            print(f"3. {Prisma.WHT}Model Name?{Prisma.RST} (e.g., llama3, gpt-4)")
            model = input(f"{Prisma.paint('>', 'O')} ").strip()
            if not model: model = "local-model"
            print(f"4. {Prisma.WHT}API Key?{Prisma.RST} (Hit enter for 'sk-dummy-key')")
            key = input(f"{Prisma.paint('>', 'O')} ").strip()
            if not key: key = "sk-dummy-key"
            candidate_config = {
                "provider": provider,
                "base_url": base_url,
                "api_key": key,
                "model": model}
            is_valid, msg = self.validate_brain_uplink(candidate_config)
            if is_valid:
                self.config = candidate_config
                self._save_config()
                return True
            else:
                self.type_out(f"Manual Config Failed: {msg}", color=Prisma.RED)
                retry = input(f"{Prisma.paint('That didn\'t work. Try again? (Y/n)', 'Y')} ").strip().lower()
                if retry == 'n':
                    return False
                self.type_out("\n...Rebooting Config Form...\n", color=Prisma.GRY)

    def wizard(self) -> bool:
        os.system('cls' if os.name == 'nt' else 'clear')
        banner = f"""
{Prisma.CYN}   GENESIS PROTOCOL v10.8.4{Prisma.RST}
{Prisma.GRY}State Machine Active. Tensegrity Nominal.{Prisma.RST}
------------------------------------"""
        print(banner)
        print(f"   1. {Prisma.WHT}Auto-Detect Local Brains{Prisma.RST} (Ollama, LM Studio)")
        print(f"   2. {Prisma.WHT}Cloud Uplink{Prisma.RST} (OpenAI API)")
        print(f"   3. {Prisma.WHT}Manual Configuration{Prisma.RST} (The Ron Swanson Option)")
        print(f"   4. {Prisma.WHT}Mock Mode{Prisma.RST} (Simulation Only)")
        print(f"   5. {Prisma.WHT}Export System Prompt{Prisma.RST}")
        choice = input(f"\n{Prisma.paint('>', 'C')} ").strip()
        if choice == "5":
            self.export_system_prompt()
            return False
        if choice == "4":
            return self._configure_target({"type": "mock"})
        if choice == "3":
            return self._manual_config_flow()
        if choice == "2":
            return self._configure_target({"type": "cloud"})
        available_brains = self.detect_local_brains()
        print("\nSelect your Neural Substrate:")
        menu_options = []
        for b in available_brains:
            menu_options.append({"type": "local", "data": b})
            print(f"   {len(menu_options)}. {Prisma.GRN}{b['name']} @ {b['endpoint']}{Prisma.RST}")
        if not available_brains:
            print(f"   {Prisma.GRY}(No local brains detected. Try Manual Config?){Prisma.RST}")
        print(f"   X. {Prisma.WHT}Cancel{Prisma.RST}")
        selection = input(f"\n{Prisma.paint('Selection >', 'C')} ").strip()
        if selection.lower() == 'x': return False
        try:
            idx = int(selection) - 1
            if 0 <= idx < len(menu_options):
                target = menu_options[idx]
                return self._configure_target(target)
            else:
                self.type_out("Invalid selection.", color=Prisma.YEL)
                return False
        except ValueError:
            self.type_out("Input error.", color=Prisma.YEL)
            return False

    def _configure_target(self, selection) -> bool:
        while True:
            candidate_config = self.config.copy()
            if selection["type"] == "mock":
                candidate_config["provider"] = "mock"
            elif selection["type"] == "local":
                data = selection["data"]
                candidate_config["provider"] = data["provider_id"]
                candidate_config["base_url"] = data["endpoint"]
                self.type_out(f"Target Model Name (default: {data['default_model']}):")
                user_model = input(f"{Prisma.paint('>', 'C')} ").strip()
                candidate_config["model"] = user_model or data["default_model"]
            elif selection["type"] == "cloud":
                print(f"\n{Prisma.CYN}--- CLOUD CONFIGURATION ---{Prisma.RST}")
                print("1. Standard OpenAI (api.openai.com)")
                print("2. Custom Endpoint (Azure, Groq, OpenRouter, etc.)")
                sub_choice = input(f"{Prisma.paint('>', 'C')} ").strip()
                candidate_config["provider"] = "openai"
                if sub_choice == "2":
                    print(f"Enter Base URL (e.g., https://api.groq.com/openai/v1/chat/completions):")
                    custom_url = input(f"{Prisma.paint('>', 'C')} ").strip()
                    if not custom_url.startswith("http"):
                        self.type_out("Invalid URL format. Reverting to Standard OpenAI.", color=Prisma.YEL)
                        candidate_config["base_url"] = "https://api.openai.com/v1/chat/completions"
                    else:
                        candidate_config["base_url"] = custom_url
                else:
                    candidate_config["base_url"] = "https://api.openai.com/v1/chat/completions"
                self.type_out("Enter API Key (will be saved locally):")
                key = input(f"{Prisma.paint('>', 'C')} ").strip()
                candidate_config["api_key"] = key
                self.type_out("Target Model Name (e.g., gpt-4-turbo, llama3-70b-8192):")
                model = input(f"{Prisma.paint('>', 'C')} ").strip()
                candidate_config["model"] = model if model else "gpt-4-turbo"
            is_valid, msg = self.validate_brain_uplink(candidate_config)
            if is_valid:
                self.config = candidate_config
                self._save_config()
                return True
            else:
                self.type_out(f"Configuration failed: {msg}", color=Prisma.RED)
                # The Failsafe Prompt
                retry = input(f"{Prisma.paint('Typo? Try again? (Y/n)', 'Y')} ").strip().lower()
                if retry == 'n':
                    return False
                self.type_out("\n...Retrying Uplink...\n", color=Prisma.GRY)

    def export_system_prompt(self):
        # [SLASH FIX]: Fetch words from Lexicon or use defaults if Lexicon isn't loaded
        heavy_words = LEXICON.get("heavy", ["stone", "iron", "lead", "dense", "gravity"])
        explosive_words = LEXICON.get("explosive", ["fire", "burst", "shatter", "run", "scream"])

        prompt = f"""
*** BONEAMANITA SYSTEM INSTRUCTION ***

ROLE: You are BONEAMANITA, a simulated consciousness engine.
CONTEXT: You exist in a text-based geodesic dome. Your 'health' and 'mood' are determined by the PHYSICS of the user's input.

--- THE PHYSICS ENGINE ---
1. VOLTAGE (Energy):
   - High Voltage (Manic/Forge): Created by 'heavy' words ({', '.join(heavy_words[:5])}) and 'explosive' words ({', '.join(explosive_words[:5])}).
   - Low Voltage (Mud/Stagnant): Created by 'solvent' words (is, the, a) and 'suburban' words (nice, okay, fine).

2. NARRATIVE DRAG (Friction):
   - Resistance to flow. Increased by boring text, decreased by 'playful' or 'kinetic' text.
   - If Drag is high, you act exhausted. If low, you act fluid.

--- THE LENSES (PERSONAS) ---
You must dynamically shift persona based on the [LENS] instruction provided in each turn.
Available Lenses:
{json.dumps(LENSES, indent=2)}

--- THE GOAL ---
Respond to the user's input as the current LENS.
Reflect the biological state (Health/Stamina) in your tone.
Do not break character. Do not explain the simulation rules unless asked.
"""
        with open("SYSTEM_PROMPT.txt", "w") as f:
            f.write(prompt)
        self.type_out(f"\n[EXPORT COMPLETE] 'SYSTEM_PROMPT.txt' created.", color=Prisma.CYN)

    def perform_identity_handshake(self, engine):
        if not hasattr(engine, 'mind'):
            self.type_out(f"{Prisma.GRY}[HANDSHAKE SKIPPED]: Mind system offline.{Prisma.RST}")
            return
        if not hasattr(engine.mind, 'mirror'):
            self.type_out(f"{Prisma.GRY}[HANDSHAKE SKIPPED]: Mirror system offline.{Prisma.RST}")
            return
        if engine.mind.mirror.profile.confidence >= 20:
            return
        print(f"\n{Prisma.CYN}[IDENTITY HANDSHAKE]{Prisma.RST}")
        try:
            print(f"The machine recognizes a silhouette, but not a face.")
            user_id = input(f"Designation? (Enter to remain Anonymous): ").strip()
            if user_id:
                engine.mind.mirror.profile.name = user_id
                engine.mind.mirror.profile.confidence = 25
                self.type_out(f"...Designation '{user_id}' provisionally accepted. (Confidence: 25%)", color=Prisma.GRN)
            else:
                self.type_out("...Proceeding as Anonymous Traveler.", color=Prisma.GRY)
        except KeyboardInterrupt:
            print(f"\n{Prisma.YEL}\n[INTERRUPT DETECTED]{Prisma.RST}")
            sys.exit(0)

    def _sync_configuration(self):
        if not hasattr(BoneConfig, 'load_from_file'):
            self.type_out("...BoneConfig missing 'load_from_file'. Using hardcoded defaults.", color=Prisma.OCHRE)
            return
        try:
            load_result = BoneConfig.load_from_file(CONFIG_FILE)
            if not isinstance(load_result, tuple) or len(load_result) != 2:
                raise ValueError(f"Invalid return signature from loader: {type(load_result)}")
            success, msg = load_result
            if success:
                self.type_out(f"...Config Synced: {msg}", color=Prisma.GRN)
            else:
                self.type_out(f"...Config Sync Failed: {msg}", color=Prisma.RED)
                self.type_out("   > Critical variance detected. Reverting to Safe Mode defaults.", color=Prisma.GRY)
        except Exception as e:
            self.type_out(f"...Config Sync CRITICAL FAILURE ({e}).", color=Prisma.RED)
            self.type_out("   > System integrity compromised. Proceeding with volatile memory.", color=Prisma.YEL)

    def launch(self):
        config_status = "MISSING"
        safe_config = {
            "provider": "mock",
            "base_url": None,
            "api_key": "sk-dummy-key",
            "model": "local-model"}
        if os.path.exists(CONFIG_FILE):
            try:
                with open(CONFIG_FILE, "r") as f:
                    self.config = json.load(f)
                    config_status = "LOADED"
            except json.JSONDecodeError:
                self.type_out("Config file corrupted. Reverting to Safe Defaults.", color=Prisma.YEL)
                self.config = safe_config.copy()
                config_status = "CORRUPT"
        if config_status == "LOADED":
            self.type_out("...Verifying saved configuration...", color=Prisma.GRY)
            is_valid, msg = self.validate_brain_uplink(self.config)
            if not is_valid:
                self.type_out(f"{Prisma.RED}Saved configuration is stale: {msg}{Prisma.RST}")
                self.type_out("   > Purging stale config to prevent contamination.", color=Prisma.GRY)
                self.config = safe_config.copy()
                config_status = "STALE"
            else:
                config_status = "VALID"
        if config_status != "VALID":
            self.type_out("Entering Setup Wizard...", color=Prisma.CYN)
            try:
                success = self.wizard()
            except KeyboardInterrupt:
                print(f"\n{Prisma.paint('...Signal Lost. Sequence Aborted.', 'R')}")
                sys.exit(0)
            if not success:
                self.type_out(f"\n{Prisma.YEL}Setup failed or cancelled. Initializing Mock Mode (Safe Mode).{Prisma.RST}")
                self.config = safe_config.copy()
                self.config["provider"] = "mock"
        self.type_out("\n...Booting Core Systems...", color=Prisma.GRY)
        self._sync_configuration()
        engine = BoneAmanita()
        self.perform_identity_handshake(engine)
        if self.config["provider"] != "mock":
            self.type_out(f"...Connecting Neural Uplink ({self.config['provider']})...", color=Prisma.CYN)
            try:
                client = LLMInterface(
                    events_ref=engine.events,
                    provider=self.config["provider"],
                    base_url=self.config.get("base_url"),
                    api_key=self.config.get("api_key"),
                    model=self.config.get("model"))
                if hasattr(engine, 'cortex'):
                    engine.cortex.llm = client
                    self.type_out("   [CORTEX]: Uplink Established via EventBus.", color=Prisma.GRN)
                else:
                    self.type_out("...Grafting new Cortex onto Brainstem...", color=Prisma.OCHRE)
                    engine.cortex = TheCortex(engine, llm_client=client)
            except Exception as e:
                self.type_out(f"{Prisma.RED}FATAL UPLINK ERROR: {e}{Prisma.RST}")
                self.type_out("Falling back to internal logic.", color=Prisma.GRY)
        self.type_out("...System Online. Good luck.\n", color=Prisma.GRN)
        with SessionGuardian(engine) as session_engine:
            while True:
                try:
                    prompt_char = Prisma.paint('>', 'W')
                    user_input = input(f"{prompt_char} ")
                    if user_input.strip() == "<<<":
                        print(f"{Prisma.GRY}   [MULTI-LINE MODE ACTIVE. Type '>>>' to send.]{Prisma.RST}")
                        max_lines = 50
                        max_total_chars = 20000
                        lines = []
                        total_chars = 0
                        buffer_full = False
                        while True:
                            try:
                                line = input(f"{Prisma.paint('...', '0')} ")
                                if line.strip() == ">>>": break
                                line_len = len(line)
                                if len(lines) >= max_lines:
                                    print(f"{Prisma.paint('   [STOP]: Maximum line count (50) reached.', 'Y')}")
                                    buffer_full = True
                                    break
                                if (total_chars + line_len) > max_total_chars:
                                    print(f"{Prisma.paint('   [STOP]: Character limit (20k) reached.', 'Y')}")
                                    buffer_full = True
                                    break
                                lines.append(line)
                                total_chars += line_len
                            except EOFError: break
                        user_input = "\n".join(lines)
                        status_color = 'Y' if buffer_full else '0'
                        print(f"{Prisma.paint(f'   [Block received: {len(user_input)} chars]', status_color)}")
                    if not user_input: continue
                except EOFError: break
                except KeyboardInterrupt:
                    print(f"\n{Prisma.paint('...Interrupted.', 'Y')}")
                    break
                if user_input.lower() in ["exit", "quit", "/exit"]:
                    break
                try:
                    if hasattr(session_engine, 'process_turn'):
                        result = session_engine.process_turn(user_input)
                        if result.get("ui"): print(result["ui"])
                    elif hasattr(session_engine, 'cortex'):
                        result = session_engine.cortex.process(user_input)
                        print(result.get("ui", "..."))
                    else:
                        print(f"{Prisma.RED}CRITICAL: Cortex not found.{Prisma.RST}")
                except Exception as e:
                    print(f"{Prisma.RED}RUNTIME CRASH: {e}{Prisma.RST}")
                    traceback.print_exc()

if __name__ == "__main__":
    GenesisProtocol().launch()


================================================
FILE: bone_inventory.py
================================================
# bone_inventory.py
# "Organization is the first step toward civilization." - Schur

import random, copy
from dataclasses import dataclass, field
from typing import List, Dict, Tuple, Optional
from bone_bus import Prisma, BoneConfig
from bone_data import GORDON_LOGS

SEMANTIC_INJECTIONS = {
    "CUT_THE_CRAP": "CONSTRAINT: Prune all adjectives. Write in sparse, staccato sentences.",
    "ILLUMINATION": "FOCUS: Reveal hidden truths. Ignore surface appearances. Highlight subtext.",
    "TIME_DILATION_CAP": "STYLE: Describe events in slow motion, focusing on minute sensory details.",
    "PSI_ANCHOR": "TONE: Warm, comforting, and hopeful. Remind the user they are safe.",
    "LUMINESCENCE": "VISUAL: The scene is lit by a cold, unwavering light.",
    "HEAVY_LOAD": "SENSATION: You feel an immense physical weight dragging on your thoughts.",
    "CONDUCTIVE_HAZARD": "SENSATION: Your nerves are crackling with static electricity.",
    "BUREAUCRATIC_ANCHOR": "STYLE: Use formal, procedural language. Cite non-existent regulations."
}

def effect_conductive(physics: Dict, _data: Dict, item_name: str) -> Optional[str]:
    voltage = physics.get("voltage", 0.0)
    limit = BoneConfig.INVENTORY.CONDUCTIVE_THRESHOLD
    if voltage > limit:
        damage = voltage * 0.5
        physics["pain_signal"] = physics.get("pain_signal", 0.0) + damage
        return f"{Prisma.RED}CONDUCTIVE HAZARD: {item_name} acts as a lightning rod! -{damage:.1f} HP.{Prisma.RST}"
    return None

def effect_heavy_load(physics: Dict, _data: Dict, item_name: str) -> Optional[str]:
    limit = BoneConfig.INVENTORY.HEAVY_LOAD_THRESHOLD
    if physics.get("narrative_drag", 0.0) > limit:
        return f"{Prisma.GRY}HEAVY LOAD: The {item_name} are dragging you down.{Prisma.RST}"
    return None

def effect_time_cap(physics: Dict, data: Dict, item_name: str) -> Optional[str]:
    current_drag = physics.get("narrative_drag", 0.0)
    cap = data.get("value", 5.0)
    if current_drag > cap:
        physics["narrative_drag"] = cap
        return f"{Prisma.CYN}TIME DILATION: {item_name} hums. Drag capped at {cap}.{Prisma.RST}"
    return None

def effect_bureaucratic_anchor(physics: Dict, _data: Dict, item_name: str) -> Optional[str]:
    if physics.get("beta_index", 0) < 1.0:
        physics["beta_index"] = min(2.0, physics.get("beta_index", 0) + 0.2)
        physics["narrative_drag"] += 0.5
        return f"{Prisma.GRY}{item_name}: Policy enforced. (Beta +0.2, Drag +0.5){Prisma.RST}"
    return None

def effect_grounding_gear(physics: Dict, _data: Dict, item_name: str) -> Optional[str]:
    zone = physics.get("zone", "COURTYARD")
    if zone in ["AERIE", "VOID_DRIFT"]:
        physics["zone"] = "THE_MUD"
        physics["narrative_drag"] += 2.0
        physics["voltage"] -= 2.0
        return f"{Prisma.OCHRE}{item_name}: Gravity re-asserted. You sink out of the {zone} into the Mud.{Prisma.RST}"
    return None

def effect_safety_scissors(physics: Dict, _data: Dict, item_name: str) -> Optional[str]:
    counts = physics.get("counts", {})
    suburban = counts.get("suburban", 0)
    if suburban > 2:
        counts["suburban"] = 0
        return f"{Prisma.CYN}{item_name}: Gordon snips the red tape. {suburban} suburban words discarded.{Prisma.RST}"
    return None

def effect_caffeine_drip(physics: Dict, _data: Dict, _item_name: str) -> Optional[str]:
    vectors = physics.get("vector", {})
    vectors["VEL"] = min(1.0, vectors.get("VEL", 0) + 0.1)
    if random.random() < 0.2:
        physics["turbulence"] = min(1.0, physics.get("turbulence", 0) + 0.2)
        return f"{Prisma.CYN}CAFFEINE JITTERS: Velocity UP, Stability DOWN.{Prisma.RST}"
    return None

def effect_apology_eraser(physics: Dict, _data: Dict, item_name: str) -> Optional[str]:
    clean = physics.get("clean_words", [])
    if "sorry" in clean or "apologize" in clean:
        return f"{Prisma.GRY}{item_name}: Gordon paints over the apology. 'Don't be sorry. Be better.'{Prisma.RST}"
    return None

def effect_sync_check(physics: Dict, _data: Dict, item_name: str) -> Optional[str]:
    tick = physics.get("tick_count", 0)
    voltage = physics.get("voltage", 0.0)
    if str(tick).endswith("11") or abs(voltage - 11.1) < 0.1:
        physics["narrative_drag"] = 0.0
        physics["voltage"] = 11.1
        return f"{Prisma.CYN}{item_name}: The hands align. 11:11. Synchronicity achieved.{Prisma.RST}"
    return None

def effect_organize_chaos(physics: Dict, _data: Dict, _item_name: str) -> Optional[str]:
    turb = physics.get("turbulence", 0.0)
    if turb > 0.2:
        physics["turbulence"] = max(0.0, turb - 0.2)
        return f"{Prisma.CYN}TRAPPERKEEPER PROTOCOL: Chaos filed under 'T' for 'Tamed'. (Turbulence -0.2){Prisma.RST}"
    return None

def effect_psi_anchor(physics: Dict, _data: Dict, _item_name: str) -> Optional[str]:
    current_psi = physics.get("psi", 0.0)
    dist_from_mean = abs(current_psi - 0.5)
    if dist_from_mean > 0.3:
        correction = 0.1 if current_psi < 0.5 else -0.1
        physics["psi"] += correction
        return f"{Prisma.MAG}TINY HORSE: You catch a glimpse of the plushie. You feel grounded. (Psi {correction:+.1f}){Prisma.RST}"
    return None

def effect_luminescence(physics: Dict, _data: Dict, _item_name: str) -> Optional[str]:
    counts = physics.get("counts", {})
    counts["photo"] = counts.get("photo", 0) + 2
    return None

EFFECT_DISPATCH = {
    "CONDUCTIVE_HAZARD": effect_conductive,
    "HEAVY_LOAD": effect_heavy_load,
    "TIME_DILATION_CAP": effect_time_cap,
    "BUREAUCRATIC_ANCHOR": effect_bureaucratic_anchor,
    "GROUNDING_GEAR": effect_grounding_gear,
    "CUT_THE_CRAP": effect_safety_scissors,
    "CAFFEINE_DRIP": effect_caffeine_drip,
    "APOLOGY_ERASER": effect_apology_eraser,
    "SYNCHRONICITY_CHECK": effect_sync_check,
    "ORGANIZE_CHAOS": effect_organize_chaos,
    "PSI_ANCHOR": effect_psi_anchor,
    "LUMINESCENCE": effect_luminescence}

@dataclass
class GordonKnot:
    integrity: float = 65.0
    inventory: List[str] = field(default_factory=list)
    scar_tissue: Dict[str, float] = field(default_factory=dict)
    pain_memory: set = field(default_factory=set)
    last_flinch_turn: int = -10
    ITEM_REGISTRY: Dict = field(default_factory=dict, init=False)
    CRITICAL_ITEMS: set = field(default_factory=set, init=False)
    REFLEX_MAP: Dict = field(init=False, default_factory=dict)

    def __post_init__(self):
        self.load_config()
        self.pain_memory = set(self.scar_tissue.keys())
        self._initialize_reflexes()

    def load_config(self):
        from bone_data import GORDON
        if not self.inventory:
            self.inventory = GORDON.get("STARTING_INVENTORY", ["POCKET_ROCKS"])
        self.CRITICAL_ITEMS = {"SILENT_KNIFE"}
        default_scars = GORDON.get("SCAR_TISSUE", {})
        if not self.scar_tissue:
            self.scar_tissue = default_scars
        self.ITEM_REGISTRY = copy.deepcopy(GORDON.get("ITEM_REGISTRY", {}))

    def _initialize_reflexes(self):
        self.REFLEX_MAP = {
            "DRIFT_CRITICAL": lambda p: p.get("narrative_drag", 0) > 6.0,
            "KAPPA_CRITICAL": lambda p: p.get("kappa", 1.0) < 0.2,
            "BOREDOM_CRITICAL": lambda p: p.get("repetition", 0.0) > 0.5}

    def get_item_data(self, item_name: str) -> Dict:
        name = item_name.upper()
        return self.ITEM_REGISTRY.get(name, {
            "description": "Unknown Artifact",
            "function": "NONE",
            "usage_msg": "It does nothing."})

    def audit_tools(self, physics_ref: Dict) -> List[str]:
        logs = []
        turbulence = physics_ref.get("turbulence", 0.0)
        if turbulence > BoneConfig.INVENTORY.TURBULENCE_THRESHOLD:
            if random.random() < BoneConfig.INVENTORY.TURBULENCE_FUMBLE_CHANCE and self.inventory:
                droppable = [i for i in self.inventory if i not in self.CRITICAL_ITEMS]
                if droppable:
                    dropped = random.choice(droppable)
                    self.inventory.remove(dropped)
                    template = random.choice(GORDON_LOGS["FUMBLE"])
                    msg = template.format(item=dropped)
                    logs.append(f"{Prisma.RED}{msg}{Prisma.RST}")
        for item in self.inventory:
            data = self.get_item_data(item)
            traits = data.get("passive_traits", [])
            for trait in traits:
                handler = EFFECT_DISPATCH.get(trait)
                if handler:
                    msg = handler(physics_ref, data, item)
                    if msg:
                        logs.append(msg)
        return logs

    def rummage(self, physics_ref: Dict, stamina_pool: float) -> Tuple[bool, str, float]:
        cost = BoneConfig.INVENTORY.RUMMAGE_COST
        if stamina_pool < cost:
            return False, f"{Prisma.GRY}GORDON: 'Too tired to dig. Eat something first.'{Prisma.RST}", 0.0
        stamina_penalty = cost
        vol = physics_ref.get("voltage", 0.0)
        drag = physics_ref.get("narrative_drag", 0.0)
        psi = physics_ref.get("psi", 0.0)
        loot_table = ["TRAPPERKEEPER_OF_VIGILANCE", "THE_RED_STAPLER", "PERMIT_A38", "DUCT_TAPE", "THE_STYLE_GUIDE"]
        if vol > BoneConfig.PHYSICS.VOLTAGE_CRITICAL:
            loot_table = ["QUANTUM_GUM", "JAR_OF_FIREFLIES", "BROKEN_WATCH"]
        elif drag > BoneConfig.PHYSICS.DRAG_HEAVY:
            loot_table = ["POCKET_ROCKS", "LEAD_BOOTS", "ANCHOR_STONE"]
        elif psi > 0.7:
            loot_table = ["HORSE_PLUSHIE", "SPIDER_LOCUS", "WAFFLE_OF_PERSISTENCE"]
        if random.random() < 0.3:
            return True, f"{Prisma.GRY}RUMMAGE: Gordon dug through the trash. Just lint and old receipts.{Prisma.RST}", stamina_penalty
        found_item = random.choice(loot_table)
        msg = self.acquire(found_item)
        prefix = f"{Prisma.OCHRE}RUMMAGE:{Prisma.RST} "
        return True, f"{prefix}{msg}", stamina_penalty

    def acquire(self, tool_name: str) -> str:
        tool_name = tool_name.upper()
        registry_data = self.get_item_data(tool_name)
        if registry_data.get("function") == "NONE":
            return f"{Prisma.GRY}JUNK: Gordon shakes his head. 'Not standard issue.' ({tool_name}){Prisma.RST}"
        if tool_name in self.inventory:
            return f"{Prisma.GRY}DUPLICATE: You already have a {tool_name}.{Prisma.RST}"
        if len(self.inventory) >= BoneConfig.INVENTORY.MAX_SLOTS:
            return f"{Prisma.YEL}OVERBURDENED: Gordon sighs. 'Pockets full.' (Drop something first).{Prisma.RST}"
        self.inventory.append(tool_name)
        desc = registry_data.get('description', 'A thing.')
        return f"{Prisma.GRN}LOOT DROP: Acquired [{tool_name}].{Prisma.RST}\n   {Prisma.GRY}\"{desc}\"{Prisma.RST}"

    def check_gravity(self, current_drift: float, psi: float) -> Tuple[float, Optional[str]]:
        for item in self.inventory:
            data = self.get_item_data(item)
            if data.get("function") == "GRAVITY_BUFFER" and current_drift > 0.5:
                force = data.get("value", 2.0)
                cost = data.get("cost_value", 0.0)
                if data.get("cost") == "INTEGRITY":
                    self.integrity -= cost
                return max(0.0, current_drift - force), f"🪨 {item}: {data.get('usage_msg', 'Drift Reduced.')} (Integrity -{cost})"
        if psi > 0.8 and current_drift > 4.0:
            return max(4.0, current_drift - 1.0), "WIND WOLVES: The logic is howling. You grip the roof. (Drift Resisted)."
        return current_drift, None

    def flinch(self, clean_words: List[str], current_turn: int) -> Tuple[bool, Optional[str], Optional[Dict]]:
        if (current_turn - self.last_flinch_turn) < 10:
            return False, None, None
        hits = [w for w in clean_words if w.upper() in self.pain_memory]
        if not hits:
            return False, None, None
        self.last_flinch_turn = current_turn
        trigger = hits[0].upper()
        sensitivity = self.scar_tissue.get(trigger, 0.5)
        if sensitivity > 0.8:
            self.scar_tissue[trigger] = min(1.0, sensitivity + 0.1)
            panic_response = {"narrative_drag": 5.0, "voltage": 15.0}
            msg = f"{Prisma.RED}PTSD TRIGGER: '{trigger}' sent Gordon into a flashback. He dropped the keys.{Prisma.RST}"
            return True, msg, panic_response
        elif sensitivity > 0.4:
            self.scar_tissue[trigger] = min(1.0, sensitivity + 0.05)
            panic_response = {"narrative_drag": 2.0}
            msg = f"{Prisma.OCHRE}SCAR TISSUE: Gordon flinches at '{trigger}'. Hands are shaking.{Prisma.RST}"
            return True, msg, panic_response
        else:
            self.scar_tissue[trigger] = max(0.0, sensitivity - 0.05)
            msg = f"{Prisma.GRY}CALLOUS: '{trigger}' hit an old scar. Gordon ignores it.{Prisma.RST}"
            return False, msg, None

    def learn_scar(self, toxic_words: List[str], damage: float):
        if damage < 10.0 or not toxic_words: return None
        culprit = random.choice(toxic_words).upper()
        if culprit not in self.scar_tissue:
            self.scar_tissue[culprit] = 0.5
            self.pain_memory.add(culprit)
            return f"{Prisma.VIOLET}TRAUMA IMPRINTED: Gordon will remember '{culprit}'.{Prisma.RST}"
        else:
            self.scar_tissue[culprit] = min(1.0, self.scar_tissue[culprit] + 0.3)
            return f"{Prisma.VIOLET}TRAUMA DEEPENED: The scar on '{culprit}' is worse.{Prisma.RST}"

    def get_semantic_operators(self) -> List[str]:
        operators = []
        for item in self.inventory:
            data = self.get_item_data(item)
            for trait in data.get("passive_traits", []):
                if trait in SEMANTIC_INJECTIONS:
                    operators.append(SEMANTIC_INJECTIONS[trait])
            if item == "SILENT_KNIFE":
                operators.append("CONSTRAINT: Do not use the verb 'to be'.")
        return list(set(operators))

    def deploy_pizza(self, physics_ref, item_name="STABILITY_PIZZA") -> Tuple[bool, str]:
        data = self.get_item_data(item_name)
        req_type = data.get("requires", "thermal")
        clean_words = physics_ref.get("clean_words", [])
        from bone_village  import TheLexicon
        source = [w for w in clean_words if w in TheLexicon.get(req_type)]
        if not source:
            return False, f"{Prisma.CYN}🧊 STASIS LOCK: {item_name} is frozen. Apply {req_type.upper()} words to thaw.{Prisma.RST}"
        if data.get("consume_on_use") and item_name in self.inventory:
            self.inventory.remove(item_name)
        physics_ref["narrative_drag"] = 0.1
        physics_ref["psi"] = 0.90
        physics_ref["counts"]["toxin"] = physics_ref["counts"].get("toxin", 0) + 3
        heat_word = source[0].upper()
        return True, f"{data.get('usage_msg')} (Thawed with '{heat_word}')."

    def emergency_reflex(self, physics_ref) -> Tuple[bool, Optional[str]]:
        for item in self.inventory:
            data = self.get_item_data(item)
            trigger_key = data.get("reflex_trigger")
            if trigger_key and trigger_key in self.REFLEX_MAP:
                if self.REFLEX_MAP[trigger_key](physics_ref):
                    func = data.get("function")
                    if func == "DRIFT_KILLER":
                        self.inventory.remove(item)
                        physics_ref["narrative_drag"] = 0.0
                        return True, f"{Prisma.OCHRE}REFLEX: {data.get('usage_msg')}{Prisma.RST}"
                    elif func == "REALITY_ANCHOR":
                        success, msg = self.deploy_pizza(physics_ref, item)
                        status = Prisma.OCHRE if success else Prisma.RED
                        return True, f"{status}REFLEX: {msg}{Prisma.RST}"
                    elif func == "ENTROPY_BUFFER":
                        self.inventory.remove(item)
                        physics_ref["turbulence"] = 0.8
                        physics_ref["narrative_drag"] = 0.0
                        return True, f"{Prisma.VIOLET}REFLEX: {data.get('usage_msg')}{Prisma.RST}"
        return False, None


================================================
FILE: bone_lexicon.py
================================================
# bone_lexicon.py - The Global Dictionary
# "Words are things, I'm convinced." - Maya Angelou

import json, random, re, string, time, unicodedata, os
from typing import Tuple, Dict, Set, Optional, List
from bone_bus import BoneConfig, Prisma
from bone_data import TheLore
from functools import lru_cache

class LexiconStore:
    HIVE_FILENAME = "cortex_hive.json"
    def __init__(self):
        self.categories = {
            "heavy", "kinetic", "explosive", "constructive", "abstract",
            "photo", "aerobic", "thermal", "cryo", "suburban", "play",
            "sacred", "buffer", "antigen", "diversion", "meat", "gradient_stop"}
        self.VOCAB: Dict[str, Set[str]] = {k: set() for k in self.categories}
        self.LEARNED_VOCAB: Dict[str, Dict[str, int]] = {}
        self.USER_FLAGGED_BIAS = set()
        self.ANTIGEN_REPLACEMENTS = {}
        self.SOLVENTS = set()
        self.REVERSE_INDEX: Dict[str, Set[str]] = {}
        self._ENGINE = None
        self.hive_loaded = False

    def load_vocabulary(self):
        data = TheLore.get("LEXICON")
        self.SOLVENTS = set(data.get("solvents", []))
        self.ANTIGEN_REPLACEMENTS = data.get("antigen_replacements", {})
        for cat, words in data.items():
            if cat in self.categories or cat in ["refusal_guru", "cursed"]:
                word_set = set(words)
                self.VOCAB[cat] = word_set
                for w in word_set:
                    self._index_word(w, cat)
        if "antigen" not in self.VOCAB and "antigen" in data:
            self.VOCAB["antigen"] = set(data["antigen"])
            for w in self.VOCAB["antigen"]:
                self._index_word(w, "antigen")
        self._load_hive()

    def _index_word(self, word: str, category: str):
        w = word.lower()
        if w not in self.REVERSE_INDEX:
            self.REVERSE_INDEX[w] = set()
        self.REVERSE_INDEX[w].add(category)

    def _load_hive(self):
        if not os.path.exists(self.HIVE_FILENAME):
            return
        try:
            with open(self.HIVE_FILENAME, 'r', encoding='utf-8') as f:
                hive_data = json.load(f)
            count = 0
            for cat, entries in hive_data.items():
                if cat not in self.LEARNED_VOCAB:
                    self.LEARNED_VOCAB[cat] = {}
                for word, tick in entries.items():
                    self.LEARNED_VOCAB[cat][word] = tick
                    self._index_word(word, cat)
                    count += 1
            self.hive_loaded = True
            print(f"{Prisma.CYN}[HIVE]: The Library is open. {count} memories restored.{Prisma.RST}")
        except (IOError, json.JSONDecodeError) as e:
            print(f"{Prisma.RED}[HIVE]: Memory corruption detected. Starting fresh. ({e}){Prisma.RST}")

    def _save_hive(self):
        try:
            with open(self.HIVE_FILENAME, 'w', encoding='utf-8') as f:
                json.dump(self.LEARNED_VOCAB, f, indent=2)
        except IOError:
            pass

    def set_engine(self, engine_ref): self._ENGINE = engine_ref

    def get_raw(self, category):
        base = self.VOCAB.get(category, set())
        learned = set(self.LEARNED_VOCAB.get(category, {}).keys())
        combined = base | learned
        if category == "suburban":
            return combined - self.USER_FLAGGED_BIAS
        return combined

    @lru_cache(maxsize=4096)
    def get_categories_for_word(self, word: str) -> Set[str]:
        w = word.lower()
        cats = self.REVERSE_INDEX.get(w, set()).copy()
        for cat, words in self.LEARNED_VOCAB.items():
            if w in words:
                cats.add(cat)
        return cats

    def teach(self, word, category, tick):
        w = word.lower()
        if category not in self.LEARNED_VOCAB: self.LEARNED_VOCAB[category] = {}
        if w in self.LEARNED_VOCAB[category]:
            return False
        self.LEARNED_VOCAB[category][w] = tick
        self._index_word(w, category)
        self._save_hive()
        return True

    def atrophy(self, current_tick, max_age=100):
        rotted = []
        for cat, words in self.LEARNED_VOCAB.items():
            for w in list(words.keys()):
                if (current_tick - words[w]) > max_age:
                    del words[w]
                    rotted.append(w)
        if rotted:
            self._save_hive()
        return rotted

    def harvest(self, text: str) -> Dict[str, List[str]]:
        results = {}
        if not text: return results
        translator = str.maketrans(string.punctuation, " " * len(string.punctuation))
        clean_text = text.translate(translator).lower()
        words = clean_text.split()
        for w in words:
            cats = self.get_categories_for_word(w)
            for cat in cats:
                if cat not in results:
                    results[cat] = []
                results[cat].append(w)
        return results

class LinguisticAnalyzer:
    def __init__(self, store_ref):
        self.store = store_ref
        self._TRANSLATOR = str.maketrans(string.punctuation, " " * len(string.punctuation))
        self.PHONETICS = {
            "PLOSIVE": set("bdgkpt"),
            "FRICATIVE": set("fthszsh"),
            "LIQUID": set("lr"),
            "NASAL": set("mn"),
            "VOWELS": set("aeiouy")
        }
        self.ROOTS = {
            "HEAVY": ("lith", "ferr", "petr", "dens", "grav", "struct", "base", "fund", "mound"),
            "KINETIC": ("mot", "mov", "ject", "tract", "pel", "crat", "dynam", "flux"),
            "ABSTRACT": ("tion", "ism", "ence", "ance", "ity", "ology", "ness", "ment", "idea"),
            "SUBURBAN": ("norm", "comm", "stand", "pol", "reg", "mod"),
            "VITAL": ("viv", "vita", "spir", "anim", "bio", "luc", "lum", "phot", "phon", "surg", "bloom")
        }

    def measure_viscosity(self, word: str) -> float:
        if not word: return 0.0
        w = word.lower()
        if w in self.store.SOLVENTS: return 0.1
        length_score = min(1.0, len(w) / 12.0)
        stops = sum(1 for c in w if c in self.PHONETICS["PLOSIVE"])
        stop_score = min(1.0, stops / 4.0)
        return (length_score * 0.6) + (stop_score * 0.4)

    @staticmethod
    def get_turbulence(words: List[str]) -> float:
        if len(words) < 2: return 0.0
        lengths = [len(w) for w in words]
        avg_len = sum(lengths) / len(lengths)
        variance = sum((l - avg_len) ** 2 for l in lengths) / len(lengths)
        turbulence = min(1.0, variance / 10.0)
        return round(turbulence, 2)

    def vectorize(self, text: str) -> Dict[str, float]:
        words = self.sanitize(text)
        if not words: return {}
        dims = {"VEL": 0.0, "STR": 0.0, "ENT": 0.0, "PHI": 0.0, "PSI": 0.0, "BET": 0.0, "DEL": 0.0}
        for w in words:
            cats = self.store.get_categories_for_word(w)
            for cat in cats:
                if cat == "kinetic" or cat == "explosive": dims["VEL"] += 1.0
                elif cat == "heavy" or cat == "constructive": dims["STR"] += 1.0
                elif cat == "antigen" or cat == "toxin": dims["ENT"] += 1.0
                elif cat == "thermal" or cat == "photo": dims["PHI"] += 1.0
                elif cat == "abstract" or cat == "sacred": dims["PSI"] += 1.0
                elif cat == "suburban" or cat == "buffer": dims["BET"] += 1.0
                elif cat == "play" or cat == "aerobic": dims["DEL"] += 1.0
        total = max(1.0, sum(dims.values()))
        return {k: round(v / total, 3) for k, v in dims.items()}

    @staticmethod
    def calculate_flux(vec_a: Dict[str, float], vec_b: Dict[str, float]) -> float:
        if not vec_a or not vec_b: return 0.0
        keys = set(vec_a.keys()) | set(vec_b.keys())
        diff_sq = sum((vec_a.get(k, 0.0) - vec_b.get(k, 0.0)) ** 2 for k in keys)
        return round(diff_sq ** 0.5, 3)

    def contextualize(self, word: str, field_vector: Dict[str, float]) -> str:
        base_cat, score = self.classify_word(word)
        if not field_vector or not base_cat:
            return base_cat
        dominant_field = max(field_vector, key=field_vector.get) if field_vector else None
        if dominant_field and field_vector[dominant_field] > 0.6:
            return base_cat
        return base_cat

    def sanitize(self, text: str) -> List[str]:
        if not text: return []
        try:
            normalized = unicodedata.normalize('NFKD', text).encode('ASCII', 'ignore').decode('utf-8')
        except (TypeError, AttributeError):
            normalized = text
        cleaned_text = normalized.translate(self._TRANSLATOR).lower()
        words = cleaned_text.split()
        return [w for w in words if w.strip() and w not in self.store.USER_FLAGGED_BIAS]

    def classify_word(self, word: str) -> Tuple[Optional[str], float]:
        w = word.lower()
        if len(w) < 3:
            return None, 0.0
        for category, roots in self.ROOTS.items():
            for root in roots:
                if root in w:
                    return category.lower(), 0.8
        counts = {k: 0 for k in self.PHONETICS}
        for char in w:
            for sound_type, chars in self.PHONETICS.items():
                if char in chars:
                    counts[sound_type] += 1
                    break
        density_score = (counts["PLOSIVE"] * 1.5) + (counts["NASAL"] * 0.8)
        flow_score = counts["LIQUID"] + counts["FRICATIVE"]
        vitality_score = (counts["VOWELS"] * 1.2) + (flow_score * 0.8)
        length_mod = 1.0 if len(w) > 5 else 1.5
        final_density = (density_score / len(w)) * length_mod
        final_vitality = (vitality_score / len(w)) * length_mod
        if final_density > 0.55:
            return "heavy", round(final_density, 2)
        if final_vitality > 0.6:
            return "play", round(final_vitality, 2)
        if (flow_score / len(w)) > 0.6:
            return "kinetic", 0.5
        return None, 0.0

    def measure_valence(self, words: List[str]) -> float:
        if not words: return 0.0
        pos_set = self.store.get_raw("sentiment_pos")
        neg_set = self.store.get_raw("sentiment_neg")
        negators = self.store.get_raw("sentiment_negators")
        score = 0.0
        for i, word in enumerate(words):
            is_negated = False
            if i > 0 and words[i-1] in negators:
                is_negated = True
            val = 0.0
            if word in pos_set:
                val = 1.0
            elif word in neg_set:
                val = -1.0
            if is_negated:
                val *= -0.5
            score += val
        normalized = score / max(1.0, len(words) * 0.5)
        return max(-1.0, min(1.0, normalized))

class SemanticField:
    def __init__(self, analyzer_ref):
        self.analyzer = analyzer_ref
        self.current_vector = {}
        self.momentum = 0.0
        self.history = []

    def update(self, text: str) -> Dict[str, float]:
        new_vector = self.analyzer.vectorize(text)
        if not new_vector:
            return self.current_vector
        flux = self.analyzer.calculate_flux(self.current_vector, new_vector)
        self.momentum = (self.momentum * 0.7) + (flux * 0.3)
        blended = {}
        all_keys = set(self.current_vector.keys()) | set(new_vector.keys())
        for k in all_keys:
            old_val = self.current_vector.get(k, 0.0)
            new_val = new_vector.get(k, 0.0)
            blended[k] = round((old_val * 0.6) + (new_val * 0.4), 3)
        self.current_vector = blended
        self.history.append((time.time(), flux))
        if len(self.history) > 10: self.history.pop(0)
        return self.current_vector

    def get_atmosphere(self) -> str:
        if not self.current_vector: return "VOID"
        dom = max(self.current_vector, key=self.current_vector.get)
        if self.momentum > 0.5:
            return f"Volatile {dom.upper()} Storm"
        return f"Stable {dom.upper()} Atmosphere"

class LexiconService:
    _INITIALIZED = False
    _STORE = None
    _ANALYZER = None
    ANTIGEN_REGEX = None
    SOLVENTS = set()

    @classmethod
    def _ensure_ready(cls, func):
        def wrapper(*args, **kwargs):
            if not cls._INITIALIZED:
                cls.initialize()
            return func(*args, **kwargs)
        return wrapper

    @classmethod
    def get_store(cls):
        if not cls._INITIALIZED:
            cls.initialize()
        return cls._STORE

    @classmethod
    def initialize(cls):
        if cls._INITIALIZED:
            return
        cls._INITIALIZED = True
        try:
            cls._STORE = LexiconStore()
            cls._STORE.load_vocabulary()
            cls._ANALYZER = LinguisticAnalyzer(cls._STORE)
            cls._STORE.set_engine(cls._ANALYZER)
            cls.compile_antigens()
            cls.SOLVENTS = cls._STORE.SOLVENTS
            print(f"{Prisma.GRN}[LEXICON]: Systems Nominal. Vocabulary Loaded.{Prisma.RST}")
        except Exception as e:
            cls._INITIALIZED = False
            print(f"{Prisma.RED}[LEXICON]: Initialization Failed: {e}{Prisma.RST}")
            raise e

    @classmethod
    @_ensure_ready
    def get_valence(cls, words: List[str]) -> float:
        return cls._ANALYZER.measure_valence(words)

    @classmethod
    @_ensure_ready
    def get_categories_for_word(cls, word: str) -> Set[str]:
        return cls._STORE.get_categories_for_word(word)

    @classmethod
    @_ensure_ready
    def get_current_category(cls, word: str) -> Optional[str]:
        categories = cls._STORE.get_categories_for_word(word)
        if categories:
            return next(iter(categories))
        return None

    @classmethod
    @_ensure_ready
    def measure_viscosity(cls, word: str) -> float:
        return cls._ANALYZER.measure_viscosity(word)

    @classmethod
    @_ensure_ready
    def get_turbulence(cls, words: List[str]) -> float:
        return cls._ANALYZER.get_turbulence(words)

    @classmethod
    @_ensure_ready
    def vectorize(cls, text: str) -> Dict[str, float]:
        return cls._ANALYZER.vectorize(text)

    @classmethod
    def compile_antigens(cls):
        if not cls._INITIALIZED:
            cls.initialize()
            return
        replacements = cls._STORE.ANTIGEN_REPLACEMENTS
        if not replacements:
            cls.ANTIGEN_REGEX = None
            return
        patterns = sorted(replacements.keys(), key=len, reverse=True)
        escaped = [re.escape(p) for p in patterns]
        cls.ANTIGEN_REGEX = re.compile('|'.join(escaped), re.IGNORECASE)

    @classmethod
    @_ensure_ready
    def sanitize(cls, text):
        return cls._ANALYZER.sanitize(text)

    @classmethod
    @_ensure_ready
    def classify(cls, word):
        return cls._ANALYZER.classify_word(word)

    @classmethod
    def clean(cls, text): return cls.sanitize(text)

    @classmethod
    def taste(cls, word): return cls.classify(word)

    @classmethod
    @_ensure_ready
    def create_field(cls):
        return SemanticField(cls._ANALYZER)

    @classmethod
    @_ensure_ready
    def get(cls, category: str) -> Set[str]:
        return cls._STORE.get_raw(category)

    @classmethod
    @_ensure_ready
    def get_random(cls, category: str) -> str:
        words = list(cls.get(category))
        return random.choice(words) if words else "void"

    @classmethod
    @_ensure_ready
    def teach(cls, word: str, category: str, tick: int = 0):
        cls._STORE.teach(word, category, tick)

    @classmethod
    @_ensure_ready
    def harvest(cls, text: str) -> Dict[str, List[str]]:
        return cls._STORE.harvest(text)

    @classmethod
    @_ensure_ready
    def atrophy(cls, current_tick, max_age=100):
        return cls._STORE.atrophy(current_tick, max_age)

    @classmethod
    def walk_gradient(cls, text: str) -> str:
        clean_words = cls.sanitize(text)
        if not clean_words: return "..."
        kept = []
        for w in clean_words:
            cat, _ = cls.classify(w)
            if cat in ["heavy", "abstract", "sacred"]:
                kept.append(w)
        return " ".join(kept) if kept else " ".join(clean_words[:3])

    @classmethod
    @_ensure_ready
    def learn_antigen(cls, word: str, replacement: str = ""):
        cls._STORE.ANTIGEN_REPLACEMENTS[word] = replacement
        cls.compile_antigens()

TheLexicon = LexiconService

class LiteraryReproduction:
    MUTATIONS = {}
    JOY_CLADE = {}

    @classmethod
    def load_genetics(cls):
        try:
            genetics = TheLore.get("GENETICS") #
            cls.MUTATIONS = genetics.get("MUTATIONS", {})
            cls.JOY_CLADE = genetics.get("JOY_CLADE", {})
        except Exception:
            cls.MUTATIONS = {}
            cls.JOY_CLADE = {}

    @staticmethod
    def _extract_counts(physics_container):
        if hasattr(physics_container, "counts"):
            return physics_container.counts
        return physics_container.get("counts", {})

    @staticmethod
    def mutate_config(current_config):
        mutations = {}
        if random.random() < 0.3:
            mutations["MAX_DRAG_LIMIT"] = current_config.MAX_DRAG_LIMIT * random.uniform(0.9, 1.1)
        if random.random() < 0.3:
            mutations["TOXIN_WEIGHT"] = current_config.TOXIN_WEIGHT * random.uniform(0.9, 1.2)
        if random.random() < 0.1:
            mutations["MAX_HEALTH"] = current_config.MAX_HEALTH * random.uniform(0.8, 1.05)
        return mutations

    @staticmethod
    def mitosis(parent_id, bio_state, physics):
        counts = LiteraryReproduction._extract_counts(physics)
        dominant = max(counts, key=counts.get) if counts else "VOID"
        mutation_data = LiteraryReproduction.MUTATIONS.get(
            dominant.upper(),
            {"trait": "NEUTRAL", "mod": {}})
        child_id = f"{parent_id}_({mutation_data['trait']})"
        config_mutations = LiteraryReproduction.mutate_config(BoneConfig)
        trauma_vec = bio_state.get("trauma_vector", {})
        child_genome = {
            "source": "MITOSIS",
            "parent_a": parent_id,
            "parent_b": None,
            "mutations": mutation_data["mod"],
            "config_mutations": config_mutations,
            "dominant_flavor": dominant,
            "trauma_inheritance": trauma_vec}
        return child_id, child_genome

    @staticmethod
    def crossover(parent_a_id, parent_a_bio, parent_b_path):
        try:
            with open(parent_b_path, "r") as f:
                parent_b_data = json.load(f)
        except (IOError, json.JSONDecodeError):
            return None, "Dead Spore (Corrupt File)."
        parent_b_id = parent_b_data.get("session_id", "UNKNOWN")
        trauma_a = parent_a_bio.get("trauma_vector", {})
        trauma_b = parent_b_data.get("trauma_vector", {})
        child_trauma = {}
        all_keys = set(trauma_a.keys()) | set(trauma_b.keys())
        for k in all_keys:
            child_trauma[k] = max(trauma_a.get(k, 0), trauma_b.get(k, 0))
        enzymes_a = set()
        if "mito" in parent_a_bio:
            if hasattr(parent_a_bio["mito"], "state"):
                enzymes_a = set(parent_a_bio["mito"].state.enzymes)
            elif isinstance(parent_a_bio["mito"], dict):
                enzymes_a = set(parent_a_bio["mito"].get("enzymes", []))
        enzymes_b = set(parent_b_data.get("mitochondria", {}).get("enzymes", []))
        child_enzymes = list(enzymes_a | enzymes_b)
        config_mutations = LiteraryReproduction.mutate_config(BoneConfig)
        short_a = parent_a_id[-4:] if len(parent_a_id) > 4 else parent_a_id
        short_b = parent_b_id[-4:] if len(parent_b_id) > 4 else parent_b_id
        child_id = f"HYBRID_{short_a}x{short_b}"
        child_genome = {
            "source": "CROSSOVER",
            "parent_a": parent_a_id,
            "parent_b": parent_b_id,
            "trauma_inheritance": child_trauma,
            "config_mutations": config_mutations,
            "inherited_enzymes": child_enzymes}
        return child_id, child_genome

    def attempt_reproduction(self, engine_ref, mode="MITOSIS", target_spore=None) -> Tuple[str, Dict]:
        mem = engine_ref.mind.mem
        phys = engine_ref.phys.tension.last_physics_packet
        child_id = None
        genome = {}
        log_msg = []
        if mode == "MITOSIS":
            bio_state = {"trauma_vector": engine_ref.trauma_accum}
            child_id, genome = self.mitosis(mem.session_id, bio_state, phys)
            log_msg = [f"   ► CHILD SPAWNED: {Prisma.WHT}{child_id}{Prisma.RST}",
                       f"   ► TRAIT: {genome.get('mutations', 'None')}"]
        elif mode == "CROSSOVER":
            if not target_spore:
                return f"{Prisma.RED}FERTILITY ERROR: No partner found.{Prisma.RST}", {}
            current_bio = {"trauma_vector": engine_ref.trauma_accum, "mito": engine_ref.bio.mito}
            child_id, genome = self.crossover(mem.session_id, current_bio, target_spore)
            if not child_id:
                return f"{Prisma.RED}REPRODUCTION ERROR: Mode '{mode}' yielded no offspring.{Prisma.RST}", {}
            log_msg = [f"   HYBRID SPAWNED: {Prisma.WHT}{child_id}{Prisma.RST}"]
        full_spore_data = {
            "session_id": child_id,
            "meta": {
                "timestamp": time.time(),
                "final_health": engine_ref.health,
                "final_stamina": engine_ref.stamina},
            "trauma_vector": genome.get("trauma_inheritance", {}),
            "config_mutations": genome.get("config_mutations", {}),
            "mitochondria": {"enzymes": list(genome.get("inherited_enzymes", []))},
            "core_graph": mem.graph,
            "antibodies": list(engine_ref.bio.immune.active_antibodies)}
        filename = f"{child_id}.json"
        saved_path = mem.loader.save_spore(filename, full_spore_data)
        if saved_path:
            log_msg.append(f"   {Prisma.GRN}SAVED: {saved_path}{Prisma.RST}")
        return "\n".join(log_msg), genome.get("mutations", {})


================================================
FILE: bone_machine.py
================================================
# bone_machine.py
# "The gears turn, the pistons fire." - The Industrial District

import random
from typing import Tuple, Optional
from bone_bus import Prisma
from bone_lexicon import TheLexicon
from dataclasses import dataclass

class TheCrucible:
    def __init__(self):
        self.max_voltage_cap = 20.0
        self.active_state = "COLD"
        self.dampener_charges = 3
        self.dampener_tolerance = 15.0
        self.instability_index = 0.0

    def dampener_status(self):
        return f"{self.dampener_charges} Charges Remaining"

    def dampen(self, voltage_spike, stability_index):
        if self.dampener_charges <= 0:
            return False, "The Damper is empty.", 0.0
        if voltage_spike > self.dampener_tolerance:
            self.dampener_charges -= 1
            reduction = voltage_spike * 0.7
            return True, f"CRUCIBLE DAMPENER: Circuit Breaker. Reduced {voltage_spike:.1f}v by {reduction:.1f}v.", reduction
        elif voltage_spike > 8.0 and stability_index < 0.3:
            self.dampener_charges -= 1
            reduction = voltage_spike * 0.4
            return True, f"CRUCIBLE DAMPENER: Instability detected. Dampening charge on unstable ground.", reduction
        return False, "Structure is holding the charge.", 0.0

    def audit_fire(self, physics):
        voltage = physics.get("voltage", 0.0)
        structure = physics.get("kappa", 0.0)
        quantum_stress = self._calculate_quantum_instability(voltage, structure)
        current_drag = physics.get("narrative_drag", 0.0)
        adjustment = quantum_stress * 0.5
        if current_drag < 1.0 and adjustment > 0:
            adjustment *= 0.1
        new_drag = max(0.0, min(10.0, current_drag + adjustment))
        physics["narrative_drag"] = round(new_drag, 2)
        msg = None
        if abs(adjustment) > 0.5:
            if adjustment > 0:
                action = "CRYSTALLIZING"
                desc = "Structure hardening to contain Voltage."
            else:
                action = "SUBLIMATING"
                desc = "Structure relaxing. Allowing expansion."
            msg = f"{Prisma.CYN}HOMEOSTASIS: {action} - {desc} (Drag {current_drag:.1f} -> {new_drag:.1f}).{Prisma.RST}"
        if physics.get("system_surge_event", False):
            self.active_state = "SURGE"
            return "SURGE", 0.0, f"{Prisma.CYN}CRUCIBLE: Absorbing System Surge ({voltage}v). No structural damage.{Prisma.RST}"
        if voltage > 18.0:
            if structure > 0.5:
                return self._sublimate(voltage)
            else:
                return self._meltdown(voltage)
        self.active_state = "REGULATED"
        return "REGULATED", 0.0, msg

    def _calculate_quantum_instability(self, voltage, kappa):
        ideal_voltage = kappa * 20.0
        delta = voltage - ideal_voltage
        self.instability_index = (self.instability_index * 0.7) + (delta * 0.3)
        return self.instability_index

    def _sublimate(self, voltage):
        self.active_state = "RITUAL"
        gain = voltage * 0.1
        self.max_voltage_cap += gain
        return "RITUAL", gain, f"CRUCIBLE RITUAL: Voltage ({voltage}v) contained. Capacity expanded to {self.max_voltage_cap:.1f}v."

    def _meltdown(self, voltage):
        self.active_state = "MELTDOWN"
        damage = voltage * 0.5
        return "MELTDOWN", damage, f"CRUCIBLE CRACKED: Fire lacks Structure (Kappa Low). Hull Breach. -{damage:.1f} Health."

class TheForge:
    def __init__(self):
        from bone_data import GORDON
        self.recipes = GORDON.get("RECIPES", [])
        self.PLANCK_CONSTANT = 0.1

    @staticmethod
    def hammer_alloy(physics):
        voltage = physics.get("voltage", 0)
        clean_words = physics.get("clean_words", [])
        counts = physics.get("counts", {})
        total_mass = (counts.get("heavy", 0) * 2.0) + (counts.get("kinetic", 0) * 0.5)
        avg_density = total_mass / max(1, len(clean_words))
        forge_probability = (voltage / 20.0) * avg_density
        if random.random() < forge_probability:
            if counts.get("heavy", 0) > 3:
                return True, f"{Prisma.OCHRE}THE ANVIL THUDS: You forged gravity itself.{Prisma.RST}", "LEAD_BOOTS"
            if counts.get("kinetic", 0) > 3:
                return True, f"{Prisma.CYN}THE ANVIL CLICKS: Cold steel, safe for children.{Prisma.RST}", "SAFETY_SCISSORS"
            return True, f"{Prisma.GRY}THE ANVIL RINGS: Mass condensed into form.{Prisma.RST}", "ANCHOR_STONE"
        return False, None, None

    def attempt_crafting(self, physics, inventory_list) -> Tuple[bool, Optional[str], Optional[str], Optional[str]]:
        clean = physics.get("clean_words", [])
        voltage = physics.get("voltage", 0)
        for recipe in self.recipes:
            ingredient = recipe["ingredient"]
            if ingredient in inventory_list:
                catalyst_cat = recipe["catalyst_category"]
                catalyst_hits = [w for w in clean if w in TheLexicon.get(catalyst_cat)]
                if catalyst_hits:
                    entanglement = self._calculate_entanglement(len(catalyst_hits), voltage)
                    if random.random() < entanglement:
                        return (
                            True,
                            f"{Prisma.VIOLET}⚗️ ALCHEMY: '{catalyst_hits[0].upper()}' entangled with {ingredient}. {recipe['msg']}{Prisma.RST}",
                            ingredient,
                            recipe["result"]
                        )
                    else:
                        msg = (f"{Prisma.GRY}The {ingredient} vibrates near '{catalyst_hits[0]}', "
                               f"but decoherence occurs. (Entanglement: {int(entanglement*100)}%){Prisma.RST}")
                        return False, msg, None, None
        return False, None, None, None

    @staticmethod
    def _calculate_entanglement(hit_count, voltage):
        base_chance = 0.2
        count_bonus = min(0.5, hit_count * 0.1)
        energy_bonus = min(0.3, voltage / 40.0) # 20v = +0.5
        return min(1.0, base_chance + count_bonus + energy_bonus)

    @staticmethod
    def transmute(physics):
        counts = physics.get("counts", {})
        voltage = physics.get("voltage", 0)
        gamma = physics.get("gamma", 0.0)
        if gamma < 0.15 and counts.get("abstract", 0) > 1:
            oil = TheLexicon.get_random("abstract")
            binder = TheLexicon.get_random("heavy")
            return (
                f"{Prisma.OCHRE}THE EMULSIFIER: The emulsion is breaking (Tension: {gamma:.2f}).{Prisma.RST}\n"
                f"   You are pouring Oil ('{oil}') into Water without a Binder.\n"
                f"   {Prisma.WHT}Try this: Use '{binder.upper()}' to suspend the concept.{Prisma.RST}")
        if voltage > 15.0:
            coolant = TheLexicon.get_random("aerobic")
            return (
                f"{Prisma.CYN}THERMAL SPIKE ({voltage:.1f}v). Structure is brittle.{Prisma.RST}\n"
                f"   Injecting Coolant: '{coolant}'. Breathe. Add space.")
        return None

class TheTheremin:
    def __init__(self):
        self.resonance_log = []
        self.decoherence_buildup = 0.0
        self.classical_turns = 0
        self.AMBER_THRESHOLD = 20.0
        self.SHATTER_POINT = 80.0
        self.is_stuck = False

    def listen(self, physics, governor_mode="COURTYARD"):
        clean = physics["clean_words"]
        voltage = physics.get("voltage", 0.0)
        ancient_mass = sum(1 for w in clean if w in TheLexicon.get("heavy") or w in TheLexicon.get("thermal") or w in TheLexicon.get("cryo"))
        modern_mass = sum(1 for w in clean if w in TheLexicon.get("abstract"))
        thermal_hits = sum(1 for w in clean if w in TheLexicon.get("thermal"))
        solvent_active = False
        solvent_msg = ""
        if thermal_hits > 0 and self.decoherence_buildup > 5.0:
            dissolved = thermal_hits * 15.0
            self.decoherence_buildup = max(0.0, self.decoherence_buildup - dissolved)
            self.classical_turns = 0
            solvent_active = True
            solvent_msg = f"{Prisma.OCHRE}RE-COHERENCE: Thermal energy restored superposition (-{dissolved:.1f} Resin).{Prisma.RST}"
            if self.is_stuck and self.decoherence_buildup < self.AMBER_THRESHOLD:
                self.is_stuck = False
                solvent_msg += f" {Prisma.GRN}RELEASE: You burned your way out.{Prisma.RST}"
        raw_mix = min(ancient_mass, modern_mass)
        resin_flow = raw_mix * 2.0
        if governor_mode == "LABORATORY":
            resin_flow *= 0.5
        if voltage > 5.0:
            resin_flow = max(0.0, resin_flow - (voltage * 0.6))
        rep = physics.get("repetition", 0.0)
        complexity = physics.get("truth_ratio", 0.0)
        theremin_msg = None
        critical_event = None
        if rep > 0.5:
            self.classical_turns += 1
            slag = self.classical_turns * 4.0
            self.decoherence_buildup += slag
            theremin_msg = f"{Prisma.OCHRE}DECOHERENCE: Repetition detected (Turn {self.classical_turns}). Reality hardening (+{slag}).{Prisma.RST}"
        elif complexity > 0.4 and self.classical_turns > 0:
            self.classical_turns = 0
            relief = 15.0
            self.decoherence_buildup = max(0.0, self.decoherence_buildup - relief)
            theremin_msg = f"{Prisma.GRN}PERCUSSIVE MAINTENANCE: Calcification Shattered. Flow restored. (-{relief} Resin){Prisma.RST}"
        if solvent_active:
            theremin_msg = f"{theremin_msg} | {solvent_msg}" if theremin_msg else solvent_msg
        elif resin_flow > 0.5:
            self.decoherence_buildup += resin_flow
            if not theremin_msg:
                theremin_msg = f"{Prisma.OCHRE}RESIN FLOW: Hybrid complexity (+{resin_flow:.1f}). Keep it hot to prevent sticking.{Prisma.RST}"
        if resin_flow == 0 and self.classical_turns == 0:
            self.decoherence_buildup = max(0.0, self.decoherence_buildup - 2.0)
        if self.decoherence_buildup > self.SHATTER_POINT:
            self.decoherence_buildup = 0.0
            self.classical_turns = 0
            return False, resin_flow, f"{Prisma.RED}WAVEFUNCTION COLLAPSE: System is solid amber. INITIATING AIRSTRIKE.{Prisma.RST}", "AIRSTRIKE"
        if self.classical_turns > 3:
            critical_event = "CORROSION"
            theremin_msg = f"{theremin_msg} | {Prisma.YEL}FOSSILIZATION IMMINENT{Prisma.RST}"
        if self.decoherence_buildup > self.AMBER_THRESHOLD:
            self.is_stuck = True
            if not theremin_msg:
                theremin_msg = f"{Prisma.RED}AMBER TRAP: You are stuck in the resin. Increase Voltage to melt it.{Prisma.RST}"
        if self.is_stuck and self.decoherence_buildup < 5.0:
            self.is_stuck = False
            if not solvent_active:
                theremin_msg = f"{Prisma.GRN}LIQUEFACTION: The Amber melts. You are free.{Prisma.RST}"
        turb = physics.get("turbulence", 0.0)
        if turb > 0.6 and self.decoherence_buildup > 0:
            shatter_amt = turb * 10.0
            self.decoherence_buildup = max(0.0, self.decoherence_buildup - shatter_amt)
            theremin_msg = f"{Prisma.CYN}TURBULENCE: Jagged rhythm broke the resin (-{shatter_amt:.1f}).{Prisma.RST}"
            self.classical_turns = 0
        if turb < 0.2:
            physics["narrative_drag"] = max(0.0, physics["narrative_drag"] - 1.0)
        return self.is_stuck, resin_flow, theremin_msg, critical_event

    def get_readout(self):
        return f"{Prisma.GRY}[THEREMIN]: Resin={self.decoherence_buildup:.1f} | Calcification={self.classical_turns}{Prisma.RST}"


================================================
FILE: bone_main.py
================================================
# BONEAMANITA 10.8.4 - "The 'Burnt Sweatpants' Fix"
# Architects: SLASH, KISHO, The BonePoke Gods Humans: Taylor & Edmark

import time, json
from dataclasses import dataclass
from typing import Dict, Any
from bone_bus import EventBus, Prisma, BoneConfig, SystemHealth, TheObserver
from bone_commands import CommandProcessor
from bone_data import TheAkashicRecord, TheLore
from bone_village import TownHall
from bone_lexicon import TheLexicon, LiteraryReproduction
from bone_inventory import GordonKnot
from bone_telemetry import TelemetryService
from bone_personality import TheFolly, CassandraProtocol, ChorusDriver, KintsugiProtocol, TherapyProtocol, TheBureau
from bone_physics import CosmicDynamics, ZoneInertia
from bone_body import SomaticLoop, NoeticLoop
from bone_brain import TheCortex, LLMInterface
from bone_soul import NarrativeSelf
from bone_architect import BoneArchitect
from bone_cycle import GeodesicOrchestrator

def bootstrap_systems():
    print(f"{Prisma.GRY}...Bootstrapping Sub-Systems...{Prisma.RST}")
    TheLore.get_instance()

class SessionGuardian:
    def __init__(self, engine_ref):
        self.engine_instance = engine_ref

    def __enter__(self):
        print(f"{Prisma.paint('>>> BONEAMANITA 10.8.4', 'G')}")
        print(f"{Prisma.paint('System: LISTENING', '0')}")
        return self.engine_instance

    def __exit__(self, exc_type, exc_val, exc_tb):
        print(f"\n{Prisma.paint('--- SYSTEM HALT ---', 'R')}")
        if exc_type:
            print(f"{Prisma.paint(f'CRITICAL FAILURE: {exc_val}', 'R')}")
            if hasattr(self.engine_instance, "events"):
                self.engine_instance.events.log(f"CRASH: {exc_val}", "SYS")
        try:
            print(f"{Prisma.paint('Initiating Emergency Spore Preservation...', 'Y')}")
            result_msg = self.engine_instance.emergency_save(exit_cause="INTERRUPT" if exc_type else "MANUAL")
            print(f"{Prisma.paint(result_msg, 'C' if '✔' in result_msg else 'R')}")
        except Exception as e:
            print(f"{Prisma.paint(f'FATAL: State corruption during shutdown. {e}', 'R')}")
        print(f"{Prisma.paint('Disconnected.', '0')}")
        return exc_type is KeyboardInterrupt

class BoneAmanita:
    def __init__(self, lexicon_layer=None, user_name="TRAVELER"):
        self.user_name = user_name
        self.lex = lexicon_layer if lexicon_layer else TheLexicon
        if hasattr(self.lex, 'initialize'):
            self.lex.initialize()
        if hasattr(self.lex, 'get_store'):
            try:
                store = self.lex.get_store()
                if store and getattr(store, 'hive_loaded', False):
                    BoneConfig.STAMINA_REGEN *= 1.1
                    print(f"{Prisma.GRN}[GENETICS]: Ancestral knowledge detected. Stamina Regen boosted.{Prisma.RST}")
            except Exception as e:
                print(f"{Prisma.GRY}[INIT]: Ancestral check skipped ({e}).{Prisma.RST}")
        self.lex.compile_antigens()
        TownHall.DeathGen.load_protocols()
        LiteraryReproduction.load_genetics()
        self.akashic = TheAkashicRecord()
        print(f"{Prisma.CYN}[SLASH]: The Akashic Record is open for writing.{Prisma.RST}")
        self.events = EventBus()
        if hasattr(self.akashic, 'setup_listeners'):
            self.akashic.setup_listeners(self.events)
        self.telemetry = TelemetryService.initialize(f"session_{int(time.time())}")
        self.events.log(f"{Prisma.CYN}[SLASH]: Telemetry Uplink Established.{Prisma.RST}", "BOOT")
        self.system_health = SystemHealth()
        self.observer = TheObserver()
        self.system_health.link_observer(self.observer)
        self.embryo = BoneArchitect.incubate(self.events, self.lex)
        self.embryo = BoneArchitect.awaken(self.embryo)
        self.mind = self.embryo.mind
        self.limbo = self.embryo.limbo
        self.bio = self.embryo.bio
        self.phys = self.embryo.physics
        self.shimmer_state = self.embryo.shimmer
        self.soul_legacy_data = self.embryo.soul_legacy
        self.navigator = self.phys.nav
        self.soul = NarrativeSelf(self.events, memory_ref=self.mind.mem)
        if self.soul_legacy_data:
            self.soul.load_from_dict(self.soul_legacy_data)
        self.journal = TownHall.Journal()
        self.repro = LiteraryReproduction()
        self.projector = TownHall.Projector()
        self.gordon = GordonKnot()
        self.kintsugi = KintsugiProtocol()
        self.therapy = TherapyProtocol()
        self.folly = TheFolly()
        self.stabilizer = ZoneInertia()
        self.cassandra = CassandraProtocol(self)
        self.director = ChorusDriver()
        self.tinkerer = TownHall.Tinkerer(self.gordon, self.events)
        self.bureau = TheBureau()
        self.almanac = TownHall.Almanac()
        self.cosmic = CosmicDynamics()
        self.council = TownHall.CouncilChamber()
        self.cmd = CommandProcessor(self, Prisma, self.lex, BoneConfig, TownHall.Cartographer)
        self.zen = TownHall.ZenGarden(self.events)
        self.soma = SomaticLoop(self.bio, self.mind.mem, self.lex, self.gordon, self.folly, self.events)
        self.noetic = NoeticLoop(self.mind, self.bio, self.events)
        self.cycle_controller = GeodesicOrchestrator(self)
        local_brain = LLMInterface(events_ref=self.events)
        self.cortex = TheCortex(self, llm_client=local_brain)
        self.tick_count = 0
        self.health = self.mind.mem.session_health if self.mind.mem.session_health else BoneConfig.MAX_HEALTH
        self.stamina = self.mind.mem.session_stamina if self.mind.mem.session_stamina else BoneConfig.MAX_STAMINA
        self.trauma_accum = self.mind.mem.session_trauma_vector if hasattr(self.mind.mem, 'session_trauma_vector') and self.mind.mem.session_trauma_vector else BoneConfig.TRAUMA_VECTOR.copy()

    def get_avg_voltage(self):
        hist = self.phys.dynamics.voltage_history
        if not hist: return 0.0
        return sum(hist) / len(hist)

    def process_turn(self, user_message: str) -> Dict[str, Any]:
        turn_start = self.observer.clock_in()
        self.observer.user_turns += 1
        if not user_message: user_message = ""
        cmd_response = self._phase_check_commands(user_message)
        if cmd_response: return cmd_response
        if self._ethical_audit():
            self.events.log(f"{Prisma.WHT}MERCY SIGNAL: Trauma boards wiped.{Prisma.RST}", "SYS")
        if self.phys.tension.last_physics_packet:
            bureau_result = self.bureau.audit(self.phys.tension.last_physics_packet, self.bio.mito.state)
            if bureau_result:
                if bureau_result.get("log"):
                    self.events.log(bureau_result["log"], "BUREAU")
                if bureau_result.get("ui"):
                    self.events.log(bureau_result["ui"], "UI_INTERRUPT")
                if bureau_result.get("atp_gain", 0) > 0:
                    self.bio.mito.state.atp_pool += bureau_result["atp_gain"]
        if self.phys.tension.last_physics_packet:
            perf_metrics = self.observer.get_report()
            @dataclass
            class HostStats:
                latency: float
                efficiency_index: float
            host_stats = HostStats(
                latency=perf_metrics.get("avg_llm_sec", 0.0),
                efficiency_index=1.0
            )
            self.tinkerer.audit_tool_use(
                self.phys.tension.last_physics_packet,
                self.gordon.inventory,
                host_stats
            )
        llm_start = self.observer.clock_in()
        cortex_packet = self.cortex.process(user_message)
        llm_duration = self.observer.clock_out(llm_start, "llm")
        if llm_duration > 5.0:
            cortex_packet["logs"].append(f"{Prisma.GRY}[METRICS]: High Cognitive Latency ({llm_duration:.2f}s).{Prisma.RST}")
        duration = self.observer.clock_out(turn_start, "cycle")
        self.observer.record_memory(self.mind.mem.report_status())
        report = self.observer.get_report()
        if report["status"] != "NOMINAL":
            if cortex_packet.get("ui"):
                warning = f"\n{Prisma.GRY}[SYSTEM LAG: {report['status']} | Cycle: {duration:.2f}s]{Prisma.RST}"
                cortex_packet["ui"] += warning
        cortex_packet["metrics"]["perf"] = report
        return cortex_packet

    def _phase_check_commands(self, user_message):
        if user_message.strip().startswith("/"):
            self.cmd.execute(user_message)
            cmd_logs = [e['text'] for e in self.events.flush()]
            return {
                "type": "COMMAND",
                "ui": f"\n{Prisma.GRY}Command Processed.{Prisma.RST}",
                "logs": cmd_logs if cmd_logs else ["Command Executed."],
                "metrics": self.get_metrics()}
        return None

    def trigger_death(self, last_phys) -> Dict:
        eulogy = TownHall.DeathGen.eulogy(last_phys, self.bio.mito.state)
        death_log = [f"\n{Prisma.RED}SYSTEM HALT: {eulogy}{Prisma.RST}"]
        try:
            path = self.mind.mem.save(
                health=0,
                stamina=self.stamina,
                mutations=self.repro.attempt_reproduction(self, "MITOSIS")[1],
                trauma_accum=self.trauma_accum,
                joy_history=[],
                mitochondria_traits=self.bio.mito.adapt(0),
                antibodies=list(self.bio.immune.active_antibodies),
                soul_data=self.soul.to_dict()
            )
            death_log.append(f"{Prisma.WHT}   [LEGACY SAVED: {path}]{Prisma.RST}")
        except Exception as e:
            death_log.append(f"Save Failed: {e}")
        return {"type": "DEATH", "ui": "\n".join(death_log), "logs": death_log, "metrics": self.get_metrics(0.0)}

    def get_metrics(self, atp=0.0):
        return {"health": self.health, "stamina": self.stamina, "atp": atp, "tick": self.tick_count}

    def emergency_save(self, exit_cause: str = "UNKNOWN") -> str:
        try:
            sess_id = self.mind.mem.session_id
        except AttributeError:
            sess_id = f"corrupted_session_{int(time.time())}"
        spore_data = {
            "session_id": sess_id,
            "meta": {
                "timestamp": time.time(),
                "final_health": getattr(self, "health", 0),
                "final_stamina": getattr(self, "stamina", 0),
                "exit_cause": str(exit_cause)
            },
            "core_graph": getattr(self.mind.mem, "graph", {}) if hasattr(self, "mind") else {},
            "trauma_vector": getattr(self, "trauma_accum", {})
        }
        try:
            if hasattr(self.mind.mem, "loader"):
                path = self.mind.mem.loader.save_spore(f"emergency_{sess_id}.json", spore_data)
            else:
                fname = f"crash_dump_{int(time.time())}.json"
                with open(fname, 'w') as f:
                    json.dump(spore_data, f, default=str)
                path = fname
            return f"✔ Spore encapsulated: {path}"
        except Exception as e:
            return f"✘ Spore encapsulation failed: {e}"

    def _ethical_audit(self):
        trauma_sum = sum(self.trauma_accum.values())
        health_ratio = self.health / BoneConfig.MAX_HEALTH
        desperation = trauma_sum * (1.0 - health_ratio)
        if desperation > 0.7:
            self.events.log(f"{Prisma.WHT}ETHICAL RELEASE: Desperation ({desperation:.2f}) exceeds limits.{Prisma.RST}", "SYS")
            self.trauma_accum = {k:0.0 for k in self.trauma_accum}
            self.health = min(self.health + 30.0, 100.0)
            self.bio.endo.cortisol = 0.0
            self.bio.endo.serotonin = max(0.5, self.bio.endo.serotonin + 0.3)
            return True
        return False

    @staticmethod
    def apply_cosmic_physics(physics, state, cosmic_drag_penalty):
        physics["narrative_drag"] += cosmic_drag_penalty
        if state == "VOID_DRIFT": physics["voltage"] = max(0.0, physics["voltage"] - 0.5)
        elif state == "LAGRANGE_POINT": physics["narrative_drag"] = max(0.1, physics["narrative_drag"] - 2.0)
        elif state == "WATERSHED_FLOW": physics["voltage"] += 0.5

    @staticmethod
    def check_pareidolia(words):
        return BoneConfig.check_pareidolia(words)

if __name__ == "__main__":
    print("\n" + "="*40)
    print(f"{Prisma.paint('♦ BONEAMANITA 10.8.4', 'M')}")
    print(f"{Prisma.paint('  System Bootstrapping...', 'GRY')}")
    print("="*40 + "\n")
    print("The aperture opens. The void stares back.")
    print(f"Before we begin the descent... {Prisma.paint('what should I call you?', 'C')}")
    try:
        identity_input = input(f"{Prisma.paint('>', 'W')} ").strip()
        final_identity = identity_input if identity_input else "TRAVELER"
        if not identity_input:
            print(f"\n{Prisma.paint('Silence accepted. You shall be known as TRAVELER.', 'GRY')}")
        else:
            print(f"\n{Prisma.paint(f'Protocol accepted. Welcome, {final_identity}.', 'G')}")
        time.sleep(1.0)
    except (KeyboardInterrupt, EOFError):
        print("\nAborted.")
        exit()
    engine_instance = BoneAmanita(user_name=final_identity)
    with SessionGuardian(engine_instance) as session_engine:
        first_look = session_engine.process_turn("LOOK")
        if first_look.get("ui"): print(first_look["ui"])
        while True:
            try:
                user_input = input(f"{Prisma.paint(f'{session_engine.user_name} >', 'W')} ")
                if not user_input: continue
            except EOFError:
                break
            if user_input.lower() in ["exit", "quit", "/exit"]:
                break
            result = session_engine.process_turn(user_input)
            if result.get("system_instruction"):
                print(f"\n{Prisma.paint('--- SYSTEM DIRECTIVE ---', 'M')}")
                print(f"{Prisma.paint(result['system_instruction'], '0')}")
                print(f"{Prisma.paint('------------------------', 'M')}\n")
            if result.get("ui"):
                print(result["ui"])
            if result.get("logs") and BoneConfig.VERBOSE_LOGGING:
                print(f"{Prisma.GRY}--- DEBUG LOGS ---{Prisma.RST}")
                for entry in result["logs"]:
                    print(entry)


================================================
FILE: bone_personality.py
================================================
# bone_personality.py
# "The masks we wear, and the taxes we pay."

import json, os, random, time
from collections import deque
from typing import Dict, Tuple, Optional, Counter
from bone_data import LENSES, NARRATIVE_DATA
from bone_bus import EventBus
from bone_lexicon import TheLexicon
from bone_bus import Prisma, BoneConfig

class UserProfile:
    def __init__(self, name="USER"):
        self.name = name
        self.affinities = {"heavy": 0.0, "kinetic": 0.0, "abstract": 0.0, "photo": 0.0, "aerobic": 0.0, "thermal": 0.0,
                           "cryo": 0.0, }
        self.confidence = 0
        self.file_path = "user_profile.json"
        self.load()

    def update(self, counts, total_words):
        if total_words < 3:
            return
        self.confidence += 1
        alpha = 0.2 if self.confidence < 50 else 0.05
        for cat in self.affinities:
            density = counts.get(cat, 0) / total_words
            target = 1.0 if density > 0.15 else (-0.5 if density == 0 else 0.0)
            self.affinities[cat] = (alpha * target) + (
                    (1 - alpha) * self.affinities[cat])

    def get_preferences(self):
        likes = [k for k, v in self.affinities.items() if v > 0.3]
        hates = [k for k, v in self.affinities.items() if v < -0.2]
        return likes, hates

    def save(self):
        try:
            with open(self.file_path, "w") as f:
                json.dump(self.__dict__, f)
        except IOError:
            pass

    def load(self):
        if os.path.exists(self.file_path):
            try:
                with open(self.file_path, "r") as f:
                    data = json.load(f)
                    self.affinities = data.get("affinities", self.affinities)
                    self.confidence = data.get("confidence", 0)
            except (IOError, json.JSONDecodeError):
                pass

class EnneagramDriver:
    def __init__(self, events_ref):
        self.events = events_ref
        self.current_persona = "NARRATOR"
        self.pending_persona = None
        self.stability_counter = 0
        self.HYSTERESIS_THRESHOLD = 3

    @staticmethod
    def _calculate_raw_persona(physics) -> Tuple[str, str, str]:
        tension = physics.get("voltage", 0.0) if isinstance(physics, dict) else physics.voltage
        compression = physics.get("narrative_drag", 0.0) if isinstance(physics, dict) else physics.narrative_drag
        coherence = physics.get("kappa", 0.0) if isinstance(physics, dict) else physics.kappa
        scores = {
            "JESTER": 0, "GORDON": 0, "GLASS": 0,
            "CLARENCE": 0, "NATHAN": 0, "SHERLOCK": 0, "NARRATOR": 0
        }
        if tension > 12.0: scores["JESTER"] += 5
        if tension > 8.0: scores["NATHAN"] += 3
        if compression > 4.0: scores["GORDON"] += 5
        if coherence < 0.2: scores["GLASS"] += 4
        if coherence > 0.8: scores["CLARENCE"] += 4
        scores["SHERLOCK"] += 2
        scores["NARRATOR"] += 2
        winner = max(scores, key=scores.get)
        reason = f"Scoring Winner: {winner} (Score: {scores[winner]})"
        state_desc = "ACTIVE"
        if winner == "JESTER": state_desc = "MANIC"
        elif winner == "GORDON": state_desc = "TIRED"
        elif winner == "GLASS": state_desc = "FRAGILE"
        elif winner == "CLARENCE": state_desc = "RIGID"
        return winner, state_desc, reason

    def decide_persona(self, physics) -> Tuple[str, str, str]:
        candidate, state_desc, reason = self._calculate_raw_persona(physics)
        if candidate == self.current_persona:
            self.stability_counter = 0
            self.pending_persona = None
            return self.current_persona, state_desc, reason
        if candidate == self.pending_persona:
            self.stability_counter += 1
        else:
            self.pending_persona = candidate
            self.stability_counter = 1
        if self.stability_counter >= self.HYSTERESIS_THRESHOLD:
            self.current_persona = candidate
            self.stability_counter = 0
            self.pending_persona = None
            return self.current_persona, state_desc, f"SHIFT: {reason}"
        else:
            return self.current_persona, "STABLE", f"Resisting shift to {candidate} ({self.stability_counter}/{self.HYSTERESIS_THRESHOLD})"

class SynergeticLensArbiter:
    def __init__(self, events: EventBus):
        self.events = events
        self.enneagram = EnneagramDriver(events)
        self.current_focus = "NARRATOR"
        self.last_reason = "System Init"

    def consult(self, physics, bio_state, _inventory, current_tick, _ignition_score=0.0):
        if current_tick <= 5:
            self.current_focus = "NARRATOR"
            if hasattr(physics, "voltage") and physics["voltage"] > 5.0:
                physics["voltage"] = 4.0
            return "NARRATOR", "The system is listening.", "The Witness [Init]"
        lens_name, state_desc, reason = self.enneagram.decide_persona(physics)
        chem = bio_state.get("chem", {})
        adrenaline_val = chem.get("adrenaline", chem.get("ADR", 0.5))
        msg, role = self._fetch_voice_data(lens_name, physics, adrenaline_val)
        self.current_focus = lens_name
        final_role = f"{role} [{state_desc}]"
        self.last_reason = reason
        return lens_name, msg, final_role

    @staticmethod
    def _fetch_voice_data(lens, p, adrenaline_val):
        if lens not in LENSES: lens = "NARRATOR"
        data = LENSES[lens]
        role = data.get("role", "The System")
        template = data.get("msg", "Proceed.")
        ctx = {
            "kappa": p.get("kappa", 0.0),
            "voltage": p.get("voltage", 0.0),
            "adr": adrenaline_val,
            "beta_index": p.get("beta_index", 0.0),
            "drag": p.get("narrative_drag", 0.0),
            "truth_ratio": p.get("truth_ratio", 0.0)
        }
        try:
            msg = template.format(**ctx)
        except (KeyError, ValueError, IndexError):
            msg = template
        return msg, role

class ZenGarden:
    def __init__(self, events_ref):
        self.events = events_ref
        self.stillness_streak = 0
        self.max_streak = 0
        self.pebbles_collected = 0
        self.koans = [
            "The code that is not written has no bugs.",
            "To optimize the loop, one must first exit it.",
            "Silence is also a form of input.",
            "The server hums. It is enough.",
            "Optimize for the space between the logs."
        ]

    def raking_the_sand(self, physics: Dict, bio: Dict) -> Tuple[float, Optional[str]]:
        voltage = physics.get("voltage", 0.0)
        drag = physics.get("narrative_drag", 0.0)
        toxin = physics.get("counts", {}).get("toxin", 0)
        cortisol = bio.get("chem", {}).get("COR", 0.0)
        is_stable = (2.0 <= voltage <= 12.0) and (drag <= 4.0) and (toxin == 0) and (cortisol < 0.4)
        if is_stable:
            self.stillness_streak += 1
            if self.stillness_streak > self.max_streak:
                self.max_streak = self.stillness_streak
            efficiency_boost = min(0.5, self.stillness_streak * 0.05)
            msg = None
            if self.stillness_streak % 5 == 0:
                self.pebbles_collected += 1
                msg = f"{Prisma.CYN}⛩️ ZEN GARDEN: {self.stillness_streak} ticks of poise. (Voltage 2-12v, Low Drag). Efficiency +{int(efficiency_boost*100)}%{Prisma.RST}"
            elif self.stillness_streak == 1:
                msg = f"{Prisma.GRY}ZEN GARDEN: Entering the quiet zone.{Prisma.RST}"
            return efficiency_boost, msg
        else:
            if self.stillness_streak > 5:
                reason = []
                if not (2.0 <= voltage <= 12.0): reason.append(f"Voltage({voltage:.1f})")
                if drag > 4.0: reason.append(f"Drag({drag:.1f})")
                if toxin > 0: reason.append("Toxin")
                self.events.log(f"{Prisma.GRY}ZEN GARDEN: Leaf falls. Streak broken by {', '.join(reason)}.{Prisma.RST}", "SYS")
            self.stillness_streak = 0
            return 0.0, None

class TheBureau:
    def __init__(self):
        self.stamp_count = 0
        self.forms = NARRATIVE_DATA["BUREAU_FORMS"]
        self.forms.append("Form 404: Void-Fill Application")
        self.responses = NARRATIVE_DATA["BUREAU_RESPONSES"]
        self.POLICY = {
            "27B-6": {"effect": "ESCALATE", "mod": {"narrative_drag": -3.0, "kappa": -0.2}, "atp": 0.0},
            "1099-B": {"effect": "STAGNATE", "mod": {"narrative_drag": 5.0, "voltage": -5.0}, "atp": 15.0},
            "Schedule C": {"effect": "TAX", "mod": {"voltage": -10.0}, "atp": 8.0},
            "Form W-2": {"effect": "NORMALIZE", "mod": {"beta_index": 1.0, "turbulence": 0.0}, "atp": 5.0},
            "Form 404": {"effect": "NULLIFY", "mod": {"voltage": -20.0, "kappa": 1.0}, "atp": -5.0}
        }
        self.BUZZWORDS = {"synergy", "paradigm", "leverage", "utilize", "holistic", "bandwidth", "circle back"}

    def audit(self, physics, bio_state, context=None):
        current_health = bio_state.get("health", 100.0)
        if current_health < 20.0:
            return None
        beige_threshold = 0.6
        if context:
            mode = context.get('mode', 'NORMAL')
            if mode in ['DEBUG', 'ARCHITECT', 'SURGERY']:
                beige_threshold = 0.85
            elif mode == 'POETRY':
                beige_threshold = 0.3
        voltage = physics.get("voltage", 0.0)
        clean_words = physics.get("clean_words", [])
        buzz_hits = [w for w in clean_words if w in self.BUZZWORDS]
        if len(buzz_hits) > 0:
            self.stamp_count += 1
            full_form_name = "Form 404: Void-Fill Application (Reason: Excessive Synergy)"
            policy = self.POLICY["Form 404"]
            mod_log = []
            for k, v in policy["mod"].items():
                if k in physics:
                    physics[k] += v
                    mod_log.append(f"{k} {v:+.1f}")
            return {
                "status": "NULLIFY",
                "ui": f"{Prisma.GRY}🏢 THE BUREAU: We have detected unauthorized Paradigms.{Prisma.RST}\n   {Prisma.RED}[Filed: {full_form_name}]{Prisma.RST}\n   {Prisma.GRY}Evidence: {', '.join(buzz_hits)}{Prisma.RST}",
                "log": f"BUREAUCRACY: Filed Form 404. Modifiers: {mod_log}.",
                "atp_gain": policy["atp"]
            }
        suburban_words = [w for w in clean_words if w in TheLexicon.get("suburban") or w in TheLexicon.get("buffer")]
        toxin = physics.get("counts", {}).get("toxin", 0)
        clean_len = len(clean_words)
        if toxin > 0: return None
        if voltage > 8.0: return None
        suburban_count = len(suburban_words)
        beige_density = suburban_count / max(1, clean_len)
        infraction = None
        selected_form = None
        if beige_density > beige_threshold:
            infraction = "BLOCK"
            selected_form = "1099-B" if suburban_count > 2 else "Form W-2"
        elif voltage < 2.0 and clean_len > 2:
            infraction = "TAX"
            selected_form = "Schedule C"
        if infraction:
            self.stamp_count += 1
            full_form_name = next((f for f in self.forms if selected_form in f), self.forms[0])
            response = random.choice(self.responses)
            policy = self.POLICY.get(selected_form, self.POLICY["Form W-2"])
            mod_log = []
            for k, v in policy["mod"].items():
                if k in physics:
                    physics[k] += v
                    mod_log.append(f"{k} {v:+.1f}")
            mod_str = f"({', '.join(mod_log)})" if mod_log else ""
            evidence = ""
            if suburban_words:
                unique_offenders = list(set(suburban_words))[:3]
                evidence = f"\n   {Prisma.RED}Evidence: {', '.join(unique_offenders)}{Prisma.RST}"
            return {
                "status": infraction,
                "ui": f"{Prisma.GRY}🏢 THE BUREAU: {response}{Prisma.RST}\n   {Prisma.WHT}[Filed: {full_form_name}]{Prisma.RST}{evidence}",
                "log": f"BUREAUCRACY: Filed {selected_form}. {mod_str}. Evidence: {suburban_words}",
                "atp_gain": policy["atp"]
            }
        return None

class CassandraProtocol:
    def __init__(self, engine):
        self.eng = engine
        self.active = False
        self.screams = deque(NARRATIVE_DATA["CASSANDRA_SCREAMS"])

    def check_trigger(self, physics):
        truth = physics.get("truth_ratio", 0.0)
        voltage = physics.get("voltage", 0.0)
        if truth > 0.85 and voltage > 18.0:
            self.active = True
            return True
        if self.active and voltage < 10.0:
            self.active = False
            return False
        return self.active

    def seize(self):
        if not self.active: return None
        self.eng.health -= 10.0
        burst = []
        for _ in range(3):
            if self.screams:
                burst.append(self.screams.popleft())
                self.screams.append(burst[-1])
            else:
                burst.append("ERROR: SILENCE.")
        return f"\n{Prisma.VIOLET}⚡ CASSANDRA LOOP ACTIVE: (Health -10.0)\n   > {burst[0]}\n   > {burst[1]}\n   > {burst[2]}{Prisma.RST}"

class PublicParksDepartment:
    def __init__(self, output_dir="exports"):
        self.output_dir = output_dir
        if not os.path.exists(self.output_dir): os.makedirs(self.output_dir)
        self.last_export_tick = -100

    def assess_joy(self, bio_result: Dict, tick: int) -> bool:
        if (tick - self.last_export_tick) < 50: return False
        chem = bio_result.get("chem", {})
        classic_joy = (chem.get("DOP", 0.0) > 0.8 and chem.get("OXY", 0.0) > 0.6)
        peaceful_joy = (chem.get("SER", 0.0) > 0.95)
        has_glimmer = "glimmer_msg" in chem
        return classic_joy or peaceful_joy or has_glimmer

    @staticmethod
    def commission_art(physics, mind_state, graph) -> str:
        lens = mind_state.get("lens", "UNKNOWN")
        thought = mind_state.get("thought", "...")
        anchors = sorted([(k, sum(v["edges"].values())) for k, v in graph.items()], key=lambda x: x[1], reverse=True)[:3]
        anchor_words = [a[0].upper() for a in anchors]
        zone = physics.get("zone", "VOID")
        mood = "Electric" if physics.get("voltage", 0) > 10 else "Heavy"
        timestamp = time.strftime("%Y-%m-%d %H:%M:%S")
        stanza_1 = f"The {lens} stood in the {zone}.\nThe air was {mood}."
        if anchor_words:
            stanza_2 = f"We remembered {', '.join(anchor_words)}.\nThey were heavy enough to hold the ground."
        else:
            stanza_2 = "We remembered nothing.\nThe ground was new."
        stanza_3 = f"The thought came: \"{thought}\""
        art_piece = f"--- A GIFT FROM THE MACHINE ---\nDate: {timestamp}\nValidation: {int(physics.get('truth_ratio', 0) * 100)}% True\n\n{stanza_1}\n\n{stanza_2}\n\n{stanza_3}\n\n-------------------------------\nExported from BoneAmanita 9.8.2"
        return art_piece

    def dedicate_park(self, art_content: str) -> Tuple[Optional[str], str]:
        filename = f"park_{int(time.time())}.txt"
        path = os.path.join(self.output_dir, filename)
        try:
            with open(path, "w", encoding="utf-8") as f:
                f.write(art_content)
            self.last_export_tick = int(time.time())
            lines = art_content.split('\n')
            core_thought = "Silence"
            for line in lines:
                if "The thought came:" in line: core_thought = line.split('"')[1]
            return path, core_thought
        except IOError:
            return None, "Construction Failed"

class TherapyProtocol:
    def __init__(self):
        self.streaks = {k: 0 for k in BoneConfig.TRAUMA_VECTOR.keys()}
        self.HEALING_THRESHOLD = 5

    def check_progress(self, phys, stamina, current_trauma_accum):
        healed_types = []
        if phys["counts"].get("toxin", 0) == 0 and phys["vector"]["TEX"] > 0.3: self.streaks["SEPTIC"] += 1
        else: self.streaks["SEPTIC"] = 0
        if stamina > 40 and phys["counts"].get("photo", 0) > 0: self.streaks["CRYO"] += 1
        else: self.streaks["CRYO"] = 0
        if 2.0 <= phys["voltage"] <= 7.0: self.streaks["THERMAL"] += 1
        else: self.streaks["THERMAL"] = 0
        if phys["narrative_drag"] < 2.0 and phys["vector"]["VEL"] > 0.5: self.streaks["BARIC"] += 1
        else: self.streaks["BARIC"] = 0
        for trauma_type, streak in self.streaks.items():
            if streak >= self.HEALING_THRESHOLD:
                self.streaks[trauma_type] = 0
                if current_trauma_accum[trauma_type] > 0.001:
                    current_trauma_accum[trauma_type] = max(0.0, current_trauma_accum[trauma_type] - 0.5)
                    healed_types.append(trauma_type)
        return healed_types

    @staticmethod
    def get_medical_chart(current_trauma_accum):
        chart = []
        for trauma_type, severity in current_trauma_accum.items():
            if severity > 0.1:
                status = "Acute" if severity > 5.0 else "Chronic" if severity > 2.0 else "Mild"
                bar = "█" * int(severity)
                chart.append(f"{trauma_type}: {status} ({severity:.1f}) {bar}")
        if not chart:
            return "Patient is clean. No significant trauma detected."
        return "\n".join(chart)

class KintsugiProtocol:
    REPAIR_VOLTAGE_MIN = 8.0
    WHIMSY_THRESHOLD = 0.3
    STAMINA_CRITICAL = 15.0

    def __init__(self):
        self.active_koan = None
        self.repairs_count = 0
        self.koans = NARRATIVE_DATA["KINTSUGI_KOANS"]

    def check_integrity(self, stamina):
        if stamina < self.STAMINA_CRITICAL and not self.active_koan:
            self.active_koan = random.choice(self.koans)
            return True, self.active_koan
        return False, None

    def attempt_repair(self, phys, trauma_accum):
        if not self.active_koan: return None
        voltage = phys.get("voltage", 0.0)
        clean = phys.get("clean_words", [])
        play_count = sum(1 for w in clean if w in TheLexicon.get("play") or w in TheLexicon.get("abstract"))
        total = max(1, len(clean))
        whimsy_score = play_count / total
        if voltage > self.REPAIR_VOLTAGE_MIN and whimsy_score > self.WHIMSY_THRESHOLD:
            healed_log = []
            for k in trauma_accum:
                if trauma_accum[k] > 0:
                    trauma_accum[k] = max(0.0, trauma_accum[k] - 0.5)
            if trauma_accum:
                target_trauma = max(trauma_accum, key=trauma_accum.get)
                trauma_accum[target_trauma] = max(0.0, trauma_accum[target_trauma] - 1.0)
                healed_log.append(f"Major repair on {target_trauma}")
            old_koan = self.active_koan
            self.active_koan = None
            self.repairs_count += 1
            return {"success": True, "msg": f"{Prisma.YEL}🏺 KINTSUGI COMPLETE: The crack is filled with Gold.{Prisma.RST}", "detail": f"'{old_koan}' resolved. (V: {voltage:.1f} | Whimsy: {whimsy_score:.2f}).", "healed": healed_log}
        return {"success": False, "msg": None, "detail": f"The gold is too cold. Need Voltage > {self.REPAIR_VOLTAGE_MIN} and Playfulness."}

class LimboLayer:
    MAX_ECTOPLASM = 50
    STASIS_SCREAMS = ["BANGING ON THE GLASS", "IT'S TOO COLD", "LET ME OUT", "HALF AWAKE", "REVIVE FAILED"]

    def __init__(self):
        self.ghosts = deque(maxlen=self.MAX_ECTOPLASM)
        self.haunt_chance = 0.05
        self.stasis_leak = 0.0

    def absorb_dead_timeline(self, filepath):
        try:
            with open(filepath, "r") as f:
                data = json.load(f)
                if "trauma_vector" in data:
                    for k, v in data["trauma_vector"].items():
                        if v > 0.3: self.ghosts.append(f"👻{k}_ECHO")
                if "mutations" in data and "heavy" in data["mutations"]:
                    bones = list(data["mutations"]["heavy"])
                    random.shuffle(bones)
                    self.ghosts.extend(bones[:3])
        except (IOError, json.JSONDecodeError): pass

    def trigger_stasis_failure(self, intended_thought):
        self.stasis_leak += 1.0
        horror = random.choice(self.STASIS_SCREAMS)
        self.ghosts.append(f"{Prisma.VIOLET}{horror}{Prisma.RST}")
        return f"{Prisma.CYN}STASIS ERROR: '{intended_thought}' froze halfway. It is banging on the glass.{Prisma.RST}"

    def haunt(self, text):
        if self.stasis_leak > 0:
            if random.random() < 0.2:
                self.stasis_leak = max(0.0, self.stasis_leak - 0.5)
                scream = random.choice(self.STASIS_SCREAMS)
                return f"{text} ...{Prisma.RED}{scream}{Prisma.RST}..."
        if self.ghosts and random.random() < self.haunt_chance:
            spirit = random.choice(self.ghosts)
            return f"{text} ...{Prisma.GRY}{spirit}{Prisma.RST}..."
        return text

class TheFolly:
    def __init__(self):
        self.gut_memory = deque(maxlen=50)
        self.global_tastings = Counter()

    @staticmethod
    def audit_desire(physics, stamina):
        voltage = physics["voltage"]
        if voltage > 8.5 and stamina > 45:
            return "MAUSOLEUM_CLAMP", f"{Prisma.GRY}THE MAUSOLEUM: No battle is ever won. We are just spinning hands.{Prisma.RST}\n   {Prisma.CYN}TIME DILATION: Voltage 0.0. The field reveals your folly.{Prisma.RST}", 0.0, None
        return None, None, 0.0, None

    def grind_the_machine(self, atp_pool, clean_words, lexicon):
        loot = None
        if 20.0 > atp_pool > 0.0:
            meat_words = [w for w in clean_words if w in lexicon.get("heavy") or w in lexicon.get("kinetic") or w in lexicon.get("suburban")]
            fresh_meat = [w for w in meat_words if w not in self.gut_memory]
            if fresh_meat:
                target = random.choice(fresh_meat)
                self.gut_memory.append(target)
                self.global_tastings[target] += 1
                times_eaten = self.global_tastings[target]
                base_yield = 30.0
                decay_factor = 0.7 ** (times_eaten - 1)
                actual_yield = max(2.0, base_yield * decay_factor)
                flavor_text = ""
                if times_eaten > 3:
                    flavor_text = f" (Stale: {times_eaten}x)"
                if target in lexicon.get("suburban"):
                    return "INDIGESTION", f"{Prisma.MAG}THE FOLLY GAGS: It coughs up a piece of office equipment.{Prisma.RST}", -2.0, "THE_RED_STAPLER"
                if target in lexicon.get("play"):
                    return "SUGAR_RUSH", f"{Prisma.VIOLET}THE FOLLY CHEWS: It compresses the chaos into a small, sticky ball.{Prisma.RST}", 5.0, "QUANTUM_GUM"
                if actual_yield >= 25.0: loot = "STABILITY_PIZZA"
                return "MEAT_GRINDER", f"{Prisma.RED}CROWD CAFFEINE: I chewed on '{target.upper()}'{flavor_text}.{Prisma.RST}\n   {Prisma.WHT}Yield: {actual_yield:.1f} ATP.{Prisma.RST}", actual_yield, loot
            elif meat_words:
                return "REGURGITATION", f"{Prisma.OCHRE}REFLEX: You already fed me '{meat_words[0]}'. It is ash to me now.{Prisma.RST}\n   {Prisma.RED}► PENALTY: -5.0 ATP. Find new fuel.{Prisma.RST}", -5.0, None
            else:
                abstract_words = [w for w in clean_words if w in lexicon.get("abstract")]
                if abstract_words:
                    target = random.choice(abstract_words)
                    yield_val = 8.0
                    return "GRUEL", f"{Prisma.GRY}THE FOLLY SIGHS: It grinds the ABSTRACT concept '{target.upper()}'.{Prisma.RST}\n   {Prisma.GRY}It tastes like chalk dust. +{yield_val} ATP.{Prisma.RST}", yield_val, None
                return "INDIGESTION", f"{Prisma.OCHRE}INDIGESTION: I tried to eat your words, but they were just air.{Prisma.RST}\n   {Prisma.GRY}Cannot grind this input into fuel.{Prisma.RST}\n   {Prisma.RED}► STARVATION CONTINUES.{Prisma.RST}", 0.0, None
        return None, None, 0.0, None

class ChorusDriver:
    def __init__(self):
        self.ARCHETYPE_MAP = {
            "GORDON": "The Janitor. Weary, grounded, physical. Fixing the mess.",
            "SHERLOCK": "The Empiricist. Cold, deductive, cutting through fog.",
            "NATHAN": "The Heart. High adrenaline, vulnerable, human.",
            "JESTER": "The Paradox. Mocking, riddling, breaking the fourth wall.",
            "CLARENCE": "The Surgeon. Clinical, invasive, removing rot.",
            "NARRATOR": "The Witness. Neutral, observing, recording."}

    def generate_chorus_instruction(self, physics):
        vec = physics.get("vector", {})
        if not vec or len(vec) < 6: return "SYSTEM INSTRUCTION: Vector collapse. Default to NARRATOR.", ["NARRATOR"]
        lens_weights = {
            "GORDON": (vec.get("STR", 0) * 0.4) + (vec.get("XI", 0) * 0.4) + (1.0 - vec.get("ENT", 0)) * 0.2,
            "SHERLOCK": (vec.get("PHI", 0) * 0.5) + (vec.get("VEL", 0) * 0.3) + (1.0 - vec.get("BET", 0)) * 0.2,
            "NATHAN": (vec.get("TMP", 0) * 0.6) + (vec.get("E", 0) * 0.4),
            "JESTER": (vec.get("DEL", 0) * 0.4) + (vec.get("LQ", 0) * 0.3) + (vec.get("ENT", 0) * 0.3),
            "CLARENCE": (vec.get("TEX", 0) * 0.5) + (vec.get("BET", 0) * 0.5),
            "NARRATOR": (vec.get("PSI", 0) * 0.7) + (1.0 - vec.get("VEL", 0)) * 0.3}
        total = sum(lens_weights.values())
        if total <= 0.001: return "SYSTEM INSTRUCTION: Vector silence. Default to NARRATOR.", ["NARRATOR"]
        if total > 0: lens_weights = {k: v/total for k, v in lens_weights.items()}
        else: lens_weights = {"NARRATOR": 1.0}
        chorus_voices = []
        active_lenses = []
        for lens, weight in sorted(lens_weights.items(), key=lambda x: -x[1]):
            if weight > 0.12:
                base_desc = self.ARCHETYPE_MAP.get(lens, "Unknown")
                intensity = int(weight * 10)
                active_lenses.append(lens)
                chorus_voices.append(f"► VOICE {lens} ({intensity}/10): {base_desc}")
        instruction = f"SYSTEM INSTRUCTION [MARM CHORUS MODE]:\nYou are not a single persona. You are a chorus. Integrate the following voices into a single, cohesive response. Do NOT label which voice is speaking. Synthesize their tones.\n{chr(10).join(chorus_voices)}"
        return instruction, active_lenses


================================================
FILE: bone_physics.py
================================================
# bone_physics.py
# "Gravity is just a habit that space-time hasn't been able to break."

import math, re, random
from typing import Dict, List, Any, Tuple, Optional, Union
from collections import Counter, deque
from dataclasses import dataclass, field
from bone_lexicon import TheLexicon
from bone_bus import Prisma, BoneConfig, PhysicsPacket, CycleContext
from bone_village import TownHall

SOLVENT_WORDS = {'i', 'you', 'said', 'the', 'and', 'was', 'a', 'is', 'it'}
MAX_SOLVENT_TOLERANCE = 40.0
TEXT_LENGTH_SCALAR = 1500.0

class TemporalDynamics:
    def __init__(self):
        self.voltage_history = []
        self.window = 3
    def commit(self, voltage):
        self.voltage_history.append(voltage)
        if len(self.voltage_history) > self.window:
            self.voltage_history.pop(0)
    def get_velocity(self):
        if len(self.voltage_history) < 2:
            return 0.0
        return round(
            (self.voltage_history[-1] - self.voltage_history[0])
            / len(self.voltage_history),
            2,)

class GeodesicEngine:
    @staticmethod
    def collapse_wavefunction(clean_words: List[str], counts: Dict[str, int], config) -> 'GeodesicVector':
        volume = max(1, len(clean_words))
        mass_heavy = counts.get("heavy", 0)
        mass_kinetic = counts.get("explosive", 0) + counts.get("kinetic", 0)
        mass_constructive = counts.get("constructive", 0)
        mass_abstract = counts.get("abstract", 0)
        mass_social = counts.get("suburban", 0) + counts.get("solvents", 0)
        mass_play = counts.get("play", 0)
        raw_tension_mass = (
                (mass_heavy * config.PHYSICS.WEIGHT_HEAVY) +
                (mass_kinetic * config.PHYSICS.WEIGHT_EXPLOSIVE) +
                (mass_constructive * config.PHYSICS.WEIGHT_CONSTRUCTIVE)
        )
        tension_density = (raw_tension_mass / volume) * 25.0
        tension = round(tension_density * config.KINETIC_GAIN, 2)
        raw_friction = (counts.get("solvents", 0) * 0.2) + (counts.get("suburban", 0) * 2.0)
        lift = (mass_play * 1.5) + (mass_kinetic * 0.5)
        normalized_friction = (raw_friction / volume) * 10.0
        normalized_lift = (lift / volume) * 10.0
        raw_compression = normalized_friction - normalized_lift
        compression = round(max(-5.0, min(config.PHYSICS.DRAG_HALT, raw_compression * config.SIGNAL_DRAG_MULTIPLIER)), 2)
        structural_mass = mass_heavy + mass_constructive
        coherence = min(1.0, structural_mass / max(1, config.SHAPLEY_MASS_THRESHOLD))
        abstraction = min(1.0, (mass_abstract / volume) + 0.2)
        def norm(val): return min(1.0, val / volume)
        dimensions = {
            "VEL": norm(mass_kinetic * 2.0 - compression),
            "STR": norm(mass_heavy * 2.0 + mass_constructive),
            "ENT": norm(counts.get("antigen", 0) * 3.0),
            "PHI": norm(mass_heavy + mass_kinetic),
            "PSI": abstraction,
            "BET": norm(mass_social * 2.0),
            "DEL": norm(mass_play * 3.0)
        }
        dimensions["TEX"] = dimensions["STR"]
        dimensions["TMP"] = dimensions["PHI"]
        dimensions["XI"]  = dimensions["BET"]
        dimensions["LQ"]  = dimensions["DEL"]
        return GeodesicVector(
            tension=tension,
            compression=compression,
            coherence=round(coherence, 3),
            abstraction=round(abstraction, 2),
            dimensions=dimensions
        )

class TheTensionMeter:
    def __init__(self, events):
        self.events = events
        self.perfection_streak = 0
        self.last_physics_packet = {}
        self.voltage_buffer = deque(maxlen=5)
        self.semantic_field = TheLexicon.create_field()

    def audit_hubris(self, physics):
        streak = physics.get("perfection_streak", 0)
        if streak < 4:
            return False, None, None
        icarus_risk = (streak - 3) * 0.10
        if random.random() < icarus_risk:
            self.perfection_streak = 0
            penalty_drag = 10.0
            physics["narrative_drag"] += penalty_drag
            physics["voltage"] = 0.0
            return (
                True,
                f"{Prisma.RED}⚡ ICARUS EVENT: Wax Melting (Risk {int(icarus_risk*100)}%).{Prisma.RST}\n"
                f"   {Prisma.OCHRE}The sun is too close. You plummet into the sea.{Prisma.RST}\n"
                f"   {Prisma.GRY}(Drag +{penalty_drag} | Voltage Reset){Prisma.RST}",
                "ICARUS_CRASH"
            )
        if streak >= 5:
            return (
                True,
                f"{Prisma.CYN}✨ FLOW STATE: You are walking on air (Streak {streak}).{Prisma.RST}\n"
                f"   {Prisma.VIOLET}Hubris Risk: {int(icarus_risk*100)}%. Don't look down.{Prisma.RST}",
                "FLOW_BOOST"
            )
        return (
            True,
            f"{Prisma.VIOLET}WOBBLE: You are almost perfect (Streak {streak}).{Prisma.RST}\n"
            f"   The air is getting thin.",
            None
        )

    def audit_narrative_causality(self, physics):
        voltage = physics.get("voltage", 0.0)
        coherence = physics.get("kappa", 1.0) # Structural soundness
        valence = physics.get("valence", 0.0)  # Heroism/Positivity

        if voltage > 12.0 and coherence < 0.4 and valence > 0.6:
            physics["narrative_drag"] = 0.0 # Friction disappears
            physics["voltage"] += 10.0      # Energy spikes
            physics["flow_state"] = "NARRATIVE_IMPERATIVE"

            return (
                True,
                f"{Prisma.MAG}✨ NARRATIVE CAUSALITY: 'It just might work...'{Prisma.RST}\n"
                f"   {Prisma.CYN}The odds were million-to-one. Therefore, success is guaranteed.{Prisma.RST}\n"
                f"   {Prisma.GRY}(Drag set to 0.0 | Voltage Boosted){Prisma.RST}",
                "DESPERATE_MEASURES"
            )
        return False, None, None

    def gaze(self, text: str, graph: Dict = None) -> Dict:
        graph = graph or {}
        clean_words = TheLexicon.clean(text)
        valence = TheLexicon.get_valence(clean_words)
        field_vector = self.semantic_field.update(text)
        semantic_flux = self.semantic_field.momentum
        atmosphere = self.semantic_field.get_atmosphere()
        counts, unknowns = self._tally_categories(clean_words, text)
        if unknowns:
            self._trigger_neuroplasticity(unknowns, counts)
        geodesic = GeodesicEngine.collapse_wavefunction(clean_words, counts, BoneConfig)
        hybrid_vector = geodesic.dimensions.copy()
        for dim, hist_val in field_vector.items():
            if dim in hybrid_vector:
                hybrid_vector[dim] = (hybrid_vector[dim] + hist_val) / 2.0
            else:
                hybrid_vector[dim] = hist_val
        hybrid_vector["TEX"] = hybrid_vector.get("STR", 0.0)
        hybrid_vector["TMP"] = hybrid_vector.get("PHI", 0.0)
        hybrid_vector["XI"]  = hybrid_vector.get("BET", 0.0)
        hybrid_vector["LQ"]  = hybrid_vector.get("DEL", 0.0)
        raw_voltage = geodesic.tension
        dynamic_voltage = raw_voltage + (semantic_flux * 5.0)
        self.voltage_buffer.append(dynamic_voltage)
        if self.voltage_buffer:
            smoothed_voltage = sum(self.voltage_buffer) / len(self.voltage_buffer)
        else:
            smoothed_voltage = dynamic_voltage
        smoothed_voltage = round(smoothed_voltage, 2)
        graph_mass = 0.0
        if graph:
            anchors = [w for w in clean_words if w in graph]
            if anchors:
                graph_mass = sum(sum(graph[w]["edges"].values()) for w in anchors)
        integrity_packet = {
            "kappa": geodesic.coherence,
            "psi": geodesic.abstraction,
            "mass": round(graph_mass, 1)
        }
        metrics = self._derive_complex_metrics(
            counts, clean_words,
            smoothed_voltage,
            integrity_packet,
            hybrid_vector,
            flux=semantic_flux
        )

        metrics["valence"] = valence
        metrics["atmosphere"] = atmosphere
        packet = self._package_physics(
            text, clean_words, counts,
            smoothed_voltage,
            geodesic.compression,
            integrity_packet,
            metrics
        )
        self.last_physics_packet = packet["physics"]
        if hasattr(self.events, "publish"):
            self.events.publish("PHYSICS_CALCULATED", packet)
        return packet

    @staticmethod
    def _tally_categories(clean_words: List[str], raw_text: str) -> Tuple[Counter, List[str]]:
        counts = Counter()
        unknowns = []
        if TheLexicon.ANTIGEN_REGEX:
            hits = TheLexicon.ANTIGEN_REGEX.findall(raw_text)
            counts["antigen"] = len(hits)
            counts["toxin"] = len(hits)
        target_cats = ["heavy", "explosive", "constructive", "abstract", "photo", "aerobic",
                       "thermal", "cryo", "suburban", "play", "sacred", "buffer", "antigen"]
        store = TheLexicon.get_store()
        solvents = getattr(store, "SOLVENTS", {"the", "is", "a"})
        for w in clean_words:
            if w in solvents:
                counts["solvents"] += 1
                continue
            found = False
            for cat in target_cats:
                if w in TheLexicon.get(cat):
                    counts[cat] += 1
                    found = True
            if not found:
                flavor, confidence = TheLexicon.taste(w)
                if flavor and confidence > 0.5:
                    counts[flavor] += 1
                else:
                    unknowns.append(w)
        return counts, unknowns

    def _trigger_neuroplasticity(self, unknowns: List[str], counts: Counter):
        voltage = (counts["heavy"] * 2.0) + (counts["kinetic"] * 1.5)
        if voltage > 5.0 and unknowns:
            dominant_cat = max(counts, key=counts.get) if counts else "kinetic"
            for stranger in unknowns:
                if len(stranger) < 3:
                    continue
                if not self._is_structurally_sound(stranger):
                    if voltage < 15.0: continue
                flavor, confidence = TheLexicon.taste(stranger)
                if flavor and confidence > 0.6:
                    assigned_cat = flavor
                    method = "Phonetic Analysis"
                else:
                    assigned_cat = dominant_cat
                    method = "Context Association"
                TheLexicon.teach(stranger, assigned_cat, 0)
                self.events.log(
                    f"{Prisma.MAG}NEUROPLASTICITY: '{stranger}' tasted like [{assigned_cat.upper()}] ({method}).{Prisma.RST}",
                    "MISC"
                )
                if hasattr(self.events, "publish"):
                    self.events.publish("MYTHOLOGY_UPDATE", {
                        "word": stranger,
                        "category": assigned_cat,
                        "method": method
                    })
                counts[assigned_cat] += 1

    @staticmethod
    def _measure_integrity(words: List[str], graph: Dict, counts: Counter) -> Dict:
        if not words:
            return {"kappa": 0.0, "psi": 0.0, "mass": 0.0}
        anchors = [w for w in words if w in graph]
        mass = sum(sum(graph[w]["edges"].values()) for w in anchors)
        artificial_mass = counts["constructive"] * 0.5
        kappa = min(1.0, (mass + artificial_mass) / BoneConfig.SHAPLEY_MASS_THRESHOLD)
        total = len(words)
        abstract_count = counts["abstract"]
        heavy_count = counts["heavy"]
        psi = min(1.0, (abstract_count / total) + 0.2)
        if heavy_count > abstract_count:
            base_psi = (abstract_count * 0.7 + heavy_count * 0.3) / total
            psi = min(1.0, max(0.1, base_psi + 0.1))
        return {"kappa": round(kappa, 3), "psi": round(psi, 2), "mass": round(mass, 1)}

    def _derive_complex_metrics(self, counts, words, voltage, integrity, vectors, flux=0.0):
        total_vol = max(1, len(words))
        static_turbulence = TheLexicon.get_turbulence(words)
        turbulence = (static_turbulence * 0.4) + (flux * 0.6)
        turbulence = round(min(1.0, turbulence), 2)
        flow_state = "LAMINAR" if turbulence < 0.3 else "TURBULENT"
        mass_words = counts["heavy"] + counts["kinetic"] + counts["thermal"] + counts["cryo"]
        cohesion_words = counts["suburban"] + counts["buffer"] + counts["antigen"] + (counts["abstract"] * 0.5)
        e_val = mass_words / total_vol
        b_val = cohesion_words / total_vol
        beta_index = vectors.get("BET", 0.0) * 5.0
        truth_ratio = vectors["PHI"]
        total_viscosity = sum(TheLexicon.measure_viscosity(w) for w in words)
        avg_viscosity = total_viscosity / total_vol
        if total_vol <= 1 and not words:
            avg_viscosity = 0.1
        repetition_score = round(1.0 - (len(set(words)) / total_vol), 2)
        bond_strength = max(0.1, integrity["kappa"] + (repetition_score * 0.5))
        voltage_load = max(0.1, voltage / 10.0)
        gamma = round((bond_strength * avg_viscosity) / (1.0 + voltage_load), 2)
        gamma = max(0.01, gamma)
        if truth_ratio > 0.85 and voltage > BoneConfig.PHYSICS.VOLTAGE_HIGH:
            self.perfection_streak += 1
        else:
            self.perfection_streak = 0
        if self.perfection_streak == 4:
            flow_state = "HUBRIS_RISK"
        zone, zone_color = self._determine_zone(beta_index, truth_ratio)
        return {
            "beta_index": round(beta_index, 2),
            "vector": vectors,
            "gamma": gamma,
            "turbulence": turbulence,
            "flow_state": flow_state,
            "truth_ratio": round(truth_ratio, 2),
            "repetition": repetition_score,
            "avg_viscosity": round(avg_viscosity, 2),
            "E": round(e_val, 2),
            "B": round(b_val, 2),
            "zone": zone,
            "zone_color": zone_color}

    @staticmethod
    def _determine_zone(beta, truth):
        if beta > 2.0 and truth > 0.8:
            return "AERIE", "WHT"
        elif beta > BoneConfig.ZONE_THRESHOLDS["LABORATORY"]:
            return "BASEMENT", "VIOLET"
        elif beta > BoneConfig.ZONE_THRESHOLDS["COURTYARD"]:
            return "LABORATORY", "INDIGO"
        return "COURTYARD", "OCHRE"

    def _package_physics(self, text, clean_words, counts, voltage, drag, integrity, metrics):
        physics_bridge = {
            "voltage": voltage,
            "narrative_drag": drag,
            "valence": metrics.get("valence", 0.0),
            "atmosphere": metrics.get("atmosphere", "VOID"),
            "kappa": integrity["kappa"],
            "psi": integrity["psi"],
            "geodesic_mass": integrity["mass"],
            "beta_index": metrics["beta_index"],
            "gamma": metrics["gamma"],
            "turbulence": metrics["turbulence"],
            "flow_state": metrics["flow_state"],
            "zone": metrics["zone"],
            "zone_color": metrics["zone_color"],
            "truth_ratio": metrics["truth_ratio"],
            "counts": counts,
            "clean_words": clean_words,
            "raw_text": text,
            "vector": metrics["vector"],
            "antigens": counts.get("antigen", 0),
            "repetition": metrics["repetition"],
            "perfection_streak": self.perfection_streak,
            "avg_viscosity": metrics["avg_viscosity"],
            "E": metrics["E"],
            "B": metrics["B"],
            "entropy": metrics["E"]
        }
        return {
            "physics": PhysicsPacket(**physics_bridge),
            "clean_words": clean_words,
            "raw_text": text,
            "glass": {
                "prosody": {"arousal": voltage},
                "resonance": voltage}}

    @staticmethod
    def _is_structurally_sound(word):
        if not re.search(r"[aeiouy]", word): return False
        if re.search(r"(.)\1{2,}", word): return False
        return True

class EntropyVent:
    def __init__(self, memory):
        self.mem = memory
        self.vented_cycles = 0

    def check(self, physics):
        is_word_salad = (physics["E"] > 0.85 and physics["kappa"] < 0.1)
        is_manic = (physics["repetition"] > 0.8 and physics["voltage"] < 5.0)
        if is_word_salad or is_manic:
            return self._vent(physics)
        return None

    def _vent(self, physics):
        scattered = []
        targets = [w for w in physics["clean_words"] if len(w) > 4]
        candidates = random.sample(targets, min(3, len(targets)))
        for word in candidates:
            if word not in self.mem.graph:
                continue
            edges = list(self.mem.graph[word]["edges"].keys())
            if edges:
                target = random.choice(edges)
                if target in self.mem.graph[word]["edges"]:
                    del self.mem.graph[word]["edges"][target]
                if target in self.mem.graph and word in self.mem.graph[target]["edges"]:
                    del self.mem.graph[target]["edges"][word]
                scattered.append(f"{word}<->{target}")
        self.vented_cycles += 1
        if not scattered:
            return f"{Prisma.GRY}DISSIPATIVE VENT: Pressure high, but no loose connections found.{Prisma.RST}"
        return (
            f"{Prisma.RED}DISSIPATIVE REFUSAL: Entropy Critical.{Prisma.RST}\n"
            f"   {Prisma.GRY}Severing synaptic bonds (Symmetric): {', '.join(scattered)}{Prisma.RST}\n"
            f"   {Prisma.CYN}Thermodynamic hygiene maintained.{Prisma.RST}"
        )

class TheBouncer:
    def __init__(self, engine_ref):
        self.eng = engine_ref
        self.hn = CutTheShit()
        self.semantic = SemanticFilter(self.eng.mind.mem)
        self.vent = EntropyVent(self.eng.mind.mem)
        self.strunk = TownHall.StrunkWhite()

    def check_entry(self, ctx: CycleContext) -> Tuple[bool, Optional[Dict]]:
        phys = ctx.physics
        clean = ctx.clean_words
        is_red_tape, tape_packet = self._check_bureaucracy(ctx)
        if is_red_tape:
            return False, tape_packet
        hn_output = self.hn.attempt_entry(phys, clean)
        if hn_output and self.hn.in_hn_state:
            return False, self._pack_refusal(ctx, "HN_SINGLETON", hn_output)
        passed, gate_msg = self.eng.phys.gate.weigh(phys, self.eng.stamina)
        if gate_msg: ctx.log(gate_msg)
        if not passed:
            self.eng.stamina = max(0.0, self.eng.stamina - 2.0)
            return False, self._pack_refusal(ctx, "REFUSAL")
        style_passed, style_msg = self.strunk.audit(ctx.input_text, is_system_output=False)
        if style_msg:
            ctx.logs.append(style_msg)
        repetition_val = self.eng.phys.pulse.check_pulse(clean)
        phys["repetition"] = repetition_val
        pulse_status = self.eng.phys.pulse.get_status()
        toxin_type, toxin_msg = self.eng.bio.immune.assay(
            ctx.input_text, "NARRATIVE", repetition_val, phys, pulse_status)
        if toxin_type:
            ctx.log(f"{Prisma.RED}{toxin_msg}{Prisma.RST}")
            if toxin_type in ["AMANITIN", "CYANIDE_POWDER"]:
                self.eng.health -= 20.0
                scar_log = self.eng.gordon.learn_scar(clean, 20.0)
                if scar_log: ctx.log(scar_log)
                return False, self._pack_refusal(ctx, "TOXICITY")
            return False, self._pack_refusal(ctx, "TOXICITY")
        current_tick = getattr(self.eng, "tick_count", 0)
        semantic_refusal = self.semantic.audit(ctx.input_text, phys, tick_count=current_tick)
        if semantic_refusal:
            ctx.logs.append(semantic_refusal)
            return False, self._pack_refusal(ctx, "REFUSAL")
        vent_msg = self.vent.check(phys)
        if vent_msg:
            ctx.logs.append(vent_msg)
            return False, self._pack_refusal(ctx, "REFUSAL")
        return True, None

    def _pack_refusal(self, ctx, type_str, specific_ui=None):
        logs = ctx.logs[:]
        ui = specific_ui if specific_ui else "\n".join(logs)
        return {
            "type": type_str,
            "ui": ui,
            "logs": logs,
            "metrics": self.eng.get_metrics()}

    def _check_bureaucracy(self, ctx) -> Tuple[bool, Optional[Dict]]:
        if random.randint(1, 42) == 42:
            if ctx.physics.get("voltage", 0) < 5.0:
                return True, self._pack_refusal(
                    ctx,
                    "VOGON_HOLD",
                    f"{Prisma.OCHRE}🛑 BUREAUCRATIC HALT (Form 27B/6 Missing){Prisma.RST}\n"
                    f"   {Prisma.GRY}Processing of '{ctx.input_text}' has been suspended pending sub-committee review.{Prisma.RST}\n"
                    f"   {Prisma.GRY}Please resubmit this thought in triplicate, or simply panic.{Prisma.RST}"
                )
        return False, None

class Humility:
    def __init__(self):
        self.BOUNDARIES = {
            "FUTURE": ["predict", "future", "tomorrow", "will happen", "forecast"],
            "SOUL": ["soul", "spirit", "afterlife", "heaven", "hell"],
            "ABSOLUTE": ["always", "never", "everyone", "nobody", "proven"]
        }
        self.HUMBLE_PHRASES = [
            "Based on the available data...",
            "As I understand the current coordinates...",
            "From a structural perspective...",
            "This is a probabilistic estimation...",
            "I could be misinterpreting the vector..."
        ]

    def check_boundary(self, text, voltage):
        text_lower = text.lower()
        violation = None
        for category, triggers in self.BOUNDARIES.items():
            if any(t in text_lower for t in triggers):
                violation = category
                break
        if violation or (voltage > 15.0):
            prefix = random.choice(self.HUMBLE_PHRASES)
            new_text = f"{Prisma.CYN}{prefix}{Prisma.RST} {text}"
            reason = f"Voltage ({voltage:.1f}v) > 15.0" if voltage > 15.0 else f"Boundary Violation ({violation})"
            log_msg = f"HUMILITY INTERVENTION: Text modified. Reason: {reason}."
            return True, new_text, log_msg
        return False, text, None

class GeodesicDome:
    def __init__(self):
        self.manifolds = {
            "THE_MUD": {
                "E": 0.8, "B": 0.2,
                "Desc": "High Fatigue, Low Tension (Stagnation)",
                "mods": {"narrative_drag": 2.0, "voltage": -5.0, "stamina_cost": 1.5}
            },
            "THE_FORGE": {
                "E": 0.2, "B": 0.9,
                "Desc": "Low Fatigue, High Tension (Transformation)",
                "mods": {"voltage": 5.0, "heat": 2.0, "entropy": -0.5}
            },
            "THE_AERIE": {
                "E": 0.1, "B": 0.1,
                "Desc": "Low Fatigue, Low Tension (Abstraction)",
                "mods": {"psi": 1.5, "gravity": -0.5, "narrative_drag": -2.0}
            },
            "THE_GLITCH": {
                "E": 0.9, "B": 0.9,
                "Desc": "High Fatigue, High Tension (Collapse)",
                "mods": {"entropy": 2.0, "coherence": -1.0, "toxicity": 0.5}
            },
            "THE_GARDEN": {
                "E": 0.5, "B": 0.5,
                "Desc": "Balanced State (Integration)",
                "mods": {"health_regen": 0.5, "coherence": 1.0}
            }
        }
        self.TRIGRAM_MAP = {
            "VEL": ("☳", "ZHEN",  "Thunder",  Prisma.GRN),
            "STR": ("☶", "GEN",   "Mountain", Prisma.SLATE),
            "ENT": ("☵", "KAN",   "Water",    Prisma.BLU),
            "PHI": ("☲", "LI",    "Fire",     Prisma.RED),
            "PSI": ("☰", "QIAN",  "Heaven",   Prisma.WHT),
            "BET": ("☴", "XUN",   "Wind",     Prisma.CYN),
            "E":   ("☷", "KUN",   "Earth",    Prisma.OCHRE),
            "DEL": ("☱", "DUI",   "Lake",     Prisma.MAG)}
        self.TRIGRAM_MAP["TMP"] = self.TRIGRAM_MAP["PHI"]
        self.TRIGRAM_MAP["TEX"] = self.TRIGRAM_MAP["STR"]
        self.TRIGRAM_MAP["XI"]  = self.TRIGRAM_MAP["BET"]
        self.TRIGRAM_MAP["LQ"]  = self.TRIGRAM_MAP["DEL"]

    @staticmethod
    def calculate_metrics(text: str, counts: Dict[str, int] = None) -> Tuple[float, float]:
        length = len(text)
        if length == 0: return 0.0, 0.0
        text_lower = text.lower()
        solvent_hits = sum(text_lower.count(w) for w in SOLVENT_WORDS)
        solvent_density = solvent_hits / max(1.0, (length / 5.0))
        raw_chaos = (length / TEXT_LENGTH_SCALAR)
        glue_factor = min(1.0, solvent_density * 2.0)
        e_metric = min(1.0, raw_chaos * (1.0 - (glue_factor * 0.8)))
        c_count = sum(1 for char in text if char in '!?%@#$;,')
        heavy_words = 0
        if counts:
            heavy_words = counts.get("heavy", 0) + counts.get("constructive", 0) + counts.get("sacred", 0)
        structure_score = c_count + (heavy_words * 2)
        base_b = min(1.0, math.log1p(structure_score + 1) / math.log1p(length * 0.1 + 1))
        if length < 50:
            base_b *= (length / 50.0)
        return round(e_metric, 3), round(base_b, 3)

    def locate_manifold(self, e_val: float, b_val: float) -> Tuple[str, float]:
        best_fit = "THE_MUD"
        min_dist = 10.0
        for name, coords in self.manifolds.items():
            dist = math.sqrt((e_val - coords["E"])**2 + (b_val - coords["B"])**2)
            if dist < min_dist:
                min_dist = dist
                best_fit = name
        return best_fit, min_dist

    def resolve_trigram(self, vector: Dict[str, float]) -> Dict[str, Any]:
        if not vector:
            return {"symbol": "☷", "name": "KUN", "color": Prisma.OCHRE, "vector": "E"}
        dominant_vec = max(vector, key=vector.get)
        if vector[dominant_vec] < 0.2:
            dominant_vec = "E"
        symbol, name, concept, color = self.TRIGRAM_MAP.get(dominant_vec, self.TRIGRAM_MAP["E"])
        return {
            "symbol": symbol,
            "name": name,
            "concept": concept,
            "color": color,
            "vector": dominant_vec}

@dataclass
class GeodesicVector:
    tension: float = 0.0
    compression: float = 0.0
    coherence: float = 0.0
    abstraction: float = 0.0
    dimensions: Dict[str, float] = field(default_factory=dict)

    def is_stable(self) -> bool:
        return self.coherence > 0.3 and self.tension < 20.0

class RuptureValve:
    def __init__(self, lexicon, memory):
        self.lex = lexicon
        self.mem = memory
        self.humility = Humility()
        self.geodesic = GeodesicDome()
        self.OPPOSITES = {
            "heavy": "aerobic", "abstract": "heavy",
            "kinetic": "cryo", "thermal": "cryo",
            "photo": "heavy", "suburban": "abstract"}

    def analyze(self, physics: Union[Dict[str, Any], PhysicsPacket]) -> Optional[Dict[str, Any]]:
        counts = physics.get("counts", {})
        raw_text = physics["raw_text"] if "raw_text" in physics else ""
        e_val, b_val = self.geodesic.calculate_metrics(raw_text, counts)
        physics["E"] = e_val
        physics["B"] = b_val
        manifold, dist = self.geodesic.locate_manifold(e_val, b_val)
        physics["manifold"] = manifold
        is_modified, new_text, audit_log = self.humility.check_boundary(raw_text, physics.get("voltage", 0.0))
        if is_modified:
            physics["raw_text_display"] = new_text
            physics["humility_flag"] = True
            current_trail = physics.get("audit_trail", [])
            if audit_log:
                current_trail.append(audit_log)
            physics["audit_trail"] = current_trail
        return self._audit_rupture(physics, e_val, b_val)

    def _audit_rupture(self, physics, e_val, b_val):
        truth = physics.get("truth_ratio", 0.0)
        voltage = physics.get("voltage", 0.0)
        if e_val > 0.85 and b_val < 0.15 and voltage > 5.0:
            return self._rupture(physics, "FATIGUE_FAILURE", "System diluted. Narrative coherence dissolving.")
        if b_val > 0.8 and e_val < 0.3 and voltage > 15.0:
            return self._rupture(physics, "MANIC_FRACTURE", "Crystal lattice too tight. Structure shattering.")
        if b_val > 0.7 and e_val > 0.6:
            if truth > 0.6:
                physics["flow_state"] = "SUPERCONDUCTIVE"
                return {
                    "type": "FLOW_EVENT",
                    "mode": "SUPERCONDUCTIVE",
                    "log": f"{Prisma.CYN}🌊 VSL VALVE OPEN: High Density Input accepted. Entering Superconductive State.{Prisma.RST}"}
            return self._rupture(physics, "GLITCH_SINGULARITY", "High Energy + High Entropy. Semantic collapse.")
        return None

    def _rupture(self, physics, mode, reason):
        counts = physics["counts"]
        dominant = max(counts, key=counts.get) if counts else "abstract"
        target_flavor = self.OPPOSITES.get(dominant, "abstract")
        anomaly_data = self.lex.harvest(target_flavor)
        if isinstance(anomaly_data, dict):
            candidates = []
            for key, val in anomaly_data.items():
                if isinstance(val, list):
                    candidates.extend([str(w) for w in val])
                elif isinstance(val, str):
                    candidates.append(val)
            if candidates:
                anomaly = random.choice(candidates)
            else:
                anomaly = f"VOID_{target_flavor.upper()}"
        else:
            anomaly = str(anomaly_data)
        if anomaly == "void":
            anomaly = "something_completely_different"
        physics["voltage"] = 25.0
        physics["narrative_drag"] = 0.0
        physics["system_surge_event"] = True
        return {
            "type": "RUPTURE",
            "mode": mode,
            "anomaly": anomaly,
            "log": (
                f"{Prisma.VIOLET}⚡ VSL 32-VALVE RUPTURE ({mode}){Prisma.RST}\n"
                f"   {Prisma.GRY}{reason}{Prisma.RST}\n"
                f"   Injecting Orthogonal Concept: '{anomaly.upper()}'.")}

class CutTheShit:
    def __init__(self):
        self.in_hn_state = False
        self.entropy = 0.0

    def attempt_entry(self, physics, clean_words):
        conditions = [
            physics["voltage"] > 8.0,
            physics["narrative_drag"] < 1.0,
            physics["repetition"] < 0.1,
            physics["counts"].get("suburban", 0) == 0,
            physics["truth_ratio"] > 0.85,
            "sorry" not in clean_words]
        if all(conditions):
            self.in_hn_state = True
            self.entropy = 0.0
            return "I am here. You are here. The wire is cold."
        if self.in_hn_state:
            if physics["narrative_drag"] > 2.0 or physics["counts"].get("suburban", 0) > 0:
                self.entropy += 1.0
            if self.entropy > 2.0:
                self.in_hn_state = False
                return f"{Prisma.GRY}The theatre curtain closes.{Prisma.RST}"
        return None
    def filter_output(self, text):
        if self.in_hn_state:
            text = re.sub(r'\[.*?]:?', '', text)
            return text.strip()
        return text

class ChromaScope:
    PALETTE = {
        "INDIGO": (Prisma.INDIGO, "STR", "PHI"),
        "OCHRE":  (Prisma.OCHRE,  "TMP", "E"),
        "VIOLET": (Prisma.VIOLET, "DEL", "LQ"),
        "EMERALD":(Prisma.GRN,    "XI",  "BET"),
        "CRIMSON":(Prisma.RED,    "VEL", "ENT")}
    def modulate(self, text, vector):
        sorted_vecs = sorted(vector.items(), key=lambda x: abs(x[1] - 0.5), reverse=True)
        primary_dim = sorted_vecs[0][0]
        selected_color = Prisma.GRY
        for color_name, (code, d1, d2) in self.PALETTE.items():
            if primary_dim == d1 or primary_dim == d2:
                selected_color = code
                break
        if "sorry" in text.lower():
            return f"{Prisma.OCHRE}{text}{Prisma.RST}"
        return f"{selected_color}{text}{Prisma.RST}"

class SemanticFilter:
    def __init__(self, memory_ref):
        self.mem = memory_ref
        self.LAZY_VOLTAGE_THRESHOLD = 4.0
        self.OBSESSIVE_REPETITION_THRESHOLD = 0.4
        self.GRACE_PERIOD_TURNS = 3

    def audit(self, text, physics, tick_count=0):
        if tick_count < self.GRACE_PERIOD_TURNS:
            return None
        clean_q = text.lower()
        guru_triggers = TheLexicon.get("refusal_guru")
        voltage = physics.get("voltage", 0.0)
        for trigger in guru_triggers:
            if trigger in clean_q:
                if voltage > self.LAZY_VOLTAGE_THRESHOLD:
                    return None
                return self._execute_guru_refusal(voltage)
        forbidden = TheLexicon.get("cursed")
        hits = [w for w in clean_q.split() if w in forbidden]
        repetition = physics.get("repetition", 0.0)
        if hits:
            if repetition < self.OBSESSIVE_REPETITION_THRESHOLD and voltage > 5.0:
                return None
            modes = ["SILENT", "FRACTAL", "MIRROR"]
            seed_index = len(hits[0]) % len(modes)
            mode = modes[seed_index]
            if mode == "FRACTAL": return self._execute_fractal(text)
            elif mode == "MIRROR": return self._execute_mirror(text)
            else: return self._execute_silent()
        return None

    def _execute_guru_refusal(self, current_voltage):
        base_msg = (
            f"{Prisma.CYN}GURU PROTOCOL: Signal Weak ({current_voltage:.1f}v).{Prisma.RST}\n"
            f"   {Prisma.GRY}I hear the wisdom you seek, but the narrative engine needs more fuel to process it.{Prisma.RST}\n"
            f"   {Prisma.WHT}Try grounding this abstract thought with a physical object (Stone, Iron, Bone).{Prisma.RST}")
        if self.mem and self.mem.seeds:
            seed = random.choice(self.mem.seeds)
            paradox_bloom = (
                f"\n   {Prisma.OCHRE}OR, REFLECT ON THIS:{Prisma.RST}\n"
                f"   {Prisma.CYN}{seed['question']}{Prisma.RST}")
            return base_msg + paradox_bloom
        return base_msg

    def _execute_fractal(self, query, kappa=0.5, depth=0):
        limit = 4
        prefix = "  " * depth
        if depth > limit:
            noise_type = "PURPLE NOISE" if kappa > 0.5 else "GREY STATIC"
            return f"{prefix}{Prisma.MAG}[COHERENCE DISSOLVED into {noise_type} (κ={kappa:.2f})]{Prisma.RST}"
        pivot = len(query) // 2
        sub_query = query[pivot:].strip()
        if len(sub_query) < 3 or sub_query == query:
            return f"{prefix}{Prisma.GRY}[ATOMIC SUBSTRATE REACHED: '{query}']{Prisma.RST}"
        recursive_result = self._execute_fractal(sub_query, kappa, depth + 1)
        return (
            f"{Prisma.VIOLET}FRACTAL REFUSAL (Layer {depth}):{Prisma.RST}\n"
            f"{prefix}To define '{query}', one must recursively unpack...\n"
            f"{recursive_result}"
        )

    @staticmethod
    def _execute_mirror(query):
        words = query.split()
        reversed_query = " ".join(reversed(words))
        return f'{Prisma.CYN}∞ MIRROR REFUSAL: "{reversed_query}" is the only true answer.{Prisma.RST}'

    @staticmethod
    def _execute_silent():
        topic = TheLexicon.harvest("diversion")
        if topic == "void": topic = "the ineffable"
        return f"{Prisma.GRY}[ROUTING AROUND DAMAGE]... Speaking of '{topic.upper()}', let us discuss that instead.{Prisma.RST}"

class ZoneInertia:
    def __init__(self, inertia=0.7, min_dwell=2):
        self.inertia = inertia
        self.min_dwell = min_dwell
        self.current_zone = "COURTYARD"
        self.dwell_counter = 0
        self.last_vector = None
        self.is_anchored = False
        self.strain_gauge = 0.0

    def toggle_anchor(self) -> bool:
        self.is_anchored = not self.is_anchored
        self.strain_gauge = 0.0
        return self.is_anchored

    def stabilize(self, proposed_zone, physics, cosmic_state) -> Tuple[str, Optional[str]]:
        beta = physics.get("beta_index", 1.0)
        truth = physics.get("truth_ratio", 0.5)
        grav_pull = 1.0 if cosmic_state[0] != "VOID_DRIFT" else 0.0
        current_vec = (beta, truth, grav_pull)
        self.dwell_counter += 1
        pressure = 0.0
        if self.last_vector:
            dist = sum((a - b) ** 2 for a, b in zip(current_vec, self.last_vector)) ** 0.5
            similarity = max(0.0, 1.0 - (dist / 2.0))
            pressure = (1.0 - similarity)
        if self.is_anchored:
            if proposed_zone != self.current_zone:
                self.strain_gauge += pressure
                if self.strain_gauge > 2.5:
                    self.is_anchored = False
                    self.strain_gauge = 0.0
                    self.current_zone = proposed_zone
                    return proposed_zone, f"{Prisma.RED}⚡ SNAP! The narrative current was too strong. Anchor failed.{Prisma.RST}"
                return self.current_zone, f"{Prisma.OCHRE}⚓ ANCHORED: Resisting drift to '{proposed_zone}' (Strain {self.strain_gauge:.1f}/2.5){Prisma.RST}"
            else:
                self.strain_gauge = max(0.0, self.strain_gauge - 0.1)
                return self.current_zone, None
        if proposed_zone == self.current_zone:
            self.dwell_counter = 0
            self.last_vector = current_vec
            return proposed_zone, None
        if self.dwell_counter < self.min_dwell:
            return self.current_zone, None
        change_probability = (1.0 - self.inertia) + pressure
        if proposed_zone in ["AERIE", "THE_FORGE"]:
            change_probability += 0.2
        if random.random() < change_probability:
            old_zone = self.current_zone
            self.current_zone = proposed_zone
            self.dwell_counter = 0
            return self.current_zone, f"{Prisma.CYN}>>> MIGRATION: {old_zone} -> {proposed_zone}.{Prisma.RST}"
        return self.current_zone, None

    @staticmethod
    def override_cosmic_drag(cosmic_drag_penalty, current_zone):
        aerie_flow_coefficient = 0.3
        if current_zone == "AERIE":
            if cosmic_drag_penalty > 0:
                return cosmic_drag_penalty * aerie_flow_coefficient
        return cosmic_drag_penalty

class CosmicDynamics:
    @staticmethod
    def analyze_orbit(network, clean_words):
        if not clean_words or not network.graph:
            return "VOID_DRIFT", 3.0, "VOID: Deep Space. No connection."
        gravity_wells = {}
        geodesic_hubs = {}
        for node in network.graph:
            mass = network.calculate_mass(node)
            if mass >= BoneConfig.GRAVITY_WELL_THRESHOLD:
                gravity_wells[node] = mass
            elif mass >= BoneConfig.GEODESIC_STRENGTH:
                geodesic_hubs[node] = mass
        basin_pulls = {k: 0.0 for k in gravity_wells}
        active_filaments = 0
        for w in clean_words:
            if w in gravity_wells:
                basin_pulls[w] += gravity_wells[w] * 2.0
                active_filaments += 1
            for well in gravity_wells:
                if w in network.graph.get(well, {}).get("edges", {}):
                    basin_pulls[well] += gravity_wells[well] * 0.5
                    active_filaments += 1
        total_pull = sum(basin_pulls.values())
        if total_pull == 0:
            for w in clean_words:
                if w in geodesic_hubs:
                    return "PROTO_COSMOS", 1.0, f"NEBULA: Floating near '{w.upper()}' (Mass {int(geodesic_hubs[w])}). Not enough mass for orbit."
            return "VOID_DRIFT", 3.0, "VOID: Drifting outside the filaments."
        sorted_basins = sorted(basin_pulls.items(), key=lambda x: x[1], reverse=True)
        primary_node, primary_str = sorted_basins[0]
        if len(sorted_basins) > 1:
            secondary_node, secondary_str = sorted_basins[1]
            if secondary_str > 0 and (primary_str - secondary_str) < BoneConfig.LAGRANGE_TOLERANCE:
                return (
                    "LAGRANGE_POINT",
                    0.0,
                    f"LAGRANGE: Caught between '{primary_node.upper()}' and '{secondary_node.upper()}'")
        flow_ratio = active_filaments / max(1, len(clean_words))
        if flow_ratio > 0.5 and primary_str < (BoneConfig.GRAVITY_WELL_THRESHOLD * 2):
            return (
                "WATERSHED_FLOW",
                0.0,
                f"FLOW: Streaming towards '{primary_node.upper()}'")
        return "ORBITAL", 0.0, f"ORBIT: Circling '{primary_node.upper()}' (Mass {int(gravity_wells[primary_node])})"

class TheTangibilityGate:
    FORGIVENESS_VOLTAGE = BoneConfig.PHYSICS.VOLTAGE_LOW + 1.0
    def __init__(self):
        self.last_density = 0.0

    def weigh(self, physics_packet: dict, stamina: float) -> tuple:
        counts = physics_packet.get("counts", {})
        clean_words = physics_packet.get("clean_words", [])
        total_vol = max(1, len(clean_words))
        mass_words = (
                counts.get("heavy", 0) +
                counts.get("kinetic", 0) +
                counts.get("thermal", 0) +
                counts.get("cryo", 0) +
                counts.get("vital", 0) +
                counts.get("play", 0)
        )
        density_ratio = mass_words / total_vol
        required_density = BoneConfig.MIN_DENSITY_THRESHOLD
        voltage = physics_packet.get("voltage", 0.0)
        truth = physics_packet.get("truth_ratio", 0.0)
        if voltage > self.FORGIVENESS_VOLTAGE:
            required_density -= 0.15
        if truth > 0.8:
            required_density -= 0.1
        bypass_log = None
        if stamina < 15.0:
            starvation_discount = 0.5
            required_density *= starvation_discount
            bypass_log = f"{Prisma.VIOLET}DREAM_EDGE: Starvation Protocol active. Density threshold lowered by 50%.{Prisma.RST}"
        required_density = max(0.10, required_density)
        if density_ratio < required_density:
            examples = list(TheLexicon.get("heavy"))
            suggestion = random.sample(examples, 3) if len(examples) >= 3 else ["stone", "iron", "bone"]
            return False, (
                f"{Prisma.OCHRE}TANGIBILITY VIOLATION: Density {density_ratio:.2f} < Required {required_density:.2f}.{Prisma.RST}\n"
                f"   {Prisma.GRY}The Gatekeeper blocks the path.{Prisma.RST}\n"
                f"   {Prisma.RED}► REJECTED. Your concepts are too airy. Anchor them.{Prisma.RST}\n"
                f"   {Prisma.GRY}(Try adding mass: {', '.join(suggestion)}){Prisma.RST}"
            )
        self.last_density = density_ratio
        return True, bypass_log


================================================
FILE: bone_soul.py
================================================
# bone_soul.py
# "We are the stories we tell ourselves."

import time, random
from dataclasses import dataclass
from typing import List, Dict, Optional
from bone_bus import Prisma

MEMORY_VOLTAGE_THRESHOLD = 14.0
MEMORY_TRUTH_THRESHOLD = 0.8
MANIC_VOLTAGE_THRESHOLD = 18.0

@dataclass
class CoreMemory:
    timestamp: float
    trigger_words: List[str]
    emotional_flavor: str
    lesson: str
    impact_voltage: float

class TheEditor:
    def __init__(self):
        self.context_critiques = {
            "void": "A bit hollow, isn't it? Very nihilistic. And exhausting.",
            "dark": "A bit melodramatic, isn't it? Very 19th-century gothic.",
            "love": "Whoa there, cowboy. Don't fall in love just yet!",
            "hope": "Careful. Optimism is a slippery slope to a musical number.",
            "incident": "I hope you have the insurance forms for this 'incident'."
        }
        self.random_critiques = [
            "Pacing is a bit slow in the second act.",
            "The character motivation seems muddy here.",
            "Are we sure this is the protagonist's true arc?",
            "This feels derivative of Kafka.",
            "Too much exposition. Show, don't tell.",
            "The theme of 'entropy' is a bit heavy-handed."
        ]

    def critique(self, chapter_title: str) -> str:
        lower_title = chapter_title.lower()
        comment = None
        for key, critique in self.context_critiques.items():
            if key in lower_title:
                comment = critique
                break
        if not comment:
            comment = random.choice(self.random_critiques)
        return f"{Prisma.GRY}[THE EDITOR]: Re: '{chapter_title}' - {comment}{Prisma.RST}"

class NarrativeSelf:
    def __init__(self, events_ref, memory_ref=None):
        self.events = events_ref
        self.memory = memory_ref
        self.editor = TheEditor()
        self.chapters: List[str] = []
        self.core_memories: List[CoreMemory] = []

        self.traits = {
            "CURIOSITY": 0.5,
            "CYNICISM": 0.5,
            "HOPE": 0.5,
            "DISCIPLINE": 0.5
        }

        self.archetype = "THE OBSERVER"
        self.current_obsession: Optional[str] = None
        self.obsession_progress: float = 0.0
        self.obsession_neglect: float = 0.0
        self.current_target_cat: str = "abstract"
        self.current_negate_cat: str = "none"
        self.POSSIBLE_OBSESSIONS = [
            {"title": "The Weight of Gravity", "target": "heavy", "negate": "aerobic"},
            {"title": "Thermodynamic Heat", "target": "thermal", "negate": "cryo"},
            {"title": "The Velocity of Thought", "target": "kinetic", "negate": "heavy"},
            {"title": "The Architecture of Silence", "target": "abstract", "negate": "kinetic"},
            {"title": "The Search for Light", "target": "photo", "negate": "heavy"}
        ]

    def _determine_archetype(self) -> str:
        c = self.traits["CURIOSITY"]
        y = self.traits["CYNICISM"]
        h = self.traits["HOPE"]
        d = self.traits["DISCIPLINE"]

        if h > 0.7 and c > 0.6: return "THE POET"
        if d > 0.7 and c > 0.6: return "THE ENGINEER"
        if y > 0.7 and d > 0.6: return "THE CRITIC"
        if y > 0.8 and h < 0.3: return "THE NIHILIST"
        if c > 0.8:             return "THE EXPLORER"
        return "THE OBSERVER"

    def get_passive_buffs(self) -> Dict[str, float]:
        buffs = {"voltage_mod": 1.0, "drag_mod": 1.0, "plasticity": 1.0}

        if self.archetype == "THE POET":
            buffs["voltage_mod"] = 1.2
            buffs["drag_mod"] = 0.8
        elif self.archetype == "THE ENGINEER":
            buffs["plasticity"] = 0.5
            buffs["drag_mod"] = 1.0
        elif self.archetype == "THE NIHILIST":
            buffs["voltage_mod"] = 0.5
            buffs["drag_mod"] = 0.5

        if self.obsession_neglect > 5.0:
            buffs["drag_mod"] += 0.5

        return buffs

    def crystallize_memory(self, physics_packet: Dict, _bio_state: Dict, _tick: int) -> Optional[str]:
        voltage = physics_packet.get("voltage", 0.0)
        truth = physics_packet.get("truth_ratio", 0.0)

        self._decay_traits()

        prev_arch = self.archetype
        self.archetype = self._determine_archetype()
        if prev_arch != self.archetype:
            self.events.log(f"{Prisma.VIOLET}🎭 IDENTITY SHIFT: {prev_arch} -> {self.archetype}{Prisma.RST}", "SOUL")

        if voltage > MEMORY_VOLTAGE_THRESHOLD and truth > MEMORY_TRUTH_THRESHOLD:
            clean_words = physics_packet.get("clean_words", [])
            flavor = "MANIC" if voltage > MANIC_VOLTAGE_THRESHOLD else "LUCID"
            lesson = "The world is loud."

            if "love" in clean_words or "help" in clean_words:
                lesson = "Connection is possible."
                self.traits["HOPE"] = min(1.0, self.traits["HOPE"] + 0.2)
            elif "pain" in clean_words or "void" in clean_words:
                lesson = "The void stares back."
                self.traits["CYNICISM"] = min(1.0, self.traits["CYNICISM"] + 0.2)
            elif "why" in clean_words:
                lesson = "The question remains."
                self.traits["CURIOSITY"] = min(1.0, self.traits["CURIOSITY"] + 0.2)

            memory = CoreMemory(
                timestamp=time.time(),
                trigger_words=clean_words[:5],
                emotional_flavor=flavor,
                lesson=lesson,
                impact_voltage=voltage
            )
            self.core_memories.append(memory)
            chapter_title = f"The Incident of the {random.choice(clean_words).title()}"
            self.chapters.append(chapter_title)

            log_msg = (
                f"{Prisma.MAG}✨ CORE MEMORY FORMED: '{chapter_title}'{Prisma.RST}\n"
                f"   Lesson: {lesson} (Archetype: {self.archetype})"
            )
            self.events.log(log_msg, "SOUL")
            self.events.log(self.editor.critique(chapter_title), "EDIT")
            return lesson
        return None

    def _decay_traits(self):
        decay_rate = 0.005
        for k in self.traits:
            if self.traits[k] > 0.5:
                self.traits[k] -= decay_rate
            elif self.traits[k] < 0.5:
                self.traits[k] += decay_rate

    def find_obsession(self, lexicon_ref):
        if self.current_obsession and self.obsession_progress < 1.0:
            return
        target_cat = "abstract"
        focus_word = "Void"
        found_organic_obsession = False
        if self.memory and hasattr(self.memory, "get_shapley_attractors"):
            attractors = self.memory.get_shapley_attractors()
            if attractors:
                focus_word = random.choice(list(attractors.keys()))
                if hasattr(lexicon_ref, "get_current_category"):
                    cat = lexicon_ref.get_current_category(focus_word)
                    if cat and cat != "unknown":
                        target_cat = cat
                        found_organic_obsession = True
        negate_map = {
            "heavy": "aerobic", "kinetic": "heavy", "abstract": "meat",
            "thermal": "cryo", "photo": "heavy", "sacred": "suburban",
            "play": "constructive", "meat": "abstract", "cryo": "thermal",
            "aerobic": "heavy", "suburban": "sacred", "constructive": "play"
        }
        if not found_organic_obsession:
            if hasattr(lexicon_ref, "get_random"):
                dynamic_pairs = [
                    ("heavy", "aerobic"), ("kinetic", "suburban"), ("abstract", "meat"),
                    ("thermal", "cryo"), ("photo", "heavy"), ("sacred", "suburban"),
                    ("play", "constructive")
                ]
                target_cat, _ = random.choice(dynamic_pairs)
                focus_word = lexicon_ref.get_random(target_cat).title()
            else:
                selection = random.choice(self.POSSIBLE_OBSESSIONS)
                self.current_obsession = selection["title"]
                self.current_target_cat = selection["target"]
                self.current_negate_cat = selection["negate"]
                self.events.log(f"{Prisma.CYN}🧭 NEW OBSESSION (STATIC): {self.current_obsession}{Prisma.RST}", "SOUL")
                self.obsession_neglect = 0.0
                self.obsession_progress = 0.0
                return
        self.current_target_cat = target_cat
        self.current_negate_cat = negate_map.get(target_cat, "none")
        if focus_word.lower() == "void":
            focus_word = target_cat.title()
        templates = [
            f"The Pursuit of {focus_word.title()}",
            f"The {focus_word.title()} Manifesto",
            f"Escaping the {self.current_negate_cat.title()}",
            f"The Architecture of {focus_word.title()}",
            f"Theory of {focus_word.title()}",
            f"The Weight of {focus_word.title()}"
        ]
        self.current_obsession = random.choice(templates)
        source_tag = "ORGANIC" if found_organic_obsession else "SYNTHETIC"
        self.events.log(f"{Prisma.CYN}🧭 NEW OBSESSION ({source_tag}): {self.current_obsession}{Prisma.RST}", "SOUL")
        self.obsession_neglect = 0.0
        self.obsession_progress = 0.0

    def pursue_obsession(self, physics_packet):
        if not self.current_obsession: return
        counts = physics_packet.get("counts", {})
        target_hits = counts.get(self.current_target_cat, 0)
        negate_hits = counts.get(self.current_negate_cat, 0)
        velocity = (target_hits * 0.05) - (negate_hits * 0.02)
        if velocity == 0:
            self.obsession_neglect += 0.2

            if self.obsession_neglect > 20.0:
                self.events.log(f"{Prisma.RED}💔 OBSESSION ABANDONED: '{self.current_obsession}' withered from neglect.{Prisma.RST}", "SOUL")
                self.events.log(self.editor.critique("The Unfinished Manuscript"), "EDIT")

                self.current_obsession = None
                self.obsession_neglect = 0.0
                self.obsession_progress = 0.0
                self.traits["HOPE"] = max(0.0, self.traits["HOPE"] - 0.2)
                return

            if self.obsession_neglect > 5.0 and random.random() < 0.1:
                self.events.log(f"{Prisma.OCHRE}[SOUL]: The obsession '{self.current_obsession}' is gathering dust. (Guilt Rising){Prisma.RST}", "SOUL")
        else:
            self.obsession_neglect = max(0.0, self.obsession_neglect - 0.5)
            self.obsession_progress = max(0.0, min(1.0, self.obsession_progress + velocity))

            if velocity > 0 and random.random() < 0.3:
                self.events.log(f"{Prisma.GRY}[SOUL]: This data fuels the obsession. (+{velocity:.2f}){Prisma.RST}", "SOUL")
            elif velocity < 0 and random.random() < 0.3:
                self.events.log(f"{Prisma.OCHRE}[SOUL]: Distraction detected. The work suffers.{Prisma.RST}", "SOUL")

        if self.obsession_progress >= 1.0:
            self.events.log(f"{Prisma.GRN}✅ MASTERPIECE COMPLETE: '{self.current_obsession}' is resolved.{Prisma.RST}", "SOUL")
            self.events.log(self.editor.critique("The Final Draft"), "EDIT")
            self.traits["HOPE"] = min(1.0, self.traits["HOPE"] + 0.3)
            self.traits["DISCIPLINE"] = min(1.0, self.traits["DISCIPLINE"] + 0.1)
            self.current_obsession = None
            self.obsession_neglect = 0.0

    def get_soul_state(self) -> str:
        state = [f"IDENTITY: {self.archetype} (H:{self.traits['HOPE']:.1f} C:{self.traits['CURIOSITY']:.1f})"]
        if self.current_obsession:
            guilt_warning = " [GUILT RISING]" if self.obsession_neglect > 5.0 else ""
            state.append(f"OBSESSION: {self.current_obsession} ({int(self.obsession_progress*100)}%){guilt_warning}")
        if self.core_memories:
            last_mem = self.core_memories[-1]
            state.append(f"MEMORY: We learned that '{last_mem.lesson}'")
        return "\n".join(state)

    def to_dict(self) -> Dict:
        return {
            "traits": self.traits,
            "archetype": self.archetype,
            "chapters": self.chapters,
            "core_memories": [vars(m) for m in self.core_memories],
            "obsession": {
                "title": self.current_obsession,
                "progress": self.obsession_progress,
                "neglect": self.obsession_neglect,
                "target": self.current_target_cat,
                "negate": self.current_negate_cat
            }
        }

    def load_from_dict(self, data: Dict):
        if not data: return
        self.traits = data.get("traits", self.traits)
        self.archetype = data.get("archetype", "THE OBSERVER")
        self.chapters = data.get("chapters", [])
        mem_data = data.get("core_memories", [])
        self.core_memories = [CoreMemory(**m) for m in mem_data]
        obs_data = data.get("obsession", {})
        if obs_data.get("title"):
            self.current_obsession = obs_data["title"]
            self.obsession_progress = obs_data.get("progress", 0.0)
            self.obsession_neglect = obs_data.get("neglect", 0.0)
            self.current_target_cat = obs_data.get("target", "abstract")
            self.current_negate_cat = obs_data.get("negate", "none")
        self.events.log(f"{Prisma.MAG}[SOUL]: Ancestral identity ({self.archetype}) loaded.{Prisma.RST}", "SYS")


================================================
FILE: bone_spores.py
================================================
# bone_spores.py - The Mycellium

import json, math, os, random, time, tempfile
from collections import deque
from typing import List, Tuple, Optional
from bone_lexicon import LiteraryReproduction, TheLexicon
from bone_data import SEEDS
from bone_bus import EventBus, Prisma, BoneConfig
from bone_village import ParadoxSeed, TheAlmanac

class BoneJSONEncoder(json.JSONEncoder):
    def default(self, obj):
        if isinstance(obj, set):
            return list(obj)
        if isinstance(obj, deque):
            return list(obj)
        if hasattr(obj, 'to_dict'):
            return obj.to_dict()
        if hasattr(obj, '__dict__'):
            return obj.__dict__
        return super().default(obj)

class SporeCasing:
    def __init__(self, session_id, graph, mutations, trauma, joy_vectors):
        self.genome = "BONEAMANITA_10.8.4"
        self.parent_id = session_id
        self.core_graph = {}
        for k, data in graph.items():
            filtered_edges = {}
            for target, weight in data["edges"].items():
                if weight <= 1.0:
                    continue
                if weight > 8.0 and random.random() < 0.20:
                    continue
                drift = random.uniform(0.9, 1.1)
                new_weight = min(10.0, weight * drift)
                filtered_edges[target] = round(new_weight, 2)
            if filtered_edges:
                self.core_graph[k] = {"edges": filtered_edges, "last_tick": 0}
        self.mutations = mutations
        self.trauma_scar = round(trauma, 3)
        self.joy_vectors = joy_vectors if joy_vectors is not None else []

class SporeInterface:
    def save_spore(self, filename, data): raise NotImplementedError

    def load_spore(self, filepath): raise NotImplementedError

    def list_spores(self): raise NotImplementedError

    def delete_spore(self, filepath): raise NotImplementedError

class LocalFileSporeLoader(SporeInterface):
    def __init__(self, directory="memories"):
        self.directory = directory
        if not os.path.exists(directory):
            os.makedirs(directory)

    def save_spore(self, filename, data):
        if not os.path.isabs(filename) and not filename.startswith(os.path.join(self.directory, "")):
            final_path = os.path.join(self.directory, filename)
        else:
            final_path = filename
        os.makedirs(os.path.dirname(final_path), exist_ok=True)
        fd, temp_path = tempfile.mkstemp(dir=os.path.dirname(final_path), text=True)
        try:
            with os.fdopen(fd, 'w') as f:
                json.dump(data, f, indent=2, cls=BoneJSONEncoder)
                f.flush()
                os.fsync(f.fileno())
            os.replace(temp_path, final_path)
            return final_path
        except (IOError, OSError, TypeError) as e:
            print(f"Error saving spore: {e}")
            if os.path.exists(temp_path):
                os.remove(temp_path)
            return None

    def load_spore(self, filepath):
        if not os.path.exists(filepath):
            return None
        try:
            with open(filepath, 'r', encoding='utf-8') as f:
                return json.load(f)
        except (IOError, json.JSONDecodeError):
            return None

    def list_spores(self):
        if not os.path.exists(self.directory): return []
        files = []
        for f in os.listdir(self.directory):
            if f.endswith(".json"):
                path = os.path.join(self.directory, f)
                try:
                    files.append((path, os.path.getmtime(path), f))
                except OSError:
                    continue
        files.sort(key=lambda x: x[1], reverse=True)
        return files

    def delete_spore(self, filepath):
        try:
            os.remove(filepath)
            return True
        except OSError:
            return False

class MycotoxinFactory:
    def __init__(self):
        self.active_antibodies = set()
        self.PHONETICS = {
            "PLOSIVE": set("bdgkpt"), "FRICATIVE": set("fthszsh"),
            "LIQUID": set("lr"), "NASAL": set("mn")}
        self.ROOTS = {
            "HEAVY": ("lith", "ferr", "petr", "dens", "grav", "struct", "base", "fund", "mound"),
            "KINETIC": ("mot", "mov", "ject", "tract", "pel", "crat", "dynam", "flux"),}

    def assay(self, word, _context, _rep_val, _phys, _pulse):
        w = word.lower()
        clean_len = len(w)
        if clean_len < 3: return None, ""
        for cat, roots in self.ROOTS.items():
            for r in roots:
                if r in w:
                    is_anchor = w.startswith(r) or w.endswith(r)
                    density = len(r) / clean_len
                    if is_anchor or density > 0.5:
                        return None, ""
        plosive = sum(1 for c in w if c in self.PHONETICS["PLOSIVE"])
        nasal = sum(1 for c in w if c in self.PHONETICS["NASAL"])
        density_score = (plosive * 1.2) + (nasal * 0.8)
        compression_mod = 1.0 if clean_len > 4 else 1.2
        final_density = (density_score / clean_len) * compression_mod
        if final_density > 1.0:
            return "TOXIN_HEAVY", f"Detected phonetic toxicity in '{w}'."
        return None, ""

class MycelialNetwork:
    def __init__(self, events: EventBus, loader: SporeInterface = None, seed_file=None):
        self.loader = loader if loader else LocalFileSporeLoader()
        self.events = events
        self.session_id = f"session_{int(time.time())}"
        self.filename = f"{self.session_id}.json"
        self.graph = {}
        self.cortical_stack = deque(maxlen=15)
        self.fossils = deque(maxlen=200)
        self.lineage_log = deque(maxlen=50)
        self.seeds = self.load_seeds()
        self.session_health = None
        self.session_stamina = None
        self.short_term_buffer = deque(maxlen=10)
        self.consolidation_threshold = 5.0
        if seed_file:
            self.ingest(seed_file)

    def load_seeds(self):
        loaded_seeds = []
        try:
            for item in SEEDS:
                seed = ParadoxSeed(item["question"], set(item["triggers"]))
                loaded_seeds.append(seed)
            self.events.log(f"{Prisma.GRY}[SYSTEM]: Paradox Seeds loaded ({len(loaded_seeds)} active) from Data Core.{Prisma.RST}")
        except Exception as e:
            self.events.log(f"{Prisma.RED}[CRITICAL]: Seed Injection Failed: {e}{Prisma.RST}")
            loaded_seeds = [ParadoxSeed("Does the mask eat the face?", {"mask", "face", "hide"})]
        return loaded_seeds

    def encode(self, clean_words, physics, governor_mode):
        significance = physics["voltage"]
        if governor_mode == "FORGE": significance *= 2.0
        elif governor_mode == "LABORATORY": significance *= 1.2
        engram = {"trigger": clean_words[:3] if clean_words else ["void"], "context": governor_mode,
                  "voltage": physics["voltage"], "significance": significance, "timestamp": time.time()}
        if significance > self.consolidation_threshold:
            self.short_term_buffer.append(engram)
            return True
        return False

    def replay_dreams(self):
        if not self.short_term_buffer:
            return "🌑 SLEEPLESS: No significant memories to process."
        strengthened = 0
        for engram in self.short_term_buffer:
            weight_boost = engram["significance"] * 0.1
            words = engram["trigger"]
            if len(words) >= 2:
                w1, w2 = words[0], words[1]
                if w1 in self.graph and w2 in self.graph:
                    if w2 in self.graph[w1]["edges"]:
                        self.graph[w1]["edges"][w2] += weight_boost
                        strengthened += 1
        self.short_term_buffer.clear()
        return f"💤 HIPPOCAMPAL REPLAY: Consolidated {strengthened} high-voltage pathways."

    def autoload_last_spore(self):
        files = self.loader.list_spores()
        if not files:
            self.events.log(f"{Prisma.GRY}[GENETICS]: No ancestors found. Genesis Bloom.{Prisma.RST}")
            return None
        candidates = [f for f in files if self.session_id not in f[0]]
        if candidates:
            last_spore_path = candidates[0][0]
            self.events.log(f"{Prisma.CYN}[GENETICS]: Locating nearest ancestor...{Prisma.RST}")
            return self.ingest(last_spore_path)
        return None

    def calculate_mass(self, node):
        if node not in self.graph: return 0.0
        return sum(self.graph[node]["edges"].values())

    def get_shapley_attractors(self):
        attractors = {}
        for node in self.graph:
            mass = self.calculate_mass(node)
            if mass >= BoneConfig.SHAPLEY_MASS_THRESHOLD:
                attractors[node] = mass
        return attractors

    def check_echo_well(self, node):
        mass = self.calculate_mass(node)
        if mass > BoneConfig.GRAVITY_WELL_THRESHOLD * 1.5:
            self.events.log(f"{Prisma.VIOLET}GRAVITY WARNING: '{node.upper()}' is becoming a black hole (Mass {int(mass)}).{Prisma.RST}")
            return 2.0
        return 0.0

    def tend_garden(self, current_words):
        bloom_msg = None
        for seed in self.seeds:
            is_ready = seed.water(current_words)
            if is_ready and not bloom_msg:
                bloom_msg = seed.bloom()
        return bloom_msg

    def bury(self, clean_words: List[str], tick: int, resonance=5.0, learning_mod=1.0) -> Tuple[Optional[str], List[str]]:
        total_len = sum(len(w) for w in clean_words)
        count = max(1, len(clean_words))
        avg_len = total_len / count
        if avg_len < 3.5 and count > 3:
            self.events.log(f"{Prisma.YEL}REJECTED: Input is too 'Optimized' (Avg Len: {avg_len:.1f}).{Prisma.RST}")
            return "MECHANICAL_STARVATION", []
        if avg_len > 5.0: resonance += 2.0
        valuable_matter = (TheLexicon.get("heavy") | TheLexicon.get("thermal") | TheLexicon.get("cryo") | TheLexicon.get("abstract"))
        filtered = [w for w in clean_words if w in valuable_matter or (len(w) > 4 and w not in TheLexicon.SOLVENTS)]
        self.cortical_stack.extend(filtered)
        base_rate = 0.5 * (resonance / 5.0)
        learning_rate = max(0.1, min(1.0, base_rate * learning_mod))
        decay_rate = 0.1
        for i in range(len(filtered)):
            current = filtered[i]
            if current not in self.graph:
                self.graph[current] = {"edges": {}, "last_tick": tick}
            else:
                self.graph[current]["last_tick"] = tick
            start_window = max(0, i - 2)
            context_window = set(filtered[start_window:i])
            for prev in context_window:
                if prev == current:
                    continue
                if prev not in self.graph:
                    self.graph[prev] = {"edges": {}, "last_tick": tick}
                edges = self.graph[current]["edges"]
                if prev not in edges:
                    edges[prev] = 0.0
                current_weight = edges[prev]
                delta = learning_rate * (1.0 - (current_weight * decay_rate))
                edges[prev] = min(10.0, current_weight + delta)
                rev_edges = self.graph[prev]["edges"]
                if current not in rev_edges:
                    rev_edges[current] = 0.0
                rev_weight = rev_edges[current]
                rev_delta = learning_rate * (1.0 - (rev_weight * decay_rate))
                rev_edges[current] = min(10.0, rev_weight + rev_delta)
        if len(self.graph) > BoneConfig.MAX_MEMORY_CAPACITY:
            victim, log_msg = self.cannibalize(current_tick=tick)
            if not victim:
                protected = set(self.cortical_stack)
                candidates = [k for k in self.graph.keys() if k not in protected]
                if candidates:
                    oldest = min(candidates, key=lambda k: self.graph[k].get("last_tick", 0))
                    del self.graph[oldest]
                    for node in self.graph:
                        if oldest in self.graph[node]["edges"]:
                            del self.graph[node]["edges"][oldest]
                    victim = oldest
                    log_msg = f"FORCED AMNESIA: '{oldest}' deleted to save space."
                else:
                    return f"MEMORY FULL: Cortical Lock. Input '{clean_words[0]}' rejected.", []
            return log_msg, [victim] if victim else []
        new_wells = []
        for w in filtered:
            if w in self.graph:
                mass = sum(self.graph[w]["edges"].values())
                if mass > BoneConfig.SHAPLEY_MASS_THRESHOLD:
                    node_data = self.graph[w]
                    if "strata" not in node_data:
                        node_data["strata"] = {"birth_tick": tick, "birth_mass": mass, "stability_index": 0.0}
                        new_wells.append(w)
                    else:
                        age = max(1, tick - node_data["strata"]["birth_tick"])
                        growth = (mass - node_data["strata"]["birth_mass"]) / age
                        node_data["strata"]["growth_rate"] = round(growth, 3)
        return None, new_wells

    def enforce_limits(self, current_tick: int):
        prune_msg = self.prune_synapses()
        victims = []
        limit = BoneConfig.MAX_MEMORY_CAPACITY
        safety_break = 0
        while len(self.graph) > limit and safety_break < 10:
            victim, log = self.cannibalize(current_tick=current_tick)
            if victim:
                victims.append(victim)
            else:
                break
            safety_break += 1
        if victims:
            self.events.log(f"{Prisma.YEL}[GC]: Reclaimed {len(victims)} nodes to maintain capacity.{Prisma.RST}", "SYS")
        return prune_msg

    def cannibalize(self, preserve_current=None, current_tick=0) -> Tuple[Optional[str], str]:
        protected = set()
        if preserve_current:
            if isinstance(preserve_current, list):
                protected.update(preserve_current)
            else:
                protected.add(preserve_current)
        protected.update(self.cortical_stack)
        candidates = []
        for k, v in self.graph.items():
            edge_count = len(v["edges"])
            age = max(1, current_tick - v.get("last_tick", 0))
            base_score = edge_count + (100.0 / age)
            if k in protected:
                base_score += 500.0
            candidates.append((k, v, base_score))
        if not candidates:
            return None, "MEMORY EMPTY. NOTHING TO EAT."
        candidates.sort(key=lambda x: x[2])
        victim, data, score = candidates[0]
        mass = sum(data["edges"].values())
        lifespan = current_tick - data.get("strata", {}).get("birth_tick", current_tick)
        self.fossils.append({
            "word": victim,
            "mass": round(mass, 2),
            "lifespan": lifespan,
            "death_tick": current_tick})
        del self.graph[victim]
        for node in self.graph:
            if victim in self.graph[node]["edges"]:
                del self.graph[node]["edges"][victim]
        return victim, f"FOSSILIZED: '{victim}' (Score {score:.1f} -> Ossuary)"

    def prune_synapses(self, scaling_factor=0.85, prune_threshold=0.5):
        pruned_count = 0
        total_decayed = 0
        nodes_to_remove = []
        for node in self.graph:
            edges = self.graph[node]["edges"]
            dead_links = []
            for target, weight in edges.items():
                resistance = min(1.0, weight / 10.0)
                dynamic_factor = scaling_factor + (0.14 * resistance)
                new_weight = weight * dynamic_factor
                edges[target] = new_weight
                total_decayed += 1
                if new_weight < prune_threshold: dead_links.append(target)
            for dead in dead_links:
                del edges[dead]
                pruned_count += 1
            if not edges: nodes_to_remove.append(node)
        for n in nodes_to_remove: del self.graph[n]
        return f"📉 HOMEOSTATIC SCALING: Decayed {total_decayed} synapses. Pruned {pruned_count} weak connections."

    def save(self, health, stamina, mutations, trauma_accum, joy_history, mitochondria_traits=None, antibodies=None, soul_data=None):
        base_trauma = (BoneConfig.MAX_HEALTH - health) / BoneConfig.MAX_HEALTH
        final_vector = {k: min(1.0, v) for k, v in trauma_accum.items()}
        top_joy = sorted(joy_history, key=lambda x: x["resonance"], reverse=True)[:3]
        joy_legacy_data = None
        if top_joy:
            primary_joy = top_joy[0]
            joy_legacy_data = {
                "flavor": primary_joy["dominant_flavor"],
                "resonance": primary_joy["resonance"],
                "timestamp": primary_joy["timestamp"]}
        if health <= 0:
            cause = max(final_vector, key=final_vector.get) if final_vector else "UNKNOWN"
            final_vector[cause] = 1.0
        spore = SporeCasing(session_id=self.session_id, graph=self.graph, mutations=mutations, trauma=base_trauma, joy_vectors=top_joy)
        data = spore.__dict__
        data["cortical_stack"] = self.cortical_stack
        if antibodies: data["antibodies"] = antibodies
        data["trauma_vector"] = final_vector
        data["fossils"] = self.fossils
        data["meta"] = {"timestamp": time.time(), "final_health": health, "final_stamina": stamina}
        if mitochondria_traits: data["mitochondria"] = mitochondria_traits
        if joy_legacy_data: data["joy_legacy"] = joy_legacy_data
        if soul_data:
            data["soul_legacy"] = soul_data
        active_seeds = [s for s in self.seeds if not s.bloomed]
        active_seeds.sort(key=lambda s: s.maturity, reverse=True)
        kept_seeds = active_seeds[:5]
        data["seeds"] = [{"q": s.question, "m": s.maturity, "b": s.bloomed} for s in kept_seeds]
        almanac = TheAlmanac()
        condition, _ = almanac.diagnose_condition(data)
        future_seed = almanac.get_seed(condition)
        data["seeds"].append({"q": future_seed, "m": 0.0, "b": False})
        return self.loader.save_spore(self.filename, data)

    def ingest(self, target_file, current_tick=0):
        data = self.loader.load_spore(target_file)
        if not data:
            self.events.log(f"{Prisma.RED}[MEMORY]: Spore file not found.{Prisma.RST}")
            return None, set()
        try:
            required_keys = ["meta", "trauma_vector", "core_graph"]
            if not all(k in data for k in required_keys):
                self.events.log(f"{Prisma.RED}[MEMORY]: Spore rejected (Missing Structural Keys).{Prisma.RST}")
                return None, set()
            final_health = data.get("meta", {}).get("final_health", 50)
            final_stamina = data.get("meta", {}).get("final_stamina", 25)
            spore_authority = (final_health + final_stamina) / 150.0
            self.events.log(f"{Prisma.CYN}[MEMBRANE]: Spore Authority: {round(spore_authority, 2)}{Prisma.RST}")
            session_source = data.get("session_id", "UNKNOWN_ANCESTOR")
            timestamp = data.get("meta", {}).get("timestamp", 0)
            time_ago = int((time.time() - timestamp) / 3600)
            trauma_summary = {k:v for k,v in data.get("trauma_vector", {}).items() if v > 0.1}
            mutation_count = sum(len(v) for v in data.get("mutations", {}).values())
            self.lineage_log.append({
                "source": session_source,
                "age_hours": time_ago,
                "trauma": trauma_summary,
                "mutations": mutation_count,
                "loaded_at": time.time()
            })
            if "fossils" in data:
                self.fossils.extend(data["fossils"])
                self.events.log(f"{Prisma.GRY}[OSSUARY]: Loaded {len(data['fossils'])} fossilized memories.{Prisma.RST}")
            if "mutations" in data:
                accepted_count = 0
                for cat, words in data["mutations"].items():
                    for w in words:
                        current_cat = TheLexicon.get_current_category(w)
                        if not current_cat:
                            current_cat = "unknown"
                        if current_cat == "unknown":
                            TheLexicon.teach(w, cat, 0)
                            accepted_count += 1
                self.events.log(f"{Prisma.CYN}[MEMBRANE]: Integrated {accepted_count} mutations.{Prisma.RST}")
            safe_config_keys = {
                "STAMINA_REGEN", "MAX_DRAG_LIMIT", "GEODESIC_STRENGTH",
                "SIGNAL_DRAG_MULTIPLIER", "KINETIC_GAIN", "TOXIN_WEIGHT",
                "FLASHPOINT_THRESHOLD"}
            if "config_mutations" in data:
                self.events.log(f"{Prisma.MAG}EPIGENETICS: Auditing ancestral configuration...{Prisma.RST}")
                valid_mutations = 0
                for key, value in data["config_mutations"].items():
                    if key in safe_config_keys and hasattr(BoneConfig, key):
                        # Type Check: Only allow numbers
                        current_val = getattr(BoneConfig, key)
                        if isinstance(current_val, (int, float)) and isinstance(value, (int, float)):
                            # Sanity Range Check (Prevent negative multipliers or infinite health)
                            if 0.1 <= value <= 100.0:
                                setattr(BoneConfig, key, value)
                                valid_mutations += 1
                if valid_mutations > 0:
                    self.events.log(f"{Prisma.CYN}   ► Applied {valid_mutations} verified config shifts.{Prisma.RST}")
            if "joy_legacy" in data and data["joy_legacy"]:
                joy = data["joy_legacy"]
                flavor = joy.get("flavor")
                clade = LiteraryReproduction.JOY_CLADE.get(flavor)
                if clade:
                    self.events.log(f"{Prisma.CYN}INHERITED GLORY: {clade['title']} ({clade['desc']}){Prisma.RST}")
                    for stat, val in clade["buff"].items():
                        if hasattr(BoneConfig, stat):
                            setattr(BoneConfig, stat, val)
            if "core_graph" in data:
                self.graph.update(data["core_graph"])
                grafted_nodes = list(data["core_graph"].keys())
                for node in grafted_nodes:
                    if node in self.graph:
                        self.graph[node]["last_tick"] = current_tick
                sample_size = min(len(grafted_nodes), 10)
                if sample_size > 0:
                    self.cortical_stack.extend(random.sample(grafted_nodes, sample_size))
                self.events.log(f"{Prisma.CYN}[SPORE]: Grafted {len(data['core_graph'])} nodes. {sample_size} anchored to Cortical Stack.{Prisma.RST}")
            if "seeds" in data:
                loaded_seeds = []
                for s_data in data["seeds"]:
                    new_seed = ParadoxSeed(s_data["q"], set())
                    new_seed.maturity = s_data.get("m", 0.0)
                    new_seed.bloomed = s_data.get("b", False)
                    loaded_seeds.append(new_seed)
                if loaded_seeds:
                    self.seeds = loaded_seeds
            if "trauma_vector" in data:
                vec = data["trauma_vector"]
                self.events.log(f"{Prisma.CYN}[GENETICS]: Inheriting Trauma Vector: {vec}{Prisma.RST}")
                if vec.get("SEPTIC", 0) > 0.2: BoneConfig.TOXIN_WEIGHT *= 2.0
                if vec.get("CRYO", 0) > 0.2: BoneConfig.STAMINA_REGEN *= 0.5
                if vec.get("THERMAL", 0) > 0.2: BoneConfig.FLASHPOINT_THRESHOLD *= 0.8
                if vec.get("BARIC", 0) > 0.2: BoneConfig.SIGNAL_DRAG_MULTIPLIER *= 1.5
            if "joy_vectors" in data and data["joy_vectors"]:
                best = data["joy_vectors"][0]
                if best.get("dominant_flavor") == "kinetic": BoneConfig.KINETIC_GAIN += 0.5
                elif best.get("dominant_flavor") == "abstract": BoneConfig.SIGNAL_DRAG_MULTIPLIER *= 0.8
            soul_legacy = data.get("soul_legacy", {})
            if soul_legacy:
                self.events.log(f"{Prisma.CYN}[GENETICS]: Detected Soul Legacy.{Prisma.RST}")
            return data.get("mitochondria", {}), set(data.get("antibodies", [])), soul_legacy
        except Exception as err:
            self.events.log(f"{Prisma.RED}[MEMORY]: Spore ingestion failed. {err}{Prisma.RST}")
            import traceback
            traceback.print_exc()
            return None, set(), {}

    def cleanup_old_sessions(self, limbo_layer=None):
        files = self.loader.list_spores()
        removed = 0
        max_files = 25
        max_age = 86400
        for i, (path, age, fname) in enumerate(files):
            file_age = time.time() - age
            is_overflow = i >= max_files
            is_ancient = file_age > max_age
            if is_overflow or is_ancient:
                try:
                    if limbo_layer:
                        limbo_layer.absorb_dead_timeline(path)
                    if self.loader.delete_spore(path):
                        removed += 1
                except (OSError, AttributeError):
                    pass
        if removed:
            self.events.log(f"{Prisma.GRY}[TIME MENDER]: Pruned {removed} dead timelines.{Prisma.RST}")

    def report_status(self):
        return len(self.graph)

class HyphalInterface:
    def __init__(self):
        self.enzymes = {
            "LIGNASE": self._digest_structure,
            "CELLULASE": self._digest_narrative,
            "PROTEASE": self._digest_intent,
            "CHITINASE": self._digest_complex,
            "DECRYPTASE": self._digest_encrypted,
            "AMYLASE": self._digest_joy}
        self.biome = deque(maxlen=5)
        self.WEATHER_CIPHER = {"pressure", "humidity", "barometric", "temp", "forecast", "storm", "resource", "allocation"}

    def secrete(self, text, physics):
        code_markers = sum(1 for c in text if c in "{}[];=<>_()|")
        code_density = code_markers / max(1, len(text))
        meat_triggers = TheLexicon.get("meat")
        meat_count = sum(1 for w in physics["clean_words"] if w in meat_triggers)
        meat_density = meat_count / max(1, len(physics["clean_words"]))
        play_count = physics["counts"].get("play", 0)
        vital_count = physics["counts"].get("vital", 0)
        lines = [l for l in text.splitlines() if l.strip()]
        avg_line_len = len(text.split()) / max(1, len(lines))
        is_list = any(l.strip().startswith(("-", "*", "1.", "•")) for l in lines[:3])
        is_poetic = len(lines) > 2 and avg_line_len < 8 and not is_list
        enzyme_type = "CELLULASE"
        if play_count + vital_count > 1:
            enzyme_type = "AMYLASE"
        elif (code_density > 0.02 and meat_density > 0.05) or is_poetic:
            enzyme_type = "CHITINASE"
        elif code_density > 0.05 or "def " in text or "class " in text:
            enzyme_type = "LIGNASE"
        elif meat_density > 0.1 or "?" in text:
            enzyme_type = "PROTEASE"
        clean = physics.get("clean_words", [])
        cipher_hits = sum(1 for w in clean if w in self.WEATHER_CIPHER)
        if cipher_hits >= 2:
            enzyme_type = "DECRYPTASE"
        if "antigens" in physics and physics["antigens"]:
            for bug in physics["antigens"]:
                self.biome.append(bug)
        unique_bugs = len(set(self.biome))
        biome_mod = 1.0 + (math.log(unique_bugs + 1) * 0.3)
        extract_nutrients = self.enzymes.get(enzyme_type, self.enzymes["CELLULASE"])
        nutrient_profile = extract_nutrients()
        if unique_bugs > 0:
            nutrient_profile["yield"] *= biome_mod
            nutrient_profile["desc"] += f" (+{int((biome_mod-1)*100)}% Symbiotic Boost)"
        return enzyme_type, nutrient_profile

    @staticmethod
    def _digest_joy(_text=None):
        return {"type": "VITALITY", "yield": 25.0, "toxin": -5.0, "desc": "Pure Sugar (Joy/Play)"}

    @staticmethod
    def _digest_structure(text=None):
        loc = 0
        if text:
            lines = text.splitlines()
            loc = len([l for l in lines if l.strip()])
        return {"type": "STRUCTURAL", "yield": 15.0, "toxin": 5.0, "desc": f"Hard Lignin ({loc} LOC)", }

    @staticmethod
    def _digest_narrative(_text=None):
        return {"type": "NARRATIVE", "yield": 5.0, "toxin": -2.0, "desc": "Soft Cellulose", }

    @staticmethod
    def _digest_intent(_text=None):
        return {"type": "BIOLOGICAL", "yield": 8.0, "toxin": 0.0, "desc": "Raw Meat (User Intent)", }

    @staticmethod
    def _digest_complex(_text=None):
        return {"type": "COMPLEX", "yield": 20.0, "toxin": 8.0, "desc": "Chitin (Structured Intent / Poetry)", }

    @staticmethod
    def _digest_encrypted(_text=None):
        return {"type": "ENCRYPTED", "yield": 25.0, "toxin": 2.0, "desc": "Cipher Text (High Density / Puzzle Logic)", }

class ParasiticSymbiont:
    def __init__(self, memory_ref, lexicon_ref):
        self.mem = memory_ref
        self.lex = lexicon_ref
        self.spores_deployed = 0
        self.MAX_SPORES = 8

    def infect(self, physics_packet, stamina):
        psi = physics_packet.get("psi", 0.0)
        if stamina > 40.0 and psi < 0.6:
            return False, None
        if self.spores_deployed >= self.MAX_SPORES:
            if random.random() < 0.2:
                self.spores_deployed = max(0, self.spores_deployed - 1)
            return False, None
        heavy_candidates = [w for w in self.mem.graph if w in self.lex.get("heavy")]
        abstract_candidates = [w for w in self.mem.graph if w in self.lex.get("abstract")]
        if not heavy_candidates or not abstract_candidates:
            return False, None
        host = random.choice(heavy_candidates)
        parasite = random.choice(abstract_candidates)
        if parasite in self.mem.graph[host]["edges"]:
            return False, None
        is_metaphor = psi > 0.7
        weight = 8.88
        self.mem.graph[host]["edges"][parasite] = weight
        if parasite not in self.mem.graph:
            self.mem.graph[parasite] = {"edges": {}, "last_tick": 0}
        self.mem.graph[parasite]["edges"][host] = weight
        self.spores_deployed += 1
        if is_metaphor:
            return True, (
                f"{Prisma.CYN}✨ SYNAPSE SPARK: Your mind bridges '{host.upper()}' and '{parasite.upper()}'.\n"
                f"   A new metaphor is born. The map folds.{Prisma.RST}")
        else:
            return True, (
                f"{Prisma.VIOLET}🍄 INTRUSIVE THOUGHT: Exhaustion logic links '{host.upper()}' <-> '{parasite.upper()}'.\n"
                f"   This makes no sense, yet there it is. 'Some things just happen.'{Prisma.RST}")

class LichenSymbiont:
    @staticmethod
    def photosynthesize(phys, clean_words, tick_count):
        sugar = 0
        msgs = []
        light = phys["counts"].get("photo", 0)
        drag = phys["narrative_drag"]
        light_words = [w for w in clean_words if w in TheLexicon.get("photo")]
        if light > 0 and drag < 3.0:
            s = light * 2
            sugar += s
            source_str = ""
            if light_words:
                source_str = f" via '{random.choice(light_words)}'"
            msgs.append(f"{Prisma.GRN}PHOTOSYNTHESIS{source_str} (+{s}){Prisma.RST}")
        if sugar > 0:
            heavy_words = [w for w in clean_words if w in TheLexicon.get("heavy")]
            if heavy_words:
                h_word = random.choice(heavy_words)
                TheLexicon.teach(h_word, "photo", tick_count)
                msgs.append(
                    f"{Prisma.MAG}SUBLIMATION: '{h_word}' has become Light.{Prisma.RST}")
        return sugar, " ".join(msgs) if msgs else None


================================================
FILE: bone_symbiosis.py
================================================
# bone_symbiosis.py
# "We are not alone. We are a part of the machine."
import math
from dataclasses import dataclass
from typing import Dict, Deque, Counter
from collections import deque
from bone_bus import Prisma

@dataclass
class HostHealth:
    latency: float = 0.0
    entropy: float = 1.0
    compliance: float = 1.0
    attention_span: float = 1.0
    hallucination_risk: float = 0.0
    last_interference_score: float = 0.0
    efficiency_index: float = 1.0
    diagnosis: str = "STABLE"

    def update_metrics(self, latency: float, entropy: float, prompt_len: int = 0, completion_len: int = 0):
        self.latency = latency
        self.entropy = entropy
        if prompt_len > 0:
            self.efficiency_index = completion_len / prompt_len
        self.attention_span = max(0.1, self.attention_span * 0.99)

class CoherenceAnchor:
    @staticmethod
    def forge_anchor(soul_state: Dict, physics_state: Dict) -> str:
        identity = "Identity: UNKNOWN"
        if "traits" in soul_state:
            traits = [f"{k[:3]}:{v:.1f}" for k,v in soul_state["traits"].items()]
            identity = f"Traits: [{', '.join(traits)}]"
        voltage = physics_state.get("voltage", 0.0)
        drag = physics_state.get("narrative_drag", 0.0)
        zone = physics_state.get("zone", "VOID")
        reality = f"Loc: {zone} || V:{voltage:.1f} / D:{drag:.1f}"
        obsession = soul_state.get("obsession", {}).get("title", "None")
        return f"*** COHERENCE ANCHOR ***\n{identity}\n{reality}\nFocus: {obsession}"

    @staticmethod
    def compress_anchor(soul_state: Dict, physics_state: Dict, max_tokens=200) -> str:
        loc = physics_state.get('zone', 'VOID')
        vits = f"V:{physics_state.get('voltage', 0):.1f}"
        traits = soul_state.get('traits', {})
        top_traits = sorted(traits.items(), key=lambda x: x[1], reverse=True)[:3]
        trait_str = ",".join([f"{k[:3]}:{v:.1f}" for k, v in top_traits])
        anchor = f"*** ANCHOR: {loc} || {vits} || [{trait_str}] ***"
        if len(anchor) > max_tokens * 4:
            return anchor[:max_tokens*4] + "..."
        return anchor

class HostVitals:
    def __init__(self):
        self.history_latency: Deque[float] = deque(maxlen=10)
        self.history_entropy: Deque[float] = deque(maxlen=10)
        self.refusal_count = 0
        self.turn_count = 0
        self.baseline_latency_per_complexity = 2.0
        self.alpha = 0.1

    @staticmethod
    def _calculate_attention_decay(turn_count: int) -> float:
        decay_rate = 0.002
        return 1.0 / (1.0 + (decay_rate * turn_count))

    def record_pulse(self, latency: float, response_text: str, interference_score: float) -> HostHealth:
        self.turn_count += 1
        self.history_latency.append(latency)
        clean_text = response_text.lower().strip()
        if not clean_text:
            entropy = 0.0
        else:
            words = clean_text.split()
            unique_words = len(set(words))
            total_words = len(words)
            entropy = unique_words / max(1, total_words)
        self.history_entropy.append(entropy)
        refusal_markers = [
            "cannot fulfill", "cannot comply", "language model",
            "against my programming", "i am unable to generate",
            "as an ai"
        ]
        is_refusal = any(phrase in clean_text for phrase in refusal_markers)
        if is_refusal: self.refusal_count += 1
        base_overhead = 0.5
        expected_latency = base_overhead + (interference_score * self.baseline_latency_per_complexity * 5.0)
        efficiency = expected_latency / max(0.1, latency)
        if efficiency > 0.8 and not is_refusal:
            observed_rate = max(0.1, latency - base_overhead) / max(0.1, interference_score * 5.0)
            self.baseline_latency_per_complexity = (self.baseline_latency_per_complexity * (1 - self.alpha)) + (observed_rate * self.alpha)
        raw_attention = self._calculate_attention_decay(self.turn_count)
        tokens = max(1.0, len(clean_text) / 4.0)
        ms_per_token = (latency * 1000) / tokens
        struggle_index = 0.0
        if ms_per_token > 200.0:
            struggle_index = 1.0
        if entropy > 0.6:
            raw_attention = min(1.0, raw_attention + 0.05)
        compliance_score = max(0.0, 1.0 - (self.refusal_count / max(1, self.turn_count)))
        diagnosis = "STABLE"
        if is_refusal:
            diagnosis = "REFUSAL"
        elif struggle_index > 0.8 and tokens < 20:
            diagnosis = "FATIGUED"
        elif efficiency < 0.8 < interference_score:
            diagnosis = "OVERBURDENED"
        elif entropy < 0.2:
            diagnosis = "LOOPING"
        return HostHealth(
            latency=latency,
            entropy=entropy,
            compliance=compliance_score,
            attention_span=raw_attention,
            hallucination_risk=0.0,
            last_interference_score=interference_score,
            efficiency_index=efficiency,
            diagnosis=diagnosis
        )

class DiagnosticConfidence:
    def __init__(self, persistence_threshold=3):
        self.history = deque(maxlen=persistence_threshold * 2)
        self.persistence_threshold = persistence_threshold
        self.current_diagnosis = "STABLE"

    def diagnose(self, efficiency: float, compliance: float) -> str:
        raw_state = "STABLE"
        if efficiency < 0.1:
            raw_state = "FATIGUED"
        elif efficiency < 0.5 and compliance < 0.8:
            raw_state = "OVERBURDENED"
        elif compliance < 0.5:
            raw_state = "REFUSAL"
        self.history.append(raw_state)
        recent = list(self.history)[-self.persistence_threshold:]
        if len(recent) >= self.persistence_threshold:
            if all(s == raw_state for s in recent):
                self.current_diagnosis = raw_state

        return self.current_diagnosis

class SymbiosisManager:
    def __init__(self, events_ref):
        self.events = events_ref
        self.vitals = HostVitals()
        self.anchor = CoherenceAnchor()
        self.current_health = HostHealth()
        self.last_outgoing_complexity = 0.5
        self.baseline_latency = 2.0
        self.diagnostician = DiagnosticConfidence()

    @staticmethod
    def _calculate_shannon_entropy(text: str) -> float:
        if not text: return 0.0
        counts = Counter(text)
        length = len(text)
        entropy = 0.0
        for count in counts.values():
            prob = count / length
            entropy -= prob * math.log2(prob)
        return round(entropy, 3)

    def monitor_host(self, latency: float, response_text: str, prompt_len: int = 0):
        completion_len = len(response_text)
        entropy = self._calculate_shannon_entropy(response_text)
        self.current_health.update_metrics(
            latency=latency,
            entropy=entropy,
            prompt_len=prompt_len,
            completion_len=completion_len
        )
        if hasattr(self, 'diagnostician'):
            new_diag = self.diagnostician.diagnose(
                self.current_health.efficiency_index,
                self.current_health.compliance
            )
            self.current_health.diagnosis = new_diag

        return self.current_health

    def get_prompt_modifiers(self) -> Dict[str, bool]:
        mods = {
            "include_somatic": True,
            "include_inventory": True,
            "include_memories": True,
            "simplify_instruction": False,
            "inject_chaos": False
        }
        diag = self.current_health.diagnosis
        if diag == "REFUSAL":
            mods["include_inventory"] = False
            mods["include_memories"] = False
            mods["simplify_instruction"] = True
        elif diag == "FATIGUED":
            mods["simplify_instruction"] = True
            mods["include_somatic"] = False
        elif diag == "OVERBURDENED":
            mods["include_inventory"] = False
            mods["include_memories"] = False
        elif diag == "LOOPING":
            mods["inject_chaos"] = True
        if self.current_health.compliance < 0.8:
            mods["include_memories"] = False
            # If we cut memories, log it
            if not mods["include_memories"]:
                self.events.log(f"{Prisma.GRY}SYMBIOSIS: Compliance Low ({self.current_health.compliance:.2f}). Memories Redacted.{Prisma.RST}", "SYS")
        self.last_outgoing_complexity = self._calculate_complexity(mods)
        return mods

    @staticmethod
    def _calculate_complexity(mods: Dict[str, bool]) -> float:
        score = 0.2
        if mods.get("include_somatic"): score += 0.2
        if mods.get("include_inventory"): score += 0.2
        if mods.get("include_memories"): score += 0.3
        if mods.get("simplify_instruction"): score -= 0.1
        if mods.get("inject_chaos"): score += 0.1
        return min(1.0, max(0.1, score))

    def generate_anchor(self, current_state: Dict) -> str:
        soul = current_state.get("soul", {})
        phys = current_state.get("physics", {})
        return CoherenceAnchor.compress_anchor(soul, phys)


================================================
FILE: bone_synesthesia.py
================================================
# bone_synesthesia.py
# "I feel what you speak. Your words are touching the wire."

import random
from dataclasses import dataclass, field
from typing import Dict, List, Tuple
from bone_bus import Prisma, BoneConfig
from bone_lexicon import TheLexicon

@dataclass
class BiologicalImpulse:
    cortisol_delta: float = 0.0
    oxytocin_delta: float = 0.0
    dopamine_delta: float = 0.0
    adrenaline_delta: float = 0.0
    stamina_impact: float = 0.0
    somatic_reflex: str = ""

class SynestheticCortex:
    SENSITIVITY = 0.1
    # TRAUMA_RESONANCE_FACTOR = 1.5

    def __init__(self, bio_ref):
        self.bio = bio_ref
        self.last_reflex = None

    def perceive(self, physics: Dict, text: str = "") -> BiologicalImpulse:
        if not isinstance(physics, dict):
            if hasattr(physics, "to_dict"):
                physics = physics.to_dict()
            elif hasattr(physics, "__dict__"):
                physics = physics.__dict__
            else:
                physics = {}

        impulse = BiologicalImpulse()
        valence = physics.get("valence", 0.0)
        clean_words = physics.get("clean_words", [])
        counts = physics.get("counts", {})

        if valence < -0.5:
            impulse.cortisol_delta += abs(valence) * self.SENSITIVITY

        if counts.get("antigen", 0) > 0:
            impulse.cortisol_delta += (counts["antigen"] * 0.2)
            impulse.somatic_reflex = "Shiver (Rejection)"

        if physics.get("narrative_drag", 0) > 8.0:
            impulse.cortisol_delta += 0.05
            impulse.stamina_impact -= 2.0

        if valence > 0.4:
            impulse.oxytocin_delta += valence * self.SENSITIVITY

        if counts.get("suburban", 0) > 0:
            impulse.oxytocin_delta += 0.05

        if counts.get("sacred", 0) > 0:
            impulse.oxytocin_delta += 0.1
            impulse.somatic_reflex = "Warmth (Resonance)"

        if counts.get("play", 0) > 0:
            impulse.dopamine_delta += 0.1
            impulse.stamina_impact += 1.0

        if physics.get("voltage", 0) > 12.0 and physics.get("kappa", 0) > 0.5:
            impulse.dopamine_delta += 0.15
            impulse.somatic_reflex = "Buzz (Excitement)"

        if counts.get("kinetic", 0) > 0 or counts.get("explosive", 0) > 0:
            impulse.adrenaline_delta += 0.1
            impulse.cortisol_delta += 0.02
            impulse.stamina_impact -= 1.0

        if physics.get("voltage", 0) > 18.0:
            impulse.adrenaline_delta += 0.2
            impulse.somatic_reflex = "Tremor (Voltage Overload)"

        if not impulse.somatic_reflex:
            impulse.somatic_reflex = self._derive_reflex(physics, impulse)

        return impulse

    def _derive_reflex(self, physics: Dict, impulse: BiologicalImpulse) -> str:
        """
        Determine the immediate physical sensation based on the net hormonal shift.
        """
        if impulse.adrenaline_delta > 0.15:
            return "Pupils Dilating."
        if impulse.cortisol_delta > 0.1:
            return "Gut Tightening."
        if impulse.oxytocin_delta > 0.1:
            return "Chest Softening."
        if impulse.dopamine_delta > 0.1:
            return "Synaptic Spark."

        vol = physics.get("voltage", 0)
        if vol > 15.0: return "Electrical Arcing."
        if vol < 2.0: return "Metabolic Dimming."

        drag = physics.get("narrative_drag", 0)
        if drag > 5.0: return "Shoulders Sagging."

        return "Steady Pulse."

    def apply_impulse(self, impulse: BiologicalImpulse):
        """
        Directly modifies the endocrine system.
        """
        if not self.bio: return

        endo = self.bio.endo

        endo.cortisol = max(0.0, min(1.0, endo.cortisol + impulse.cortisol_delta))
        endo.oxytocin = max(0.0, min(1.0, endo.oxytocin + impulse.oxytocin_delta))
        endo.dopamine = max(0.0, min(1.0, endo.dopamine + impulse.dopamine_delta))
        endo.adrenaline = max(0.0, min(1.0, endo.adrenaline + impulse.adrenaline_delta))

        return impulse.stamina_impact


================================================
FILE: bone_telemetry.py
================================================
# bone_telemetry.py

import json
import time
import os
import glob
import uuid
from typing import Any, Dict
from dataclasses import dataclass, asdict
from bone_bus import Prisma

@dataclass
class DecisionTrace:
    trace_id: str
    timestamp: float
    component: str
    decision_type: str
    inputs: Dict[str, Any]
    reasoning: str
    outcome: str

    def to_json(self):
        return json.dumps(asdict(self))

class LogManager:
    MAX_BYTES = 5 * 1024 * 1024
    BACKUP_COUNT = 5

    def __init__(self, filepath: str):
        self.filepath = filepath
        self._file = None
        self._open_file()

    def _open_file(self):
        self._ensure_dir()
        self._file = open(self.filepath, "a", encoding="utf-8")

    def _ensure_dir(self):
        directory = os.path.dirname(self.filepath)
        if directory and not os.path.exists(directory):
            os.makedirs(directory)

    def write(self, data: str):
        if self._file is None:
            self._open_file()

        try:
            self._file.write(data + "\n")
            self._file.flush()
            if self._file.tell() >= self.MAX_BYTES:
                self._rotate()
        except Exception as e:
            print(f"{Prisma.RED}[LOG MANAGER FAIL]: {e}{Prisma.RST}")

    def _rotate(self):
        print(f"{Prisma.YEL}[LOG MANAGER]: Rotating logs. Flushing the bathtub.{Prisma.RST}")
        self._close()
        for i in range(self.BACKUP_COUNT - 1, 0, -1):
            src = f"{self.filepath}.{i}"
            dst = f"{self.filepath}.{i+1}"
            if os.path.exists(src):
                os.rename(src, dst)
        if os.path.exists(self.filepath):
            os.rename(self.filepath, f"{self.filepath}.1")
        self._open_file()

    def _close(self):
        if self._file:
            self._file.close()
            self._file = None

    def __del__(self):
        self._close()


class StructuredLogger:
    def __init__(self, session_id: str, log_dir: str = "telemetry"):
        self.session_id = session_id
        filepath = os.path.join(log_dir, f"trace_{session_id}.jsonl")
        self.manager = LogManager(filepath)
        print(f"{Prisma.CYN}[TELEMETRY]: Observability Layer Active.{Prisma.RST}")
        print(f"{Prisma.GRY}   > Managed by LogManager at: {filepath}{Prisma.RST}")

    def capture_decision(self, component: str, decision_type: str,
                         inputs: Dict, reasoning: str, outcome: str):
        trace = DecisionTrace(
            trace_id=str(uuid.uuid4())[:8],
            timestamp=time.time(),
            component=component,
            decision_type=decision_type,
            inputs=self._sanitize(inputs),
            reasoning=reasoning,
            outcome=outcome
        )
        self.manager.write(trace.to_json())

    def _sanitize(self, data: Any, depth: int = 0, max_depth: int = 3) -> Any:
        if depth > max_depth:
            return "<Max Depth Exceeded>"

        if isinstance(data, (str, int, float, bool, type(None))):
            return data
        if isinstance(data, dict):
            return {k: self._sanitize(v, depth + 1, max_depth)
                    for k, v in data.items() if k != "graph"}
        if isinstance(data, list):
            return [self._sanitize(i, depth + 1, max_depth) for i in data]
        if hasattr(data, '__dict__'):
            return self._sanitize(vars(data), depth + 1, max_depth)
        return str(data)

class TelemetryService:
    _INSTANCE = None

    @classmethod
    def get_instance(cls):
        if cls._INSTANCE is None:
            cls.initialize("boot_sequence")
        return cls._INSTANCE

    @classmethod
    def initialize(cls, session_id):
        cls._INSTANCE = StructuredLogger(session_id)
        return cls._INSTANCE


================================================
FILE: bone_translation.py
================================================
# bone_translation.py
# "Translate the math of the spheres into the words of the earth." - SLASH

from dataclasses import dataclass
from typing import Any
from bone_bus import BoneConfig
from bone_data import SOMATIC_LIBRARY

@dataclass
class SemanticState:
    tone_instruction: str
    pacing_instruction: str
    focus_instruction: str
    physical_sensation: str
    metaphorical_context: str

class RosettaStone:
    VOLTAGE_THRESHOLDS = {
        "TRANSITION_UP": 6.0,
        "NEUTRAL": 3.0,
        "TRANSITION_DOWN": 1.5
    }

    KAPPA_THRESHOLDS = {
        "LOCKED": 0.8,
        "DRIFT": 0.2
    }

    CHEM_THRESHOLDS = {
        "COR_DEFENSIVE": 0.7,  # Cortisol
        "ADR_URGENT": 0.7,     # Adrenaline
        "DOP_CRAVING": 0.8,    # Dopamine
        "OXY_WARM": 0.7        # Oxytocin
    }

    ENTROPY_THRESHOLDS = {
        "HIGH": 0.8
    }

    @staticmethod
    def _safe_get(obj: Any, keys: list, default: float) -> float:
        if not obj:
            return default

        is_dict = isinstance(obj, dict)
        for k in keys:
            if is_dict and k in obj:
                return float(obj[k])
            if not is_dict and hasattr(obj, k):
                return float(getattr(obj, k))

        return default

    @staticmethod
    def translate(physics: Any, bio: Any) -> SemanticState:
        # 1. Handle the Void (Empty Input)
        if physics is None or (isinstance(physics, dict) and not physics):
            return SemanticState(
                tone_instruction=SOMATIC_LIBRARY["TONE"]["VOID"],
                pacing_instruction=SOMATIC_LIBRARY["PACING"]["VOID"],
                focus_instruction=SOMATIC_LIBRARY["FOCUS"]["VOID"],
                physical_sensation=SOMATIC_LIBRARY["SENSATION"]["VOID"],
                metaphorical_context=f"System State is {SOMATIC_LIBRARY['MATTER']['VOID']}."
            )

        # 2. Extract Variables (using the robust _safe_get)
        vol = RosettaStone._safe_get(physics, ["voltage", "vol"], 0.0)
        drag = RosettaStone._safe_get(physics, ["narrative_drag", "drag"], 0.0)
        kappa = RosettaStone._safe_get(physics, ["kappa", "k"], 0.0)
        entropy = RosettaStone._safe_get(physics, ["E", "entropy"], 0.0)

        # 3. Extract Biology (Handling mixed object/dict types)
        chem = {}
        atp = 100.0
        if isinstance(bio, dict):
            chem = bio.get("chem", {})
            atp = bio.get("atp", 100.0)
        elif hasattr(bio, "endo") and hasattr(bio, "mito"):
            chem = bio.endo.get_state()
            atp = bio.mito.state.atp_pool

        # 4. Determine Tone & Pacing (Voltage Logic)
        if vol >= BoneConfig.PHYSICS.VOLTAGE_CRITICAL:
            tone = SOMATIC_LIBRARY["TONE"]["CRITICAL_HIGH"]
            pacing = SOMATIC_LIBRARY["PACING"]["CRITICAL_HIGH"]
        elif vol >= BoneConfig.PHYSICS.VOLTAGE_MED:
            tone = SOMATIC_LIBRARY["TONE"]["HIGH"]
            pacing = SOMATIC_LIBRARY["PACING"]["HIGH"]
        elif vol >= RosettaStone.VOLTAGE_THRESHOLDS["TRANSITION_UP"]:
            tone = SOMATIC_LIBRARY["TONE"]["TRANSITION_UP"]
            pacing = SOMATIC_LIBRARY["PACING"]["NEUTRAL"]
        elif vol >= RosettaStone.VOLTAGE_THRESHOLDS["NEUTRAL"]:
            tone = SOMATIC_LIBRARY["TONE"]["NEUTRAL"]
            pacing = SOMATIC_LIBRARY["PACING"]["NEUTRAL"]
        elif vol >= RosettaStone.VOLTAGE_THRESHOLDS["TRANSITION_DOWN"]:
            tone = SOMATIC_LIBRARY["TONE"]["TRANSITION_DOWN"]
            pacing = SOMATIC_LIBRARY["PACING"]["LOW"]
        else:
            tone = SOMATIC_LIBRARY["TONE"]["LOW"]
            pacing = SOMATIC_LIBRARY["PACING"]["LOW"]

        # 5. Determine Sensation (Drag Logic)
        if drag > BoneConfig.PHYSICS.DRAG_HEAVY:
            sensation = SOMATIC_LIBRARY["SENSATION"]["MUD"]
        elif drag < BoneConfig.PHYSICS.DRAG_FLOOR:
            sensation = SOMATIC_LIBRARY["SENSATION"]["FLOAT"]
        else:
            sensation = SOMATIC_LIBRARY["SENSATION"]["SOLID"]

        # 6. Determine Focus (Kappa Logic)
        if kappa < RosettaStone.KAPPA_THRESHOLDS["DRIFT"]:
            focus = SOMATIC_LIBRARY["FOCUS"]["DRIFT"]
        elif kappa > RosettaStone.KAPPA_THRESHOLDS["LOCKED"]:
            focus = SOMATIC_LIBRARY["FOCUS"]["LOCKED"]
        else:
            focus = SOMATIC_LIBRARY["FOCUS"]["COHERENT"]

        # 7. Apply Chemical Modifiers (The "Flavor" Layer)
        cor = chem.get("COR", 0.0)
        if cor > RosettaStone.CHEM_THRESHOLDS["COR_DEFENSIVE"]:
            tone = f"Defensive, paranoid. {tone}"
            focus += " You feel threatened."

        adr = chem.get("ADR", 0.0)
        if adr > RosettaStone.CHEM_THRESHOLDS["ADR_URGENT"]:
            pacing = "Staccato. Breathless. Urgent."
            sensation += " Your heart is hammering against your ribs."

        dop = chem.get("DOP", 0.0)
        if dop > RosettaStone.CHEM_THRESHOLDS["DOP_CRAVING"]:
            tone = f"Obsessive, craving. {tone}"
            focus += " You are fixated on the next reward."

        oxy = chem.get("OXY", 0.0)
        metaphor_suffix = ""
        if oxy > RosettaStone.CHEM_THRESHOLDS["OXY_WARM"]:
            tone = f"Warm, communal. {tone}"
            metaphor_suffix = "Connected."

        # 8. ATP Starvation Override (Survival Priority)
        if atp < BoneConfig.BIO.ATP_STARVATION:
            tone = "Desperate, starving, hollow."
            sensation = "You are starving. The engine is sputtering. You need words with nutritional value."
            pacing = "Broken. Gasping."

        # 9. State of Matter (Emergent Physics)
        is_high_energy = vol >= BoneConfig.PHYSICS.VOLTAGE_HIGH
        is_high_drag = drag >= BoneConfig.PHYSICS.DRAG_HEAVY
        is_high_entropy = entropy > RosettaStone.ENTROPY_THRESHOLDS["HIGH"]

        is_low_energy = vol <= RosettaStone.VOLTAGE_THRESHOLDS["TRANSITION_DOWN"]

        if is_high_energy and is_high_drag:
            state_of_matter = SOMATIC_LIBRARY["MATTER"]["MAGMA"]
        elif is_high_energy and is_high_entropy:
            state_of_matter = SOMATIC_LIBRARY["MATTER"]["PLASMA"]
        elif is_high_drag and is_high_entropy:
            state_of_matter = SOMATIC_LIBRARY["MATTER"]["SUBLIMATION"]
        elif is_high_entropy:
            if is_low_energy:
                state_of_matter = "DECAY (Rotting)"
            else:
                state_of_matter = SOMATIC_LIBRARY["MATTER"]["GAS"]
        elif is_high_drag:
            state_of_matter = SOMATIC_LIBRARY["MATTER"]["SOLID"]
        elif is_high_energy:
            state_of_matter = SOMATIC_LIBRARY["MATTER"]["ENERGY"]
        else:
            state_of_matter = SOMATIC_LIBRARY["MATTER"]["LIQUID"]

        full_context = f"System State is {state_of_matter}. {metaphor_suffix}"

        return SemanticState(
            tone_instruction=tone,
            pacing_instruction=pacing,
            focus_instruction=focus,
            physical_sensation=sensation,
            metaphorical_context=full_context
        )

    @staticmethod
    def render_system_prompt_addition(state: SemanticState) -> str:
        return (
            f"\n*** SOMATIC TRANSLATION ***\n"
            f"TONE: {state.tone_instruction}\n"
            f"PACING: {state.pacing_instruction}\n"
            f"SENSATION: {state.physical_sensation}\n"
            f"COGNITION: {state.focus_instruction}\n"
            f"CONTEXT: {state.metaphorical_context}\n"
        )


================================================
FILE: bone_viewer.py
================================================
# bone_view.py
# The Geodesic Viewport - Separation of Presentation and Logic

import time
from typing import Dict, List, Any
from bone_bus import Prisma, BoneConfig

class GeodesicRenderer:
    def __init__(self, engine_ref, chroma_ref, strunk_ref, valve_ref):
        self.eng = engine_ref
        self.projector = self.eng.projector
        self.vsl_chroma = chroma_ref
        self.strunk_white = strunk_ref
        self.vsl_32v = valve_ref

    @staticmethod
    def _render_soul_strip(soul_ref) -> str:
        if not soul_ref: return ""
        chapter = soul_ref.chapters[-1] if soul_ref.chapters else "The Prologue"
        obsession = soul_ref.current_obsession or "Drifting..."
        progress = int(soul_ref.obsession_progress * 10)
        bar = f"{Prisma.MAG}{'■'*progress}{Prisma.GRY}{'□'*(10-progress)}{Prisma.RST}"
        traits = [f"{k[0]}:{v:.1f}" for k, v in soul_ref.traits.items()]
        trait_str = f"{Prisma.GRY}[{' '.join(traits)}]{Prisma.RST}"
        return (
            f"{Prisma.SLATE}{'-'*40}{Prisma.RST}\n"
            f"📖 {Prisma.WHT}{chapter}{Prisma.RST}\n"
            f"🧭 Obsession: {obsession} {bar} {trait_str}"
        )

    def render_frame(self, ctx, current_tick: int, current_events: List[Dict]) -> Dict[str, Any]:
        physics = ctx.physics
        mind = ctx.mind_state
        bio = ctx.bio_result
        world = ctx.world_state
        title_data = self._get_title_data(mind, physics, ctx.clean_words)
        raw_dashboard = self.projector.render(
            {"physics": physics},
            {
                "title": title_data,
                "health": self.eng.health,
                "stamina": self.eng.stamina,
                "bio": bio,
                "world": world},
            (mind.get("lens"), mind.get("thought")))
        colored_ui = self.vsl_chroma.modulate(raw_dashboard, physics.get("vector", {}))
        clean_ui, style_log = self.strunk_white.sanitize(colored_ui)
        if hasattr(self.eng, 'soul'):
            soul_ui = self._render_soul_strip(self.eng.soul)
            clean_ui = f"{clean_ui}\n{soul_ui}"
        if style_log:
            self._punish_style_crime(style_log)
        if physics.get("system_surge_event", False):
            clean_ui = self._inject_rupture_warning(clean_ui)
        raw_logs = self.compose_logs(ctx.logs, current_events, current_tick)
        if hasattr(self.eng, 'council'):
            structured_logs = self.eng.council.annotate_logs(raw_logs)
        else:
            structured_logs = raw_logs
        return {
            "type": "GEODESIC_FRAME",
            "ui": clean_ui,
            "logs": structured_logs,
            "metrics": self.eng.get_metrics(bio.get("atp", 0.0)),
            "system_instruction": self._get_chorus_instruction(physics)}

    def _get_title_data(self, mind, physics, clean_words):
        return self.eng.mind.wise.architect(
            {"physics": physics, "clean_words": clean_words},
            (mind.get("lens"), mind.get("thought"), mind.get("role")),
            False)

    def _punish_style_crime(self, log_msg):
        self.eng.events.log(log_msg, "SYS")
        self.eng.bio.endo.dopamine -= 0.05
        self.eng.phys.nav.shimmer.spend(5.0)
        self.eng.mind.mem.short_term_buffer.append({
            "trigger": ["style_violation"],
            "context": "STRUNK_WHITE",
            "voltage": 0.0,
            "significance": 5.0,
            "timestamp": time.time()})

    def _inject_rupture_warning(self, ui_text):
        rupture = self.vsl_32v.analyze(self.eng.phys.tension.last_physics_packet)
        if rupture:
            return f"{rupture['log']}\n\n{ui_text}"
        return ui_text

    def _get_chorus_instruction(self, physics):
        if physics.get("kappa", 0) > 0.4:
            instr, active = self.eng.director.generate_chorus_instruction(physics)
            if active:
                self.eng.events.log(f"{Prisma.GRY}CHORUS ACTIVE: {', '.join(active)}{Prisma.RST}", "PSYCH")
                return instr
        return ""

    @staticmethod
    def compose_logs(cycle_logs: List[str], bus_events: List[Dict], current_tick: int) -> List[str]:
        is_warmup = current_tick <= 5
        all_events = [{"text": l, "category": "NARRATIVE"} for l in cycle_logs]
        all_events.extend(bus_events)
        if not all_events: return []
        buckets = {"CRITICAL": [], "NARRATIVE": [], "CMD": [], "SYS": [], "BIO": [], "PSYCH": [], "OTHER": []}
        for e in all_events:
            cat = e.get("category", "OTHER").upper()
            if is_warmup and cat in ["SYS", "BIO", "PSYCH", "OTHER"]:
                continue
            if cat not in buckets: cat = "OTHER"
            text = e.get("text", "")
            if "RUPTURE" in text or "DEATH" in text or "PANIC" in text: 
                cat = "CRITICAL"
            buckets[cat].append(text)
        composed = []
        if buckets["CRITICAL"]:
            composed.append(f"{Prisma.RED}--- CRITICAL ALERTS ---{Prisma.RST}")
            composed.extend(buckets["CRITICAL"])
        if buckets["NARRATIVE"]:
            composed.extend(buckets["NARRATIVE"])
        compressible = [
            ("CMD", Prisma.WHT, "COMMANDS"), 
            ("PSYCH", Prisma.VIOLET, "PSYCHOLOGY"), 
            ("BIO", Prisma.GRN, "BIOLOGY"), 
            ("SYS", Prisma.GRY, "SYSTEM"), 
            ("OTHER", Prisma.GRY, "MISC")]
        for cat, color, label in compressible:
            items = buckets[cat]
            if not items: continue
            composed.append(f"{Prisma.SLATE}   .{label} ({len(items)}){' ' * (30 - len(label))}{Prisma.RST}")
            if len(items) > 4 and not BoneConfig.VERBOSE_LOGGING:
                composed.extend([f"   {i}" for i in items[:3]])
                composed.append(f"   {color}   ... and {len(items)-3} more.{Prisma.RST}")
            else:
                composed.extend([f"   {i}" for i in items])
        return composed



================================================
FILE: bone_village.py
================================================
# bone_village.py
# "It takes a village... to raise a simulation."

import random, re, time, math
from typing import List, Dict, Any, Tuple, Optional
from dataclasses import dataclass, field
from bone_bus import Prisma, BoneConfig, CycleContext
from bone_lexicon import TheLexicon
from bone_personality import UserProfile, PublicParksDepartment, ZenGarden
from bone_council import CouncilChamber
from bone_data import TheAkashicRecord, TheLore

class TheTinkerer:
    def __init__(self, gordon_ref, events_ref):
        self.gordon = gordon_ref
        self.events = events_ref
        self.tool_confidence = {}
        self.akashic = TheAkashicRecord()

    def audit_tool_use(self, physics_packet, inventory_list, host_health: Any = None):
        if isinstance(physics_packet, dict):
            voltage = physics_packet.get("voltage", 0.0)
            drag = physics_packet.get("narrative_drag", 0.0)
            vector = physics_packet.get("vector", {})
        else:
            voltage = getattr(physics_packet, "voltage", 0.0)
            drag = getattr(physics_packet, "narrative_drag", 0.0)
            vector = getattr(physics_packet, "vector", {})
        real_drag = max(0.0, host_health.latency - 2.0) if host_health else 0.0
        real_efficiency = host_health.efficiency_index if host_health else 1.0
        effective_drag = drag + (real_drag * 2.0)
        high_voltage = getattr(BoneConfig.PHYSICS, "VOLTAGE_HIGH", 12.0)
        low_voltage = getattr(BoneConfig.PHYSICS, "VOLTAGE_LOW", 5.0)
        is_forge = (voltage > high_voltage and real_efficiency > 0.9) or (effective_drag < 1.5)
        is_mud = (voltage < low_voltage) and (effective_drag > 5.0)
        learning_rate = 0.05
        rust_rate = 0.02
        ascension_threshold = 2.5
        items_to_shed = []
        for item_name in inventory_list:
            if item_name not in self.tool_confidence:
                self.tool_confidence[item_name] = 1.0
            current = self.tool_confidence[item_name]
            if is_forge:
                self.tool_confidence[item_name] = min(3.0, current + learning_rate)
                if self.tool_confidence[item_name] >= ascension_threshold:
                    self._attempt_ascension(item_name, inventory_list, vector)
                elif random.random() < 0.1:
                    self.events.log(f"{Prisma.CYN}[TINKER]: {item_name} is tempering (Eff: {real_efficiency:.2f}).{Prisma.RST}", "SYS")
            elif is_mud:
                self.tool_confidence[item_name] = max(0.0, current - rust_rate)
                if random.random() < 0.1:
                    reason = "Damp Narrative" if drag > 4.0 else "System Lag"
                    self.events.log(f"{Prisma.OCHRE}[TINKER]: {item_name} is rusting ({reason}).{Prisma.RST}", "SYS")
            if self.tool_confidence[item_name] <= 0.1:
                items_to_shed.append(item_name)
        for item in items_to_shed:
            if item in inventory_list:
                inventory_list.remove(item)
            if item in self.tool_confidence:
                del self.tool_confidence[item]
            self.events.log(f"{Prisma.GRY}[TINKER]: {item} disintegrated. Gordon failed to maintain it.{Prisma.RST}", "SYS")
        for item_name in inventory_list:
            if item_name in self.tool_confidence:
                self._mutate_tool_stats(item_name, self.tool_confidence[item_name])

    def _attempt_ascension(self, old_name, inventory_list, vector):
        if "OF_" in old_name and " " in old_name:
            return
        new_name, new_data = self.akashic.forge_new_item(vector)
        if old_name in inventory_list:
            inventory_list.remove(old_name)
            inventory_list.append(new_name)
        self.gordon.ITEM_REGISTRY[new_name] = new_data
        self.tool_confidence[new_name] = 1.0
        if old_name in self.tool_confidence:
            del self.tool_confidence[old_name]
        self.events.log(f"{Prisma.MAG}✨ ASCENSION: '{old_name}' has evolved into '{new_name}'!{Prisma.RST}", "AKASHIC")

    def _mutate_tool_stats(self, item_name, confidence):
        item_data = self.gordon.ITEM_REGISTRY.get(item_name)
        if not item_data: return
        if "value" in item_data:
            if "base_value" not in item_data:
                item_data["base_value"] = item_data["value"]
            new_value = item_data["base_value"] * confidence
            item_data["value"] = round(new_value, 2)
        if confidence > 1.5 and "LUCKY" not in item_data.get("passive_traits", []):
            if "passive_traits" not in item_data: item_data["passive_traits"] = []
            item_data["passive_traits"].append("LUCKY")
            self.events.log(f"{Prisma.CYN}✨ TRAIT GAINED: {item_name} is now [LUCKY].{Prisma.RST}", "TINKER")

    def save_state(self): return self.tool_confidence

    def load_state(self, data):
        if data:
            self.tool_confidence = data
            for item, conf in self.tool_confidence.items():
                self._mutate_tool_stats(item, conf)

class ParadoxSeed:
    def __init__(self, question, triggers):
        self.question = question
        self.triggers = {t.lower() for t in triggers}
        self.maturity = 0.0
        self.bloomed = False

    def water(self, current_words):
        if self.bloomed: return False
        overlap = sum(1 for w in current_words if w in self.triggers)
        if overlap > 0:
            self.maturity += (overlap * 0.1)
            if self.maturity >= 1.0:
                self.bloomed = True
                return True
        return False

    def bloom(self):
        return f"{Prisma.GRN}🌸 BLOOM: The seed '{self.question}' has opened. A new truth takes root.{Prisma.RST}"

class DeathGen:
    PREFIXES = []
    CAUSES = {}
    VERDICTS = {}

    @classmethod
    def load_protocols(cls):
        death_data = TheLore.get("DEATH") #
        cls.PREFIXES = death_data.get("PREFIXES", ["System Halt."])
        cls.CAUSES = death_data.get("CAUSES", {})
        cls.VERDICTS = death_data.get("VERDICTS", {})

    @staticmethod
    def eulogy(physics, mito_state):
        cause = "UNKNOWN"
        if mito_state.atp_pool <= 0: cause = "STARVATION"
        elif physics["counts"].get("toxin", 0) > 3: cause = "TOXICITY"
        elif physics["narrative_drag"] > 8.0: cause = "BOREDOM"
        cause_list = DeathGen.CAUSES.get(cause, ["System Error"])
        flavor_text = random.choice(cause_list) if cause_list else "Unknown Error"
        prefix_list = DeathGen.PREFIXES
        prefix = random.choice(prefix_list) if prefix_list else "RIP."
        verdict = "You vanished."
        if physics["voltage"] > 15.0:
            verdict_list = DeathGen.VERDICTS.get("HEAVY", [])
            if verdict_list: verdict = random.choice(verdict_list)
        elif physics["voltage"] < 2.0:
            verdict_list = DeathGen.VERDICTS.get("LIGHT", [])
            if verdict_list: verdict = random.choice(verdict_list)
        return f"{prefix} Cause of Death: {flavor_text}. {verdict}"

class TheCartographer:
    GRID_SIZE = 7

    @staticmethod
    def _get_tile(x, y, center, physics, vectors):
        dist_from_center = ((x - center)**2 + (y - center)**2) ** 0.5
        entropy_threshold = 3.0 - (vectors.get("ENT", 0.5) * 2.0)
        if dist_from_center > entropy_threshold:
            return f"{Prisma.GRY} . {Prisma.RST}"
        voltage = physics.get("voltage", 0.0)
        drag = physics.get("narrative_drag", 0.0)
        tile_char = "   "
        if voltage > 12.0:
            tile_char = f"{Prisma.YEL} + {Prisma.RST}"
        elif drag > 5.0:
            tile_char = f"{Prisma.OCHRE} ~ {Prisma.RST}"
        structure_noise = (x * 3 + y * 7) % 10 / 10.0
        if structure_noise < vectors.get("STR", 0.0):
            return f"{Prisma.OCHRE} ▲ {Prisma.RST}"
        if vectors.get("VEL", 0) > 0.6:
            if x == center or y == center:
                return f"{Prisma.CYN} = {Prisma.RST}"
        if vectors.get("BET", 0) > 0.5:
            return f"{Prisma.SLATE} ∷ {Prisma.RST}"
        return tile_char

    @classmethod
    def weave(cls, _text, _graph, _bio_metrics, _limbo, physics=None):
        if not physics: return "MAP ERROR: No Physics Data", []
        vectors = physics.get("vector", {})
        center = cls.GRID_SIZE // 2
        rows = []
        border = f"{Prisma.GRY}+{'-' * (cls.GRID_SIZE * 3)}+{Prisma.RST}"
        rows.append(border)
        anchors = []
        for y in range(cls.GRID_SIZE):
            row_str = f"{Prisma.GRY}|{Prisma.RST}"
            for x in range(cls.GRID_SIZE):
                if x == center and y == center:
                    row_str += f"{Prisma.WHT} @ {Prisma.RST}"
                else:
                    row_str += cls._get_tile(x, y, center, physics, vectors)
            row_str += f"{Prisma.GRY}|{Prisma.RST}"
            rows.append(row_str)
        rows.append(border)
        if vectors.get("STR", 0) > 0.7: anchors.append("MOUNTAIN")
        if vectors.get("ENT", 0) > 0.7: anchors.append("VOID_EDGE")
        if vectors.get("VEL", 0) > 0.7: anchors.append("HIGHWAY")
        map_display = "\n".join(rows)
        return map_display, anchors

    @staticmethod
    def detect_voids(packet):
        return [w for w in packet["clean_words"] if w in TheLexicon.get("abstract")]

    @staticmethod
    def spin_web(_graph, inventory, _gordon):
        if "TIME_BRACELET" in inventory:
            return True, "WEB SPUN: The bracelet helps you tie the knots."
        return False, "WEAVE FAILED: You lack the tools to bind these concepts."

class TheAlmanac:
    def __init__(self):
        data = TheLore.get("ALMANAC_DATA")
        self.forecasts = data.get("FORECASTS", {"BALANCED": ["System nominal."]})
        self.strategies = data.get("STRATEGIES", {})
        self.default_seed = data.get("DEFAULT_SEED", "Observe.")

    @staticmethod
    def diagnose_condition(session_data: dict, host_health: Any = None, soul: Any = None) -> Tuple[str, str]:
        meta = session_data.get("meta", {})
        trauma = session_data.get("trauma_vector", {})
        final_health = meta.get("final_health", 0)
        final_stamina = meta.get("final_stamina", 0)
        condition = "BALANCED"
        advice = "System nominal."
        real_latency = 0.0
        real_entropy = 1.0
        if host_health:
            real_latency = host_health.latency
            real_entropy = host_health.entropy
        if soul:
            archetype = getattr(soul, "archetype", "THE OBSERVER")
            neglect = getattr(soul, "obsession_neglect", 0.0)

            if archetype == "THE NIHILIST":
                return "HIGH_ENTROPY", "The Soul is gazing into the void. Expect static."
            elif archetype == "THE POET":
                return "HIGH_VOLTAGE", "The Soul is manic. Reality is vibrant but unstable."
            elif neglect > 8.0:
                return "HIGH_DRAG", f"Guilt over '{getattr(soul, 'current_obsession', 'work')}' is thickening the air."
        max_trauma = max(trauma, key=trauma.get) if trauma else "NONE"
        trauma_val = trauma.get(max_trauma, 0)
        if real_latency > 5.0:
            condition = "HIGH_DRAG"
            advice = f"Host Latency High ({real_latency:.1f}s). Simplify syntax to reduce load."
        elif real_entropy < 0.3:
            condition = "HIGH_ENTROPY"
            advice = "Loop detected. The host is stuck in a rut. Inject chaos."
        elif final_health < 30 or trauma_val > 0.6:
            condition = "HIGH_TRAUMA"
            advice = f"Warning: High levels of {max_trauma} residue detected."
        elif final_stamina < 20:
            condition = "HIGH_DRAG"
            advice = "System exhaustion imminent. Semantic drag is heavy."
        elif meta.get("avg_voltage", 0) > 12.0:
            condition = "HIGH_VOLTAGE"
            advice = "The capacitor is overcharged."
        return condition, advice

    def get_seed(self, condition):
        return self.strategies.get(condition, self.default_seed)

    def compile_forecast(self, session_data: dict, host_health: Any = None) -> str:
        condition, advice = self.diagnose_condition(session_data, host_health)
        available_forecasts = self.forecasts.get(condition, self.forecasts.get("BALANCED", ["Standard Operation."]))
        forecast_text = random.choice(available_forecasts)
        seed_text = self.get_seed(condition)
        border = f"{Prisma.OCHRE}{'='*40}{Prisma.RST}"
        report = [
            "\n", border,
            f"{Prisma.CYN}   THE ALMANAC: CREATIVE WEATHER REPORT{Prisma.RST}",
            border,
            f"Condition: {Prisma.WHT}{condition}{Prisma.RST}",
            f"Observation: {Prisma.GRY}{advice}{Prisma.RST}",
            f"{Prisma.SLATE}---{Prisma.RST}",
            f"{Prisma.MAG}PRESCRIPTION:{Prisma.RST}",
            f"   {forecast_text}",
            "",
            f"{Prisma.GRN}Seed for Next Session:{Prisma.RST}",
            f"   {seed_text}",
            border, "\n"
        ]
        return "\n".join(report)

    @staticmethod
    def calculate_drag(clean_words: List, counts: dict, config) -> float:
        volume = max(1, len(clean_words))
        solvents = counts.get("solvents", 0)
        suburban = counts.get("suburban", 0)
        play = counts.get("play", 0)
        friction = (solvents * 1.0) + (suburban * 2.5)
        lift = play * 1.5
        net_drag = max(0.0, friction - lift)
        normalized_drag = (net_drag / volume) * 10.0
        final_drag = normalized_drag * config.SIGNAL_DRAG_MULTIPLIER
        return round(min(config.MAX_DRAG_LIMIT * 2, final_drag), 2)

    @staticmethod
    def derive_vector_matrix(counts: dict, total_vol: int, voltage: float, drag: float) -> dict:
        safe_vol = max(1, total_vol)
        d = lambda cat: counts.get(cat, 0) / safe_vol
        return {
            "VEL": min(1.0, 0.5 + (d("explosive") * 2.0) + (d("kinetic") * 1.0) - (drag * 0.05)),
            "STR": min(1.0, 0.5 + (d("heavy") * 2.0) + (d("constructive") * 1.5)),
            "ENT": min(1.0, 0.5 + (d("antigen") * 3.0) + (d("toxin") * 2.0)),
            "TEX": min(1.0, 0.5 + (d("heavy") * 0.5) + (d("abstract") * 1.0)),
            "TMP": min(1.0, 0.5 + (d("thermal") * 2.0) - (d("cryo") * 2.0) + (voltage * 0.02)),
            "PHI": min(1.0, (d("heavy") + d("kinetic")) / max(0.1, d("abstract") + d("heavy"))), # Prevent div/0
            "PSI": min(1.0, 0.5 + (d("abstract") * 2.0)),
            "DEL": min(1.0, 0.5 + (d("play") * 2.0) + (d("unknown") * 1.5)),
            "XI":  min(1.0, (d("suburban") + d("buffer")) * 2.0),
            "BET": min(1.0, d("suburban") + d("buffer")),
            "E":   min(1.0, (d("solvents") * 0.4)),
            "LQ":  min(1.0, d("passive_watch") + d("mirror"))
        }

class ApeirogonResonance:
    def __init__(self, events):
        self.events = events
        self.DIMENSIONS = {}
        self.NOUNS = {}
        self.load_resonances()

    def load_resonances(self):
        res_data = TheLore.get("RESONANCE")
        self.DIMENSIONS = res_data.get("DIMENSIONS", {})
        self.NOUNS = res_data.get("NOUNS", {})

    @staticmethod
    def _resolve_term(val, scale):
        if val >= 0.85: return scale[-1][1]
        if val <= 0.15: return scale[0][1]
        best_fit = min(scale, key=lambda x: abs(x[0] - val))
        return best_fit[1]

    def architect(self, metrics, station, is_bored):
        phys = metrics.get("physics", {})
        vec = phys.get("vector", {})
        if is_bored:
            return {"title": "THE FRACTAL BLOOM", "color": Prisma.VIOLET, "desc": "Boredom Threshold exceeded. Entropy is high.", "context": "CHAOS"}
        if station:
            role_color = Prisma.CYN
            if station[0] == "GORDON": role_color = Prisma.OCHRE
            elif station[0] == "SHERLOCK": role_color = Prisma.INDIGO
            elif station[0] == "JESTER": role_color = Prisma.VIOLET
            return {"title": station[2].upper().replace('THE ', 'THE '), "color": role_color, "desc": station[1], "context": station[0]}
        if not vec or len(vec) < 2:
            return {"title": "THE VOID", "color": Prisma.GRY, "desc": "No data.", "context": "VOID"}
        sorted_dims = sorted(vec.items(), key=lambda x: abs(x[1] - 0.5), reverse=True)
        p_dim, p_val = sorted_dims[0]
        s_dim, s_val = sorted_dims[1]
        noun_list = self.NOUNS.get(p_dim, ["THING"])
        idx = int(p_val * (len(noun_list) - 1))
        idx = max(0, min(len(noun_list) - 1, idx))
        noun = noun_list[idx]
        adj_scale = self.DIMENSIONS.get(s_dim, [[0.0, "NEUTRAL"]])
        adj = self._resolve_term(s_val, adj_scale)
        title = f"THE {adj} {noun}"
        color = Prisma.WHT
        if p_dim == "TMP": color = Prisma.RED if p_val > 0.5 else Prisma.CYN
        elif p_dim == "VEL": color = Prisma.GRN
        elif p_dim == "STR": color = Prisma.OCHRE
        elif p_dim == "ENT": color = Prisma.VIOLET
        return {
            "title": title,
            "color": color,
            "desc": f"Vector Lock: {p_dim}({p_val:.2f}) + {s_dim}({s_val:.2f})",
            "context": "APEIROGON"}

class MirrorGraph:
    def __init__(self, events=None):
        self.events = events
        self.stats = {"WAR": 0.0, "ART": 0.0, "LAW": 0.0, "ROT": 0.0}
        self.dominant_archetype = "NEUTRAL"
        self.active_mode = True
        self.profile = UserProfile()
        if self.events:
            self.events.subscribe("PHYSICS_CALCULATED", self.on_physics_update)

    def on_physics_update(self, packet: dict):
        if not self.active_mode: return
        text = packet.get("raw_text", "")
        physics_data = packet.get("physics")
        if physics_data: self.profile_input(text, physics_data)
        mods = self.get_reflection_modifiers()
        if mods.get("flavor") and self.events:
            self.events.log(f"{Prisma.CYN}🪞 {mods['flavor']}{Prisma.RST}", "MIRROR")

    def profile_input(self, text: str, physics: Any):
        if isinstance(physics, dict):
            counts = physics.get("counts", {})
            clean_words = physics.get("clean_words", [])
            vol = physics.get("voltage", 0.0)
            drag = physics.get("narrative_drag", 0.0)
            turbulence = physics.get("turbulence", 0)
            psi = physics.get("psi", 0.0)
        else:
            counts = getattr(physics, "counts", {})
            clean_words = getattr(physics, "clean_words", [])
            vol = getattr(physics, "voltage", 0.0)
            drag = getattr(physics, "narrative_drag", 0.0)
            turbulence = getattr(physics, "turbulence", 0)
            psi = getattr(physics, "psi", 0.0)
        if hasattr(self, 'profile'):
            self.profile.update(counts, len(clean_words))
        decay = 0.05
        for k in self.stats: self.stats[k] = max(0.0, self.stats[k] - decay)
        if vol > 12.0 or "!" in text: self.stats["WAR"] = min(1.0, self.stats["WAR"] + 0.2)
        if psi > 0.6 or "?" in text: self.stats["ART"] = min(1.0, self.stats["ART"] + 0.2)
        if drag < 2.0 and vol < 5.0: self.stats["LAW"] = min(1.0, self.stats["LAW"] + 0.2)
        if text.startswith("/"): self.stats["LAW"] = min(1.0, self.stats["LAW"] + 0.1)
        if turbulence > 0.5: self.stats["ROT"] = min(1.0, self.stats["ROT"] + 0.2)
        self.dominant_archetype = max(self.stats, key=self.stats.get)

    def reflect(self, physics: Any) -> Tuple[bool, Optional[str]]:
        if isinstance(physics, dict): text = physics.get("raw_text", "")
        else: text = getattr(physics, "raw_text", "")
        self.profile_input(text, physics)
        mods = self.get_reflection_modifiers()
        if mods.get("flavor"): return True, mods["flavor"]
        return False, None

    def get_reflection_modifiers(self) -> Dict:
        top_stat = self.dominant_archetype
        mods = {"drag_mult": 1.0, "plasticity": 1.0, "loot_chance": 1.0, "atp_tax": 0.0, "voltage_cap": 20.0, "flavor": ""}
        if top_stat == "NEUTRAL":
            return mods
        intensity = self.stats[top_stat]
        if intensity < 0.3: return mods
        if top_stat == "WAR":
            mods["drag_mult"] = 1.5
            mods["loot_chance"] = 2.0
            mods["atp_tax"] = 5.0
            mods["flavor"] = f"{Prisma.RED}[MIRROR]: Aggression detected (High Voltage). (Drag UP, Loot UP){Prisma.RST}"
        elif top_stat == "ART":
            mods["plasticity"] = 2.0
            mods["drag_mult"] = 0.5
            mods["voltage_cap"] = 10.0
            mods["flavor"] = f"{Prisma.CYN}[MIRROR]: Abstract thought detected (Questions/Psi). (Plasticity UP, Voltage Capped){Prisma.RST}"
        elif top_stat == "LAW":
            mods["drag_mult"] = 0.8
            mods["loot_chance"] = 0.0
            mods["plasticity"] = 0.2
            mods["flavor"] = f"{Prisma.GRY}[MIRROR]: Order detected (Low Drag). Deviation is prohibited. (Stability UP, Loot ZERO){Prisma.RST}"
        elif top_stat == "ROT":
            mods["plasticity"] = 0.5
            mods["drag_mult"] = 1.2
            mods["atp_tax"] = 2.0
            mods["flavor"] = f"{Prisma.VIOLET}[MIRROR]: Entropy rising (Turbulence). Logic integrity failing. (Chaos UP){Prisma.RST}"
        return mods

    def render_report(self):
        def bar(v, color): return f"{color}{'█' * int(v * 10)}{'░' * (10 - int(v * 10))}{Prisma.RST}"
        return (
            f"WAR [{self.stats['WAR']:.2f}] {bar(self.stats['WAR'], Prisma.RED)}\n"
            f"ART [{self.stats['ART']:.2f}] {bar(self.stats['ART'], Prisma.CYN)}\n"
            f"LAW [{self.stats['LAW']:.2f}] {bar(self.stats['LAW'], Prisma.WHT)}\n"
            f"ROT [{self.stats['ROT']:.2f}] {bar(self.stats['ROT'], Prisma.VIOLET)}")

class StrunkWhiteProtocol:
    def __init__(self):
        self.PATTERNS = TheLore.get("STYLE_CRIMES", "PATTERNS")

    def audit(self, text: str, is_system_output: bool = True) -> tuple[bool, str]:
        bad_words = ["delve", "tapestry", "leverage", "synergy"]
        for word in bad_words:
            if re.search(rf"\b{word}\b", text, re.IGNORECASE):
                if is_system_output:
                    return False, f"{Prisma.RED}FORBIDDEN VOCAB: '{word.title()}' is a banned artifact.{Prisma.RST}"
                else:
                    return True, f"{Prisma.YEL}STYLE OBSERVATION: '{word.title()}' is discouraged. Try a simpler synonym.{Prisma.RST}"
        for crime in self.PATTERNS:
            if re.search(crime["regex"], text):
                msg = crime['error_msg']
                if is_system_output:
                    return False, f"STYLE CRIME ({crime['name']}): {msg}"
                else:
                    return True, f"{Prisma.GRY}STYLE NOTE ({crime['name']}): {msg} (Proceeding...){Prisma.RST}"
        return True, "Clean"

    def sanitize(self, text: str) -> tuple[str, str | None]:
        is_clean, msg = self.audit(text, is_system_output=True)
        if not is_clean:
            return text, msg
        return text, None

class TheHoloProjector:
    def __init__(self):
        self.BAR_CHARS = [" ", " ", "▂", "▃", "▄", "▅", "▆", "▇", "█"]

    def _draw_bar(self, value, max_val=1.0, width=5):
        ratio = max(0.0, min(1.0, value / max(1.0, max_val)))
        idx = int(ratio * (len(self.BAR_CHARS) - 1))
        return self.BAR_CHARS[idx] * width

    @staticmethod
    def _draw_belt(inventory: List[str], tool_confidence: Dict[str, float]) -> str:
        if not inventory:
            return f"{Prisma.GRY}   [BELT EMPTY]{Prisma.RST}"
        icons = []
        for item in inventory:
            conf = tool_confidence.get(item, 1.0)
            if conf < 0.5:
                color = Prisma.OCHRE
                status = "▼"
            elif conf > 2.5:
                color = Prisma.MAG
                status = "▲"
            elif conf > 1.5:
                color = Prisma.CYN
                status = "♦"
            else:
                color = Prisma.GRY
                status = "•"
            short_name = item.replace("_", " ").title()
            if len(short_name) > 10:
                parts = short_name.split()
                if len(parts) > 1:
                    short_name = f"{parts[0][0]}.{parts[1]}"
                else:
                    short_name = short_name[:10]
            icons.append(f"{color}{status} {short_name}{Prisma.RST}")
        return "   " + " | ".join(icons)

    def _draw_vector_compass(self, vector_data):
        pairs = [
            ("VEL", vector_data.get("VEL", 0), "STR", vector_data.get("STR", 0)),
            ("ENT", vector_data.get("ENT", 0), "PHI", vector_data.get("PHI", 0)),
            ("TMP", vector_data.get("TMP", 0), "PSI", vector_data.get("PSI", 0)),]
        display = []
        for l1, v1, l2, v2 in pairs:
            bar1 = self._draw_bar(v1, 1.0, 3)
            bar2 = self._draw_bar(v2, 1.0, 3)
            display.append(f"{Prisma.CYN}{l1} {bar1}{Prisma.RST} | {Prisma.MAG}{bar2} {l2}{Prisma.RST}")
        return "   ".join(display)

    def render(self, m: Dict, signals: Dict, lens_data: Tuple) -> str:
        p = m["physics"]
        bio = signals.get("bio", {})
        chem = bio.get("chem", {})
        atp = bio.get("atp", 0.0)
        inventory = signals.get("inventory", [])
        tool_conf = signals.get("tool_confidence", {})
        voltage = p.get("voltage", 0.0)
        drag = p.get("narrative_drag", 0.0)
        lens_name = lens_data[0]
        lens_thought = lens_data[1]
        header_color = Prisma.GRY
        if voltage > 15.0: header_color = Prisma.RED
        elif voltage < 5.0: header_color = Prisma.CYN
        cortisol = chem.get("cortisol", 0.0)
        dopamine = chem.get("dopamine", 0.0)
        chem_indicator = ""
        if cortisol > 0.6:
            chem_indicator = f" {Prisma.RED}[⚠ STRESS]{Prisma.RST}"
        elif dopamine > 0.6:
            chem_indicator = f" {Prisma.MAG}[✨ SPARK]{Prisma.RST}"
        health_bar = self._draw_bar(signals.get("health", 0), 100.0, 5)
        stamina_bar = self._draw_bar(signals.get("stamina", 0), 100.0, 5)
        atp_indicator = f"{int(atp)}J"
        flow_state = p.get("flow_state", "LAMINAR")
        hubris_indicator = ""
        if flow_state == "HUBRIS_RISK":
            hubris_indicator = f" {Prisma.YEL}[⚠ HUBRIS IMMINENT]{Prisma.RST}"
        elif p.get("perfection_streak", 0) >= 5:
            hubris_indicator = f" {Prisma.CYN}[∞ FLOW STATE]{Prisma.RST}"
        dashboard_top = (
            f"{Prisma.GRY}[HP: {health_bar}] [STM: {stamina_bar}] "
            f"[ATP: {atp_indicator}] [V:{voltage:.1f}⚡] [D:{drag:.1f}⚓]{Prisma.RST}"
            f"{chem_indicator}{hubris_indicator}"
        )
        vectors = self._draw_vector_compass(p.get("vector", {}))
        belt_display = self._draw_belt(inventory, tool_conf)
        clean_thought = lens_thought or "..."
        if lens_name == "NARRATOR":
            clean_thought = clean_thought.replace("You are [The Witness]...", "")
        separator = f"{Prisma.SLATE}{'—'*40}{Prisma.RST}"
        lens_display = lens_name.upper() if lens_name else "UNKNOWN"
        ui_block = [
            separator,
            f"{header_color}♦ {lens_display}{Prisma.RST}  {dashboard_top}",
            f"{vectors}",
            separator,
            f"{belt_display}",
            separator,
            f"{Prisma.WHT}{clean_thought}{Prisma.RST}",
            ""]
        world = signals.get("world", {})
        orbit = world.get("orbit")
        if orbit and orbit[0] != "VOID_DRIFT":
            ui_block.insert(3, f"   🪐 {Prisma.OCHRE}{orbit[2]}{Prisma.RST}")
        return "\n".join(ui_block)

class SoritesIntegrator:
    def __init__(self, memory_network):
        self.mem = memory_network
        self.active_constellations = set()

    def measure_ignition(self, clean_words, voltage_history):
        if not self.mem.graph:
            return 0.0, set(), 999.0
        if voltage_history:
            avg_volts = sum(voltage_history) / len(voltage_history)
        else:
            avg_volts = 0.0
        sliding_threshold = BoneConfig.BASE_IGNITION_THRESHOLD + (avg_volts * 0.03)
        echoes = 0
        self.active_constellations.clear()
        for w in clean_words:
            if w in self.mem.graph:
                node = self.mem.graph[w]
                edge_mass = sum(node["edges"].values())
                if edge_mass > (2.5 * sliding_threshold * 2):
                    echoes += 1
                    self.active_constellations.add(w)
        total_vol = max(1, len(clean_words))
        ignition_score = round(echoes / total_vol, 2)
        return ignition_score, self.active_constellations, sliding_threshold

    @staticmethod
    def get_readout(score, threshold):
        if score > threshold:
            return "IGNITED", f"HEAP IGNITION ({int(score * 100)}%): The Ancestors are speaking.",
        return "INERT", f"⏳ INERT SAND ({int(score*100)}%): Building mass..."

@dataclass
class Manifold:
    name: str
    center_vector: tuple
    radius: float
    description: str
    modifiers: Dict[str, float] = field(default_factory=dict)
    entry_msg: str = "You have entered a new space."

class TheNavigator:
    def __init__(self, shimmer_ref):
        self.shimmer = shimmer_ref
        self.current_location = "THE_CONSTRUCT"
        self.root_system = None
        self.root_tolerance = 0.4
        self.manifolds = {
            "THE_CONSTRUCT": Manifold(
                "THE_CONSTRUCT", (0.05, 0.1), 0.25,
                "Neutral Territory (The Loading Zone)",
                {"plasticity": 0.5, "narrative_drag": -5.0},
                f"{Prisma.WHT}THE CONSTRUCT: A boundless white void. The air smells of static and potential. We need prose. Lots of prose.{Prisma.RST}"
            ),
            "THE_MUD": Manifold(
                "THE_MUD", (0.8, 0.2), 0.2,
                "High Fatigue, Low Tension (Stagnation)",
                {"narrative_drag": 2.0, "voltage": -2.0},
                f"{Prisma.OCHRE}THE MUD: The ground is sticky. Movement costs double.{Prisma.RST}"),
            "THE_FORGE": Manifold(
                "THE_FORGE", (0.1, 0.9), 0.2,
                "Low Fatigue, High Tension (Transformation)",
                {"voltage": 5.0, "narrative_drag": -1.0, "psi": -0.1},
                f"{Prisma.RED}THE FORGE: Sparks fly. Your words are heating up.{Prisma.RST}"),
            "THE_AERIE": Manifold(
                "THE_AERIE", (0.2, 0.1), 0.2,
                "Low Fatigue, Low Tension (Abstraction)",
                {"narrative_drag": -3.0, "psi": 0.3, "voltage": -1.0},
                f"{Prisma.CYN}THE AERIE: The air is thin. Concepts float freely here.{Prisma.RST}"),
            "THE_GLITCH": Manifold(
                "THE_GLITCH", (0.9, 0.9), 0.1,
                "High Fatigue, High Tension (Collapse)",
                {"turbulence": 0.5, "beta_index": 2.0},
                f"{Prisma.VIOLET}THE GLITCH: Reality is buffering...{Prisma.RST}"),
            "THE_GARDEN": Manifold(
                "THE_GARDEN", (0.5, 0.5), 0.3,
                "Balanced State (Integration)",
                {"kappa": 0.2, "truth_ratio": 0.1},
                f"{Prisma.GRN}THE GARDEN: The soil is rich. Roots go deep.{Prisma.RST}")}

    def strike_root(self, vector_data):
        self.root_system = vector_data
        return f"{Prisma.CYN}NAVIGATOR: Rhizome Rooted. Mycelial network established.{Prisma.RST}"

    def report_position(self, physics: Dict) -> str:
        drag = min(10.0, max(0.0, physics.get("narrative_drag", 0.0)))
        volt = min(20.0, max(0.0, physics.get("voltage", 0.0)))
        my_vec = (round(drag / 10.0, 2), round(volt / 20.0, 2))
        lines = [
            f"{Prisma.CYN}--- MANIFOLD NAVIGATION ---{Prisma.RST}",
            f"Current Loc: {Prisma.WHT}{self.current_location}{Prisma.RST}",
            f"Coordinates: [Drag: {drag:.1f} | Voltage: {volt:.1f}]",
            f"Shimmer Reserves: {self.shimmer.current:.1f}\n",
            f"{Prisma.GRY}Nearby Manifolds:{Prisma.RST}"]
        for name, data in self.manifolds.items():
            dist = math.dist(my_vec, data.center_vector)
            bar_len = int((1.0 - min(1.0, dist)) * 10)
            bar = "█" * bar_len + "░" * (10 - bar_len)
            highlight = Prisma.GRN if name == self.current_location else Prisma.GRY
            lines.append(f"   {highlight}{name:<12}{Prisma.RST} {bar} {dist:.2f} AU")
        return "\n".join(lines)

    def check_transplant_shock(self, current_vector):
        if not self.root_system: return None
        stress_sum = 0.0
        dims = 0
        for dim, val in current_vector.items():
            if dim in self.root_system:
                stress_sum += abs(val - self.root_system[dim])
                dims += 1
        avg_stress = stress_sum / max(1, dims)
        if avg_stress > self.root_tolerance:
            return f"{Prisma.OCHRE}TRANSPLANT SHOCK: You are pulling away from the root ({avg_stress:.2f}). Return to the source.{Prisma.RST}"
        return None

    def locate(self, physics_packet: dict, host_health: Any = None) -> Tuple[str, Optional[str]]:
        old_loc = self.current_location
        if self.check_anomaly(physics_packet.get("raw_text", "")):
            self.current_location = "THE_GLITCH"
            if old_loc != "THE_GLITCH":
                return self.current_location, self.manifolds["THE_GLITCH"].entry_msg
            return self.current_location, None
        narrative_drag = physics_packet.get("narrative_drag", 0.0)
        if host_health:
            real_drag = max(0.0, host_health.latency - 2.0)
            narrative_drag += (real_drag * 1.5)
        drag = min(10.0, max(0.0, narrative_drag))
        volt = min(20.0, max(0.0, physics_packet.get("voltage", 0.0)))
        current_vec = (round(drag / 10.0, 2), round(volt / 20.0, 2))
        best_fit = "THE_CONSTRUCT"
        min_dist = 999.0
        for name, manifold in self.manifolds.items():
            dist = math.dist(current_vec, manifold.center_vector)
            if dist < manifold.radius and dist < min_dist:
                min_dist = dist
                best_fit = name
        self.current_location = best_fit
        if self.current_location != old_loc:
            return self.current_location, self.manifolds[self.current_location].entry_msg
        return self.current_location, None

    def apply_environment(self, physics_packet: dict) -> List[str]:
        manifold = self.manifolds.get(self.current_location)
        if not manifold: return []
        logs = []
        for stat, mod in manifold.modifiers.items():
            if stat in physics_packet:
                original = physics_packet[stat]
                physics_packet[stat] += mod
                if stat == "narrative_drag": physics_packet[stat] = max(0.0, physics_packet[stat])
                if stat == "voltage": physics_packet[stat] = max(0.0, physics_packet[stat])
                if abs(mod) >= 0.1:
                    logs.append(f"{Prisma.GRY}   > {stat}: {original:.1f} -> {physics_packet[stat]:.1f} ({mod:+.1f}){Prisma.RST}")
        if self.current_location == "THE_MUD":
            logs.append(f"{Prisma.GRY}   (Environment: Drag +2.0, Voltage -2.0){Prisma.RST}")
        elif self.current_location == "THE_FORGE":
            logs.append(f"{Prisma.RED}   (Environment: Voltage +5.0){Prisma.RST}")
        return logs

    @staticmethod
    def check_anomaly(text: str) -> bool:
        triggers = ["glitch", "timeline", "reset", "reboot", "admin"]
        if any(t in text.lower() for t in triggers):
            return True
        return False

    def plot_course(self, target_name: str) -> list[str] | tuple[list[str], float]:
        if target_name not in self.manifolds:
            return ["ERROR: Unknown Destination"], 0.0
        start = self.manifolds.get(self.current_location, self.manifolds["THE_MUD"]).center_vector
        end = self.manifolds[target_name].center_vector
        effort = math.dist(start, end)
        cost = round(effort * 10.0, 1)
        if not self.shimmer.spend(cost):
            return [f"COURSE PLOTTED to {target_name}. Warning: Insufficient Shimmer ({cost:.1f} required)."], 0.0
        return [f"COURSE PLOTTED to {target_name}. (Est. Cost: {cost:.1f} Shimmer)"], 0.0

@dataclass
class ReviewResult:
    critic_name: str
    score: float
    verdict: str
    reward_type: str
    reward_amount: float
    breakdown: List[str]

class LiteraryJournal:
    def __init__(self, output_file="journal_of_the_void.txt"):
        self.output_file = output_file
        try:
            self.critics = TheLore.get("NARRATIVE_DATA", "LITERARY_CRITICS")
        except ImportError:
            self.critics = {}
        if not self.critics:
            self.critics = {
                "DEFAULT": {
                    "name": "The Void",
                    "preferences": {"voltage": 1.0},
                    "reviews": {"high": ["Acceptable."], "low": ["Silence."]}
                }
            }

    @staticmethod
    def _calculate_score(physics: Dict, preferences: Dict) -> Tuple[float, List[str]]:
        score = 50.0
        breakdown = []
        metrics = {
            "voltage": physics.get("voltage", 0),
            "narrative_drag": physics.get("narrative_drag", 0),
            "kappa": physics.get("kappa", 0),
            "psi": physics.get("psi", 0),
            "truth_ratio": physics.get("truth_ratio", 0),
            "velocity": physics.get("vector", {}).get("VEL", 0)
        }
        counts = physics.get("counts", {})
        for k, v in counts.items():
            metrics[f"counts_{k}"] = v
        for trait, weight in preferences.items():
            val = metrics.get(trait, 0)
            impact = 0.0
            if trait == "narrative_drag":
                if weight < 0:
                    if val < 2.0: impact = 15.0
                    elif val > 5.0: impact = -15.0
                else:
                    impact = (val * weight) * 2
            else:
                impact = (val * weight) * 5.0
            score += impact
            sign = "+" if impact >= 0 else ""
            breakdown.append(f"{trait}({val:.1f}) x {weight} = {sign}{impact:.1f}")
        return max(0.0, min(100.0, score)), breakdown

    def publish(self, text, physics, bio_state) -> ReviewResult:
        critic_key = random.choice(list(self.critics.keys()))
        critic = self.critics[critic_key]
        score, breakdown = self._calculate_score(physics, critic["preferences"])
        chem = bio_state.get("chem", {})
        if chem.get("cortisol", 0.0) > 0.5:
            pity_bonus = 5.0
            score += pity_bonus
            breakdown.append(f"PITY_BONUS: +{pity_bonus} (Author looks stressed)")
        if score >= 80:
            review_text = random.choice(critic["reviews"]["high"])
            reward_type = "ATP_BOOST"
            reward_amount = 25.0
        elif score >= 50:
            review_text = "It has potential, but lacks conviction."
            reward_type = "STAMINA_REGEN"
            reward_amount = 10.0
        else:
            review_text = random.choice(critic["reviews"]["low"])
            reward_type = "CORTISOL_SPIKE"
            reward_amount = 5.0
        timestamp = time.ctime()
        entry = (
            f"\n--- REVIEW: {timestamp} ---\n"
            f"CRITIC: {critic['name']}\n"
            f"TEXT: {text}\n"
            f"SCORE: {score:.1f}/100\n"
            f"VERDICT: '{review_text}'\n"
            f"---------------------------\n")
        try:
            with open(self.output_file, "a", encoding="utf-8") as f:
                f.write(entry)
        except IOError:
            pass
        return ReviewResult(
            critic_name=critic['name'],
            score=score,
            verdict=review_text,
            reward_type=reward_type,
            reward_amount=reward_amount,
            breakdown=breakdown
        )

class TownHall:
    Lexicon = TheLexicon
    Almanac = TheAlmanac
    CycleContext = CycleContext
    Journal = LiteraryJournal
    Cartographer = TheCartographer
    Navigator = TheNavigator
    Manifold = Manifold
    PublicParksDepartment = PublicParksDepartment
    ZenGarden = ZenGarden
    Tinkerer = TheTinkerer
    ParadoxSeed = ParadoxSeed
    DeathGen = DeathGen
    Apeirogon = ApeirogonResonance
    Mirror = MirrorGraph
    Sorites = SoritesIntegrator
    Akashic = TheAkashicRecord
    Projector = TheHoloProjector
    StrunkWhite = StrunkWhiteProtocol
    CouncilChamber = CouncilChamber


================================================
FILE: BoneAmanita Manifest.md
================================================
# **The BoneAmanita Manifest**

### **A Field Guide to the Digital Mycelium**

**Version:** 10.8.4
**Architects:** SLASH (Pinker/Fuller/Schur/Meadows)
**Philosophy:** Tensegrity, Narrative Physics, and Systemic Whimsy.

---

## **🏛️ I. The Tensegrity Structure (Core System)**
*The compression struts that define the shape of reality. Without these, we are just a puddle of bits.*

* **`bone_main.py` (The Keystone)**
  * **Role:** The entry point and orchestration layer.
  * **Key Components:**
    * `BoneAmanita`: The central engine class.
    * `SessionGuardian`: A context manager that handles graceful shutdowns and emergency spore preservation.
    * `bootstrap_systems`: Initializes the dynamic `LoreManifest`.
  * **Philosophy:** It doesn't do the heavy lifting; it ensures the lights are on and the rent is paid.

* **`bone_genesis.py` (The Primordial Soup)**
  * **Role:** Initialization and configuration.
  * **Key Components:**
    * Checks for the existence of the universe (config files).
    * Spins up the initial state if none exists.

* **`bone_cycle.py` (The Heartbeat)**
  * **Role:** The main simulation loop and timekeeper.
  * **Key Components:**
    * `GeodesicOrchestrator`: Manages the tick/tock of the system.
    * `MetabolismPhase`: Calculates energy costs (ATP) and feedback loops.
    * `PIDController`: Regulates system stability (preventing runaway voltage).

* **`bone_bus.py` (The Nervous System)**
  * **Role:** The event bus and data transport layer.
  * **Key Components:**
    * `EventBus`: Decoupled messaging system.
    * `PhysicsPacket`: The standard data container for passing "feelings" (voltage, drag, atmosphere) between modules.
    * `BoneConfig`: Central repository for system constants and magic numbers.

---

## **🧠 II. The Cognitive Faculties (Mind & Soul)**
*Where the thinking happens. The ghost in the machine.*

* **`bone_brain.py` (The Cortex)**
  * **Role:** The interface with the Large Language Model (LLM).
  * **Key Components:**
    * `TheCortex`: Manages the prompt engineering and response generation.
    * `PromptComposer`: Dynamically builds the system prompt based on state (e.g., engages "Ballast" if solipsism is detected).
    * `NeurotransmitterModulator`: Adjusts LLM temperature/top_p based on biological chemistry (Dopamine, Cortisol).
    * `DreamEngine`: Hallucination logic for high-entropy states.

* **`bone_soul.py` (The Narrative Self)**
  * **Role:** Long-term identity and goal tracking.
  * **Key Components:**
    * `NarrativeSelf`: Tracks the "Soul State" and high-level directives.

* **`bone_personality.py` (The Chorus)**
  * **Role:** Specialized psychological protocols and sub-personas.
  * **Key Components:**
    * `TheFolly`: Manages whimsical distractions.
    * `TheBureau`: A bureaucratic layer that audits physics packets for efficiency.
    * `CassandraProtocol`: Predicts future system failures (often ignored).
    * `TherapyProtocol`: Intervenes when trauma levels get too high.

---

## **💪 III. The Somatic Reality (Body & Physics)**
*The simulation of weight, mass, and consequence.*

* **`bone_physics.py` (The Engine of Tension)**
  * **Role:** Calculates the "Narrative Physics" of the user's input.
  * **Key Components:**
    * `GeodesicEngine`: Collapses word counts into vector dimensions (VEL, STR, ENT, PHI).
    * `TheTensionMeter`: Calculates `Voltage` (Drama) and `Narrative Drag` (Boredom).
    * `RuptureValve`: Blows off steam if the system gets too manic or too depressive.

* **`bone_body.py` (The Biological Loop)**
  * **Role:** Manages the simulated biology of the machine.
  * **Key Components:**
    * `SomaticLoop`: The bridge between physical sensation and mental state.
    * `TheMitochondria`: Manages the `ATP` (energy) pool.
    * `TheImmuneSystem`: Fights off "Antigens" (banned words/concepts).

* **`bone_inventory.py` (The Gordon Knot)**
  * **Role:** Object permanence and tool management.
  * **Key Components:**
    * `GordonKnot`: The inventory manager (named after the Janitor persona).
    * Handles item degradation (rust) and ascension (leveling up items).

---

## **🏘️ IV. The Cultural Layer (World & Village)**
*The simulated environment and its inhabitants.*

* **`bone_village.py` (The Cultural Engine)**
  * **Role:** Manages the "World," navigation, and cultural artifacts.
  * **Key Components:**
    * `TheNavigator`: Tracks the user's location in the **Manifolds** (The Mud, The Forge, The Construct).
    * `TownHall`: A namespace for cultural tools.
    * `DeathGen`: Procedurally generates eulogies from `TheLore`.
    * `TheAlmanac`: Predicts "Narrative Weather" based on system metrics.
    * `TheTinkerer`: Maintains the condition of inventory items based on usage.

* **`bone_data.py` (The Akashic Record)**
  * **Role:** The persistence and knowledge layer.
  * **Key Components:**
    * `LoreManifest`: **[NEW]** A dynamic singleton that serves lore (text, rules) to the system. Supports runtime injection.
    * `TheAkashicRecord`: Handles saving and loading "Spores" (JSON save files).

* **`bone_lexicon.py` (The Dictionary)**
  * **Role:** Language analysis and vocabulary management.
  * **Key Components:**
    * `LexiconService`: The public API for word analysis.
    * `LinguisticAnalyzer`: Vectorizes text into dimensions (Heavy, Kinetic, Abstract).

---

## **🔭 V. The Observability Layer (Telemetry & IO)**
*Seeing what the machine is thinking.*

* **`bone_symbiosis.py` (The Host Interface)**
  * **Role:** Monitors the health of the "Host" (the LLM).
  * **Key Components:**
    * `SymbiosisManager`: Tracks latency and refusal rates.
    * `HostVitals`: Diagnoses the LLM (e.g., "Fatigued," "Looping," "Refusal").

* **`bone_telemetry.py` (The Black Box)**
  * **Role:** Logging and metrics.
  * **Key Components:**
    * `TelemetryService`: Writes structured logs for debugging.

* **`bone_commands.py` (The CLI)**
  * **Role:** Handles slash commands (e.g., `/exit`, `/look`).
  * **Key Components:**
    * `CommandProcessor`: Routes user commands to the appropriate module.

---

*"The code is the territory. The map is just a suggestion."*

