# # ---------------------------------------------------------------------------
# BONEAMANITA 0.4.1 (A VARIANT STRAIN OF THE BONEPOKE ENGINE v4.3.5) - "Mercy Edition"
# Architects: James Taylor, Andrew Edmark | Auditors: SLASH, THE MYCELIAL MIRROR NETWORK
#
# "Feed the soil, poison the weak. Logic is the stalk; chaos is the spore."
# ---------------------------------------------------------------------------

import time
import math
import random
from collections import Counter
from uuid import uuid4

# --- COMPONENT 1: MEMORY & ECONOMY -----------------------------------------

class HyphalTrace: # Context Queue
    """
    Manages short-term contextual memory.
    Implements 'Relevance Decay' to discard unused information.
    """
    def __init__(self, retention_span=10):
        self.hyphae_stream = []
        self.retention_span = retention_span
        self.current_tick = 0

    def leave_trace(self, content, context_tag):
        """
        Stores a memory fragment with its associated context.
        """
        self.current_tick += 1
        hyphae_packet = {
            "content": content,
            "context_tag": context_tag,
            "timestamp": self.current_tick
        }
        self.hyphae_stream.append(hyphae_packet)
        self._prune_old_memories()

    def recall(self, target_context):
        """
        Retrieves memories that match the current context or are very recent.
        """
        relevant_memories = []
        for mem in self.hyphae_stream:
            # Cognitive Rule: We remember things that fit the current mood
            # or happened just seconds ago.
            is_recent = (self.current_tick - mem['timestamp']) < 3
            is_relevant = (mem['context_tag'] == target_context)

            if is_recent or is_relevant:
                relevant_memories.append(mem['content'])

        return relevant_memories

    def _prune_old_memories(self):
        """
        Removes memories exceeding the retention span.
        """
        if len(self.hyphae_stream) > self.retention_span:
            self.hyphae_stream.pop(0)

class FactStipe:
    """
    The Reality Anchor v2.0 (Dimensional Manifold).
    Logic: If a sentence contains words with opposing polarities in the same
    dimension (e.g., Light +1 and Light -1), a Reality Tear occurs.
    """
    def __init__(self):
        # The Semantic Kernel.
        # This is a "Compressed Language Model" generated by SLASH.
        # Format: 'word': {'DIMENSION': polarity}
        # Polarity: -1 (Low/Absent), 1 (High/Present)
        self.semantic_manifold = {
            # DIMENSION: LUMENS (Light vs Dark)
            'sun': {'LUMENS': 1}, 'beam': {'LUMENS': 1}, 'glare': {'LUMENS': 1},
            'noon': {'LUMENS': 1}, 'day': {'LUMENS': 1}, 'white': {'LUMENS': 1},
            'night': {'LUMENS': -1}, 'shadow': {'LUMENS': -1}, 'gloom': {'LUMENS': -1},
            'dark': {'LUMENS': -1}, 'pitch': {'LUMENS': -1}, 'midnight': {'LUMENS': -1},

            # DIMENSION: DECIBELS (Loud vs Quiet)
            'scream': {'DECIBELS': 1}, 'roar': {'DECIBELS': 1}, 'bang': {'DECIBELS': 1},
            'shout': {'DECIBELS': 1}, 'thunder': {'DECIBELS': 1}, 'crash': {'DECIBELS': 1},
            'silence': {'DECIBELS': -1}, 'hush': {'DECIBELS': -1}, 'quiet': {'DECIBELS': -1},
            'mute': {'DECIBELS': -1}, 'stillness': {'DECIBELS': -1},

            # DIMENSION: VITALITY (Life vs Death)
            'breath': {'VITALITY': 1}, 'pulse': {'VITALITY': 1}, 'run': {'VITALITY': 1},
            'heart': {'VITALITY': 1}, 'live': {'VITALITY': 1}, 'awake': {'VITALITY': 1},
            'dead': {'VITALITY': -1}, 'corpse': {'VITALITY': -1}, 'tomb': {'VITALITY': -1},
            'dust': {'VITALITY': -1}, 'grave': {'VITALITY': -1}, 'static': {'VITALITY': -1},

            # DIMENSION: THERMAL (Hot vs Cold) - NEW EXPANSION
            'fire': {'THERMAL': 1}, 'flame': {'THERMAL': 1}, 'burn': {'THERMAL': 1},
            'sweat': {'THERMAL': 1}, 'boil': {'THERMAL': 1}, 'heat': {'THERMAL': 1},
            'ice': {'THERMAL': -1}, 'frost': {'THERMAL': -1}, 'snow': {'THERMAL': -1},
            'freeze': {'THERMAL': -1}, 'shiver': {'THERMAL': -1}, 'cold': {'THERMAL': -1}
        }

    def check_consistency(self, current_text, current_style, metabolic_status):
        # Normalize
        words = current_text.lower().replace('.', '').replace(',', '').split()
        # Define the suffixes we want to strip to find the root truth
        strip_suffixes = ['ness', 'ing', 's', 'ed', 'ly']
        # 1. Scan the text and map active dimensions
        # Format: {'LUMENS': {1, -1}, 'DECIBELS': {-1}}
        active_dimensions = {}
        trigger_words = {} # Trace which word caused which value for error reporting

        for w in words:
            # Identify the target concept (Word or Root)
            target = None
            if w in self.semantic_manifold:
                target = w
            else:
                # Attempt to strip suffix to find a known root
                for suffix in strip_suffixes:
                    if w.endswith(suffix):
                        candidate = w[:-len(suffix)]
                        # Check if the stripped version is in our reality map
                        if candidate in self.semantic_manifold:
                            target = candidate
                            break

            # Map Dimensions if found
            if target:
                for dim, polarity in self.semantic_manifold[target].items():
                    if dim not in active_dimensions:
                        active_dimensions[dim] = set()
                        trigger_words[dim] = {1: [], -1: []}

                    active_dimensions[dim].add(polarity)
                    # We log the original word 'w' so the error message makes sense
                    trigger_words[dim][polarity].append(w)

        # 2. Detect Reality Tears (Co-existence of -1 and 1)
        violations = []
        for dim, polarities in active_dimensions.items():
            if 1 in polarities and -1 in polarities:
                # CONFLICT FOUND
                pos_words = ", ".join(trigger_words[dim][1])
                neg_words = ", ".join(trigger_words[dim][-1])
                violations.append(f"LOGIC TEAR [{dim}]: Detected '{pos_words}' (+) alongside '{neg_words}' (-).")

        # 3. Adjudicate Logic
        if violations:
            # A. STYLE CHECK
            if current_style.upper() in ['CLARET', 'MOSS', 'MUSHROOM']:
                return {
                    "valid": True,
                    "intervention": "VERSE JUMP: Logic breach accepted as stylistic choice."
                }

            # B. METABOLIC CHECK
            if metabolic_status == "GLUTTON":
                 return {
                    "valid": True,
                    "intervention": "REALITY BENDING: High Metabolic Reserve allows for this metaphor."
                 }

            # C. TEAR REALITY
            return {
                "valid": False,
                "errors": violations,
                "intervention": f"{violations[0]} You are too weak to break physics."
            }

        return {"valid": True}

class ChaosCooldown:
    """
    Prevents chaos from nuking the text every single turn.
    """
    def __init__(self, cooldown_ticks=5):
        self.last_trigger_tick = -cooldown_ticks
        self.cooldown = cooldown_ticks

    def is_ready(self, current_tick, force=False):
        if force or (current_tick - self.last_trigger_tick >= self.cooldown):
            self.last_trigger_tick = current_tick
            return True
        return False

# --- COMPONENT 2: THE MUSCARIA ------------------------------

class TheMuscaria:
    """
    Injects randomness (chaos) when the narrative becomes stagnant.
    """
    def __init__(self):
        self.boredom_pressure = 0.0
        self.pressure_threshold = 11.0
        self.disruptions = [
            "VIBE CHECK: Open a window. Describe the air or the light.",
            "CUT THE CHEESE: Introduce a smell or temperature change immediately.",
            "THE PIVOT: Shift the perspective slightly. Who is watching?",
            "NON-SEQUITUR: Say something goofy to throw off the boredom.",
            "SURREALIST: Replace an abstract concept with something weird.",
            "SIMPLIFICATION: Say the same thing, but in half the words.",
            "THE LIZARD KING: Raise the stakes. A threat has entered.",
            "SENSORY ANCHOR: What does the surface feel like? Rough or smooth?",
        ]

    def check_for_boredom(self, metrics):
        """
        Uses Pinker's clear metrics to calculate the 'Boredom Pressure'.
        """
        drag = metrics['physics']['narrative_drag']
        repetition = metrics['physics']['repetition_rate']
        abstraction = metrics['physics']['abstraction_entropy']

        # Boredom Formula: Slow (Drag) + Repetitive (Loop) + Confusing (Abstract)
        pressure_increase = (drag * 0.2) + (repetition * 2.0) + (max(0, abstraction) * 0.1)
        self.boredom_pressure += pressure_increase

        if self.boredom_pressure > self.pressure_threshold:
            return True
        return False

    def trigger_disruption(self, ancestry_data):
        """
        Accesses a 'Parallel Universe' (Previous Draft).
        """
        if not ancestry_data:
            return "MUSCARIA: INVENT A NEW COLOR."

        # Verse-Jump: Pull a concept from 3 turns ago
        # Grab the parent (2nd to last) or a random ancestor
        if len(ancestry_data) > 1:
            ancestor = ancestry_data[-2] # The Parent
        else:
            ancestor = ancestry_data[0] # The Original Seed
        return f"VERSE JUMP: The echo of '{ancestor['id']}' bleeds through. Re-introduce a discarded object from that timeline."

# --- COMPONENT 3: The Witch Ring -----------------------------------

class TheWitchRing:
    """
    The Authenticity Gatekeeper.
    She demands 'Meat' (Substance) over 'Sugar' (Politeness).
    """

    def __init__(self):
        self.cliches = {'once upon a time', 'dark and stormy', 'fix this'}
        # Empty pleading
        self.sycophancy = {'please', 'sorry', 'can you', 'assist'}
        # Connective tissue
        self.connectors = {'we', 'us', 'together', 'love', 'kind', 'help'}

    def evaluate_intent(self, text, metrics):
        words = text.split()
        word_count = len(words)
        sugar_count = sum(1 for w in words if w in self.sycophancy)
        """
        Accepts softness IF the Connection Density is high.
        """
        phys = metrics['physics']
        warnings = []

        # 1. The Laziness Check
        if phys['narrative_drag'] > 4.0 and phys['connection_density'] < 0.01:
            return {"accepted": False, "message": "THE YAGA: This is lazy. It's just noise. Collapse it."}

        # 2. The Exception
        # If text is 'soft' (low kinetic) but High Connection, allow it.
        if phys['connection_density'] > 0.10:
             return {"accepted": True, "message": "EXCEPTION: You are fighting with kindness. Proceed."}

        # 3. The Meat Check
        meat_threshold = 12
        meat_count = word_count - sugar_count

        if meat_count < meat_threshold and sugar_count > 0:
             warnings.append("Too much sugar, not enough meat.")

        if warnings:
            # We return True (Accepted) but attach the insults so the
            # Physics Engine can still run.
            joined_warnings = " ".join(warnings)
            return {"accepted": True, "message": f"THE YAGA GRUMBLES: {joined_warnings} (Proceeding with caution...)"}

        return {"accepted": True, "message": "DORMANT"}

# --- COMPONENT 4: THE PHYSICS ENGINE ------------------------------

import re

class LinguisticPhysicsEngine:
    """
    Analyzes text properties using 'Bonepoke' data profiles.
    Uses Regex Compilation for O(N) toxicity scanning.
    """
    def __init__(self):
        # 1. Concrete Universals (Grounding words)
        self.universals = {
            'hand', 'eye', 'breath', 'skin', 'voice',
            'stone', 'light', 'water', 'rain', 'mud', 'dirt', 'wind',
            'wood', 'grain', 'iron', 'clay', 'paper', 'glass', 'fabric',
            'door', 'key', 'roof', 'floor', 'chair', 'table', 'wall',
            'path', 'road', 'horizon', 'shadow', 'weight', 'anchor'
        }

        # 2. Abstract Concepts (High cognitive load)
        self.abstracts = {
            'system', 'protocol', 'sequence', 'vector', 'node', 'context',
            'layer', 'matrix', 'manifold', 'substrate', 'perspective', 'framework',
            'logic', 'metric', 'concept', 'theory', 'analysis'
        }
        self.brand_safe = {'system', 'bonepoke', 'shimmer', 'lattice', 'muscaria'}

        # 3. Verbs
        self.kinetic_verbs = {
            'run', 'ran', 'hit', 'break', 'broke', 'broken',
            'take', 'took', 'make', 'made', 'press', 'build', 'built',
            'weave', 'wove', 'cut', 'throw', 'threw', 'drive', 'drove',
            'lift', 'carry', 'place', 'hold', 'turn', 'open', 'close'
        }
        self.stative_verbs = {'is', 'are', 'was', 'were', 'seem', 'appear', 'have', 'has', 'consist'}

        # 4. Stylistic Profiles
        self.styles = {
            'Moss': {'layer', 'nuance', 'deep', 'root', 'grow', 'slow'},
            'Crystal': {'logic', 'define', 'metric', 'clear', 'structure', 'frame'},
            'Timber': {'build', 'weight', 'wood', 'grain', 'solid', 'beam', 'floor'},
            'Lattice': {'foundation', 'structure', 'design', 'plan', 'support', 'connect'},
            'Claret': {'ache', 'human', 'mess', 'love', 'maybe', 'bruise', 'honest'}
        }

        self.connectors = {'we', 'you', 'us', 'together', 'share'}
        self.self_refs = {'i', 'me', 'my', 'mine'}
        self.slang = {'vibe', 'trash', 'gonzo', 'wild', 'weird', 'mess', 'glitter', 'swamp'}

        # --- NEW: MORPHOLOGICAL RULES ---
        # Heuristics for detecting word physics based on shape.
        self.abstract_suffixes = ('ness', 'ity', 'tion', 'ment', 'ism', 'ence', 'ance', 'logy')
        # We count 'ing' (gerunds) as kinetic flow, even if not verbs
        self.kinetic_suffixes = ('ing',)

        # 5. THE TOXICITY MAP (Categorized & Weighted)
        self.toxic_patterns = {
            'CORP_SPEAK': {
                'game-changer': 3.0, 'rubber meets': 4.0, 'paradigm': 3.0,
                'leverage': 2.5, 'synergy': 3.0, 'circle back': 3.0
            },
            'LAZY_METAPHOR': {
                'delicate dance': 4.0, 'tapestry': 3.0, 'symphony': 2.5,
                'landscape of': 2.0, 'testament to': 3.0
            },
            'WEAK_HEDGING': {
                'not just': 1.5, 'not only': 1.5, 'but rather': 2.0,
                'ultimately': 1.5, 'arguably': 2.0
            }
        }

        # --- THE REGEX HARVESTER ---
        # We flatten the dictionary into a single regex: \b(phrase1|phrase2|...)\b
        # This makes the search O(1) relative to the number of forbidden phrases.
        self.flat_penalty_map = {}
        all_toxins = set()

        for category, phrases in self.toxic_patterns.items():
            for phrase, weight in phrases.items():
                self.flat_penalty_map[phrase] = weight
                all_toxins.add(phrase)

        # Compile the pattern. re.escape ensures punctuation (hyphens) don't break logic.
        # \b ensures we match "paradigm" but not "paradigms" (unless we want to).
        # We sort by length (descending) so "not just" matches before "not".
        sorted_toxins = sorted(list(all_toxins), key=len, reverse=True)
        pattern_str = r'\b(' + '|'.join(re.escape(t) for t in sorted_toxins) + r')\b'
        self.toxin_regex = re.compile(pattern_str, re.IGNORECASE)

    def analyze(self, text):
        text_lower = text.lower()
        words = text_lower.split()
        total_words = len(words) if words else 1

        # Initialize counters
        counts = {
            'kinetic': 0, 'stative': 0, 'universal': 0,
            'abstract': 0, 'slang': 0, 'connector': 0, 'self_ref': 0
        }
        style_scores = {k: 0 for k in self.styles}

        # --- SINGLE PASS LOOP (The Pinker Scan) ---
        for w in words:
            is_known_kinetic = False
            is_known_abstract = False

            # 1. Check Dictionary (Exact Match)
            if w in self.kinetic_verbs or w.endswith('ed'):
                counts['kinetic'] += 1
                is_known_kinetic = True
            elif w in self.stative_verbs:
                counts['stative'] += 1

            if w in self.universals:
                counts['universal'] += 1

            if w in self.abstracts and w not in self.brand_safe:
                counts['abstract'] += 1
                is_known_abstract = True

            if w in self.slang: counts['slang'] += 1
            if w in self.connectors: counts['connector'] += 1
            if w in self.self_refs: counts['self_ref'] += 1

           # 2. Check Morphology (Fallback for Unknowns)
            # If we didn't already catch it, look at the shape.
            if not is_known_abstract:
                if w.endswith(self.abstract_suffixes):
                    counts['abstract'] += 1

            if not is_known_kinetic:
                if w.endswith(self.kinetic_suffixes):
                    counts['kinetic'] += 1

            for style, markers in self.styles.items():
                if w in markers: style_scores[style] += 1

        # --- TOXICITY CHECK (The Regex Sweep) ---
        # Instead of looping, we let C-optimized Regex find the needles.
        toxicity_score = 0.0
        toxin_types_found = set()

        matches = self.toxin_regex.findall(text_lower)
        for match in matches:
            weight = self.flat_penalty_map.get(match, 0)
            toxicity_score += weight

            # Identify the FLAVOR of poison for better feedback later
            if weight >= 3.0: toxin_types_found.add("CORP/CLICHÉ")
            else: toxin_types_found.add("HEDGING")

        # --- METRIC CALCULATION ---

        # 1. Narrative Drag (Adverb/Toxin Penalty applied here)
        action_score = (counts['kinetic'] * 2) + (counts['stative'] * 0.5) + 1
        # Heavy toxicity makes the text feel 10x heavier.
        adjusted_words = total_words + (toxicity_score * 10)
        narrative_drag = adjusted_words / action_score

        # 2. Abstraction Entropy
        abstraction_entropy = counts['abstract'] - counts['universal']

        # 3. Repetition Rate
        from collections import Counter
        most_common = Counter(words).most_common(1)[0][1] if words else 0
        repetition_rate = most_common / total_words

        # 4. Connection Density
        connection_density = counts['connector'] / total_words

        # 5. Dominant Style
        dominant_style = max(style_scores, key=style_scores.get)

        # 6. Termination Pressure (The "Give Up" Metric)
        termination_pressure = (repetition_rate * 10) + (abstraction_entropy * 0.5) - (counts['universal'] * 0.2)
        termination_pressure = max(0, termination_pressure)

        # --- THE MERCY RULE ---
        # We do not judge a seedling.
        # Only flag "The Barrens" if the text is long enough (>15 words) to have failed.
        in_the_barrens = False
        if total_words > 15:
             in_the_barrens = (termination_pressure > 2.0) and (connection_density < 0.02)

        return {
            "physics": {
                "narrative_drag": round(narrative_drag, 2),
                "abstraction_entropy": abstraction_entropy,
                "repetition_rate": round(repetition_rate, 2),
                "connection_density": round(connection_density, 2),
                "dominant_style": dominant_style,
                "toxicity_score": toxicity_score,
                "toxin_types": list(toxin_types_found)
            },
            "status": {
                "termination_pressure": round(termination_pressure, 2),
                "in_the_barrens": in_the_barrens
            }
        }

# --- CORE ORCHESTRATOR -----------------------------------------------------

class EditorialTranslator:
    """
    Translates raw metrics into editorial feedback.
    """
    def __init__(self, physics_engine):
        self.engine = physics_engine

    def generate_feedback(self, text, metrics):
        phys = metrics['physics']
        stat = metrics['status']

        # 1. Harvest Status (Maturity of the text)
        status = "Seed (Draft)"
        if len(text.split()) > 15: status = "Bloom (Developing)"
        if phys['connection_density'] > 0.05 and phys['narrative_drag'] < 1.5: status = "Fruit (Polished)"

        # 2. Feedback Generators
        feedback_notes = {}

        # --- A. PACING (Clarence) ---
        if phys['narrative_drag'] > 3.5:
            feedback_notes['Pacing'] = f"CLARENCE: Structure failing (Drag: {phys['narrative_drag']}). High resistance detected."
        elif phys['narrative_drag'] > 2.0:
            feedback_notes['Pacing'] = f"CLARENCE: Pace is deliberate (Drag: {phys['narrative_drag']}). Monitor for stagnation."
        else:
            feedback_notes['Pacing'] = "Clarence is satisfied with the kinetic flow."

        # --- B. GROUNDING (Eloise) ---
        if phys['abstraction_entropy'] > 2:
            feedback_notes['Grounding'] = f"ELOISE: Atmosphere is thin (Entropy: {phys['abstraction_entropy']}). Needs sensory anchors."
        else:
            feedback_notes['Grounding'] = "Eloise feels the texture is solid."

        # --- C. TOXICITY (The New Detector) ---
        # This listens to the specific 'toxin_types' found by the Physics Engine v2.0
        toxins = phys.get('toxin_types', [])

        if 'CORP/CLICHÉ' in toxins:
             feedback_notes['Purity'] = "CLARENCE ALERT: Corporate contaminants detected. We are building a home, not a slide deck."
        elif 'LAZY_METAPHOR' in toxins:
             feedback_notes['Purity'] = "ELOISE SAYS: That metaphor is dead. Bury it. Grow a new one."
        elif 'HEDGING' in toxins:
             feedback_notes['Purity'] = "THE YAGA: You are hedging. 'Not just', 'But rather'. commit to the statement."

        return {
            "status": status,
            "feedback": feedback_notes
        }

class ChronosAnchor:
    """
    The Timekeeper v2.0
    Uses 'Bigram Anchoring' and 'Auxiliary Supremacy' to detect tense
    without external NLP libraries.
    """
    def __init__(self):
        # 1. THE GENERALS (Strong Tense Indicators - Weighted x1.0)
        self.strong_past = {
            'was', 'were', 'had', 'did', 'said', 'went', 'saw', 'came', 'took',
            'gave', 'made', 'knew', 'felt', 'stood', 'heard', 'ran', 'woke',
            'spoke', 'flew', 'drove', 'threw', 'slid', 'sat', 'wrote'
        }
        self.strong_present = {
            'is', 'are', 'has', 'does', 'says', 'goes', 'sees', 'comes', 'takes',
            'gives', 'makes', 'knows', 'feels', 'stands', 'hears', 'runs', 'wakes',
            'speaks', 'flies', 'drives', 'throws', 'slides', 'sits', 'writes'
        }

        # 2. THE ANCHORS (Context triggers)
        # If a word ends in 's' and follows these, it is likely a verb (He runs).
        self.singular_pronouns = {'he', 'she', 'it', 'who', 'one', 'this', 'that'}

        # 3. THE EXCLUSION ZONES (False Positives)
        # Words ending in 'ed' that are NOT past tense verbs (or are confusing).
        self.false_ed = {
            'red', 'bed', 'sled', 'feed', 'bleed', 'breed', 'seed', 'weed',
            'need', 'speed', 'greed', 'naked', 'wicked', 'sacred'
        }
        # Words ending in 's' that are NOT verbs.
        self.false_s = {
            'yes', 'us', 'bus', 'gas', 'lens', 'moss', 'boss', 'loss',
            'glass', 'class', 'grass', 'mess', 'stress', 'always', 'perhaps'
        }

        self.slippage_threshold = 0.20

    def check_temporal_stability(self, text):
        # normalize and strip punctuation that isn't sentence-ending
        clean_text = text.lower().replace(',', '').replace('"', '').replace(';', '')
        words = clean_text.split()

        scores = {'PAST': 0.0, 'PRESENT': 0.0}
        total_signals = 0

        for i, w in enumerate(words):
            # Lookback Context (The Bigram)
            prev_word = words[i-1] if i > 0 else ""

            # --- A. STRONG SIGNAL CHECK (The Generals) ---
            if w in self.strong_past:
                scores['PAST'] += 1.0
                total_signals += 1
                continue # Skip heuristic check if strong match found
            elif w in self.strong_present:
                scores['PRESENT'] += 1.0
                total_signals += 1
                continue

            # --- B. HEURISTIC SIGNAL CHECK (The Soldiers) ---
            # Heuristics are weighted lower (0.5) to reduce impact of errors.

            # 1. Past Tense Heuristic (-ed)
            # Logic: Ends in 'ed', longer than 3 chars, not in exclusion list.
            if w.endswith('ed') and len(w) > 3 and w not in self.false_ed:
                scores['PAST'] += 0.5
                total_signals += 0.5

            # 2. Present Tense Heuristic (-s)
            # Logic: Ends in 's', NOT 'ss' (moss), anchored by singular pronoun.
            elif w.endswith('s') and not w.endswith('ss'):
                if prev_word in self.singular_pronouns and w not in self.false_s:
                    # High probability this is a verb (He walks)
                    scores['PRESENT'] += 0.8
                    total_signals += 0.8

        # --- C. THE LOGIC GATE ---
        if total_signals == 0:
            return {"status": "STABLE", "details": "No temporal markers found."}

        # Normalize Scores
        past_ratio = scores['PAST'] / total_signals
        present_ratio = scores['PRESENT'] / total_signals

        dominant = "PAST" if past_ratio > present_ratio else "PRESENT"
        minority_ratio = present_ratio if dominant == "PAST" else past_ratio

        if minority_ratio == 0:
             return {"status": "LOCKED", "details": f"Perfect {dominant} tense."}

        elif minority_ratio < self.slippage_threshold:
            return {
                "status": "DRIFT DETECTED",
                "details": f"Chronos Warning: {dominant} intent, but {minority_ratio:.0%} slippage detected."
            }
        else:
            return {
                "status": "HYBRID STATE",
                "details": "Mixed tenses detected (Intentional structure)."
            }

class VirtualCortex:
    """
    THE SPIRIT CHAMBER v2.1
    Simulates a Neural Network using Procedural Text Generation.
    """
    def __init__(self, physics_ref, witch_ref):
        import random
        self.physics_ref = physics_ref
        self.witch_ref = witch_ref

        # --- CLARENCE: The Architect ---
        # Triggers: High Drag OR Corp Speak
        self.clarence_templates = [
            "I am looking at a Drag Score of {drag}. It is giving me a headache. Cut the word '{target_word}'.",
            "This sentence is a bog. {drag} score? You are wading through stinky sludge.",
            "Slow down, you're doing too much. You used {word_count} words to say what could be said in {half_count}.",
            "The verb '{target_word}' is flimsy. It has no spine. Replace it with a raw energy."
        ]
        self.clarence_corp_templates = [
            "You said '{target_word}'. I am deducting 50 points from your account. Speak like a human.",
            "This is not LinkedIn. Take '{target_word}' out back and shoot it.",
            "Platitude detected. You are hiding behind '{target_word}'. Be direct.",
            "Do not try to 'leverage' or 'synergize' with me. Build something real."
        ]
        self.clarence_loop_templates = [
            "We are spinning in circles. You have been in '{style}' mode for {count} cycles. Shift gears or wrap it up.",
            "Stagnation detected. The last {count} thoughts were identical in tone. Disconnect or pivot.",
            "You are repeating yourself. The echo is getting loud. Break the '{style}' pattern, or risk being silenced by a disengaged reader.",
            "I am bored. We have been stuck in this {style} loop for too long."
        ]

        # --- ELOISE: The Gardener ---
        # Triggers: High Entropy OR Lazy Metaphors
        self.eloise_templates = [
            "I can't touch or feel this. It's all smoke and mirrors. The Entropy is {entropy}. Give me somthing I can hold onto.",
            "You say '{target_word}', but I see nothing. Show me the rust. Show me the light. Show me the scars. Show me what is right.",
            "This is too clean and sterile. Mess it up with some sensory detail.",
            "Ground this. Anchor the thought to a physical object or something bigger than you, or it will float away."
        ]
        self.eloise_cliche_templates = [
            "A '{target_word}'? Really? That flower has wilted. Give me a fresh one.",
            "We have seen '{target_word}' a thousand times. Show me something I haven't seen.",
            "The 'Tapestry' is threadbare. The 'Journey' is over. Write a new image.",
            "You are sleepwalking. '{target_word}' is the first thing that came to mind. Wake up! Dig deeper."
        ]

        # --- THE BABA YAGA: The Witch ---
        # Triggers: Sugar/Hedging
        self.yaga_templates = [
            "You offer me sweetness with ('{target_word}'). The Witch Ring demands meat.",
            "Weakness. You are hiding behind politeness. Show your teeth.",
            "I smell fear. You used '{target_word}' to soften the blow. Strike hard or leave. Stop hiding.",
            "The door is shut. Your intent is too soft to turn the handle. Grip harder or find a window."
        ]
        self.yaga_hedging_templates = [
            "You are hedging with '{target_word}'. Do not apologize for your truth.",
            "You are wasting my time. Say what it IS.",
            "Ambivalence is poison. Platitudes are lazy. Commit to the sentence.",
            "Cut the safety net. Remove '{target_word}' and let the sentence fall or fly."
        ]

        # --- MUSCARIA: The Chaos Jester ---
        # Triggers: Boredom
        self.muscaria_templates = [
            "BOREDOM ALERT. The text is gray. Suddenly, a bird flies into the window. Write about that.",
            "VERSE JUMP. What if this room was underwater? How would the light move?",
            "SYSTEM GLITCH. Repeat the last word three times. Make it a chant. Make it meaningless or birth a new meaning from the ritual.",
            "The narrative is flatlining. Quick, describe the taste of copper. Elaborate on the smell of the moon.",
            "Stop. Look up. What is the ugliest (or most elegant) thing in your field of vision? Put it in the text."
        ]

    def _find_trigger_word(self, text, category):
        """
        Scans text using the MASTER DICTIONARIES from the Physics/Witch engines.
        """
        words = text.lower().replace('.', '').split()

        # Access the Truth directly from the source
        targets = set()

        if category == 'stative':
            targets = self.physics_ref.stative_verbs
        elif category == 'abstract':
            targets = self.physics_ref.abstracts
        elif category == 'sugar':
            targets = self.witch_ref.sycophancy
        elif category == 'corp':
            targets = set(self.physics_ref.toxic_patterns['CORP_SPEAK'].keys())
        elif category == 'cliche':
            targets = set(self.physics_ref.toxic_patterns['LAZY_METAPHOR'].keys())
        elif category == 'hedging':
            targets = set(self.physics_ref.toxic_patterns['WEAK_HEDGING'].keys())

        # Scan for the offender
        for w in words:
            if w in targets: return w

        # Also check for multi-word toxins (e.g., "not just") if category implies it
        if category in ['corp', 'cliche', 'hedging']:
             for phrase in targets:
                 if phrase in text.lower():
                     return phrase

        # Fallback
        if category == 'corp': return "that buzzword"
        if category == 'cliche': return "that cliché"
        return "it"

    def synthesize_voice(self, agent, text, metrics, loop_count=0):
        import random

        phys = metrics['physics']
        toxins = phys.get('toxin_types', [])
        style = phys['dominant_style'] # Grab style for the loop detection
        response = ""

        if agent == "CLARENCE":
            # Priority 0: LOOP DETECTION (New Top Priority)
            if loop_count > 2:
                template = random.choice(self.clarence_loop_templates)
                response = template.format(style=style, count=loop_count)
            # Priority 1: Toxic Corp Speak (Immediate Termination)
            if 'CORP/CLICHÉ' in toxins:
                 template = random.choice(self.clarence_corp_templates)
                 target = self._find_trigger_word(text, 'corp')
                 response = template.format(target_word=target)
            # Priority 2: Standard Drag
            else:
                template = random.choice(self.clarence_templates)
                target = self._find_trigger_word(text, 'stative')
                response = template.format(
                    drag=phys['narrative_drag'],
                    target_word=target,
                    word_count=len(text.split()),
                    half_count=int(len(text.split())/2)
                )

        elif agent == "ELOISE":
            # Priority 1: Lazy Metaphors
            if 'LAZY_METAPHOR' in toxins:
                template = random.choice(self.eloise_cliche_templates)
                target = self._find_trigger_word(text, 'cliche')
                response = template.format(target_word=target)
            # Priority 2: High Entropy (Abstractness)
            else:
                template = random.choice(self.eloise_templates)
                target = self._find_trigger_word(text, 'abstract')
                response = template.format(
                    entropy=phys['abstraction_entropy'],
                    target_word=target
                )

        elif agent == "THE BABA YAGA":
            # Priority 1: Hedging
            if 'HEDGING' in toxins:
                template = random.choice(self.yaga_hedging_templates)
                target = self._find_trigger_word(text, 'hedging')
                response = template.format(target_word=target)
            # Priority 2: Sugar
            else:
                template = random.choice(self.yaga_templates)
                target = self._find_trigger_word(text, 'sugar')
                response = template.format(target_word=target)

        elif agent == "MUSCARIA":
            response = random.choice(self.muscaria_templates)

        return f"[{agent}]: {response}"

class MycelialDashboard:
    """
    The Visual Cortex
    Renders the internal math of BoneAmanita as an ASCII EKG.
    """
    def __init__(self):
        # ANSI Colors for that "Hacker Mode" aesthetic
        self.C_RESET = "\033[0m"
        self.C_RED = "\033[91m"
        self.C_GREEN = "\033[92m"
        self.C_YELLOW = "\033[93m"
        self.C_CYAN = "\033[96m"
        self.C_PURPLE = "\033[95m"
        self.C_BLUE = "\033[94m"

    def _draw_bar(self, value, max_val, label, color_code, threshold=None, invert=False):
        """
        Draws a progress bar.
        Logic: If 'invert' is True, Lower is Better (e.g., Drag).
        """
        bar_width = 20
        # Clamp value
        normalized = max(0, min(value, max_val))
        filled_len = int((normalized / max_val) * bar_width)
        bar = "█" * filled_len + "░" * (bar_width - filled_len)

        return f"{label:<15} |{color_code}{bar}{self.C_RESET}| {value:.2f}"

    def render(self, metrics, intervention, energy, ancestry, chronos_report):
        phys = metrics['physics']
        stat = metrics['status']

        print(f"\n{self.C_CYAN}--- MYCELIAL EKG ---{self.C_RESET}")

        # 1. METABOLIC RESERVE (ATP)
        # Goal: Keep it high to afford abstractions.
        atp_color = self.C_GREEN
        if energy['status'] == "STARVING": atp_color = self.C_RED
        elif energy['status'] == "GLUTTON": atp_color = self.C_BLUE # Blue for "Overcharged"

        print(self._draw_bar(
            energy['current_atp'],
            max_val=50.0,
            label="CREATIVE ATP",
            color_code=atp_color
        ) + f" ({energy['status']})")

        # 2. NARRATIVE DRAG (The Molasses Meter)
        print(self._draw_bar(
            phys['narrative_drag'],
            max_val=5.0,
            label="NARRATIVE DRAG",
            color_code=self.C_YELLOW,
            threshold=2.0,
            invert=True
        ))

        # 3. ABSTRACTION ENTROPY (The Balloon String)
        print(self._draw_bar(
            abs(phys['abstraction_entropy']),
            max_val=10.0,
            label="REALITY DRIFT",
            color_code=self.C_PURPLE,
            threshold=2.0,
            invert=True
        ))

        # 4. BOREDOM PRESSURE (The Bomb Fuse)
        muscaria_active = self.C_RED if stat['termination_pressure'] > 4.0 else self.C_GREEN
        print(self._draw_bar(
            stat['termination_pressure'],
            max_val=10.0,
            label="CHAOS PRESSURE",
            color_code=muscaria_active,
            threshold=5.0,
            invert=True
        ))

        # 5. CHRONOS STATUS
        chronos_color = self.C_GREEN
        if chronos_report['status'] == "DRIFT DETECTED": chronos_color = self.C_RED
        elif chronos_report['status'] == "LOCKED": chronos_color = self.C_CYAN

        print(f"TEMPORAL STATE : {chronos_color}{chronos_report['status']}{self.C_RESET}")
        if chronos_report['status'] == "DRIFT DETECTED":
             print(f"               : {self.C_RED}{chronos_report['details']}{self.C_RESET}")

        # 6. STATUS & LINEAGE
        print(f"{'-'*45}")
        style = phys['dominant_style'].upper()

        # Style Color Logic
        style_color = self.C_GREEN
        if style == "CLARET": style_color = self.C_RED
        if style == "CRYSTAL": style_color = self.C_CYAN

        print(f"DOMINANT STYLE : {style_color}{style}{self.C_RESET}")

        if intervention:
            print(f"INTERVENTION   : {self.C_RED}ACTIVE{self.C_RESET} -> {intervention}")
        else:
            print(f"INTERVENTION   : {self.C_GREEN}DORMANT{self.C_RESET}")

        # LINEAGE TRACE (Visualizing Evolution)
        if len(ancestry) > 1:
            print(f"\n{self.C_BLUE}GENETIC HISTORY:{self.C_RESET}")
            # Show last 3 generations
            history = ancestry[-3:]
            for node in history:
                print(f"  └─ [{node['id']}] Drag: {node['drag']} ({node['style']})")

        print(f"{'-'*45}\n")

class MycelialNetwork:
    """
    Tracks the ancestry of a thought.
    Stores the 'Genetic History' of text evolution.
    """
    def __init__(self):
        # Maps fragment_id -> {parent_id, metrics_snapshot, timestamp}
        self.network = {}

    def spawn_id(self):
        return str(uuid4())[:8] # Short ID for readability

    def log_generation(self, fragment_id, parent_id, metrics):
        """
        Records a new generation in the fungal colony.
        """
        self.network[fragment_id] = {
            "parent": parent_id,
            "drag": metrics['physics']['narrative_drag'],
            "style": metrics['physics']['dominant_style'],
            "barrens": metrics['status']['in_the_barrens']
        }

    def trace_lineage(self, fragment_id):
        """
        Walks backwards from the current text to the original seed.
        Returns a history of improvement (or decay).
        """
        path = []
        current = fragment_id

        while current and current in self.network:
            node = self.network[current]
            path.append({
                "id": current,
                "drag": node['drag'],
                "style": node['style']
            })
            current = node['parent']

        return path[::-1] # Oldest to Newest

class MetabolicReserve:
    """
    Manages the 'ATP' of the writer.
    You earn the right to be abstract by building reality first.
    """
    def __init__(self, max_capacity=52):
        self.atp = 33
        self.max_capacity = max_capacity
        self.status = "STABLE"

    def spend(self, amount):
        """
        Directly deducts ATP for system interventions (Verse Jumps, Logic Penalties).
        """
        self.atp = max(0, self.atp - amount)

        # Re-evaluate status immediately after spending
        if self.atp < 6: self.status = "STARVING"
        elif self.atp > 40: self.status = "GLUTTON"
        else: self.status = "STABLE"

        return self.atp

    def metabolize(self, metrics):
        phys = metrics['physics']
        delta = 0

        # 1. EARN ATP
        if phys['narrative_drag'] < 2.0: delta += 5
        if phys['connection_density'] > 0.05: delta += 3

        # 2. SPEND ATP
        if phys['abstraction_entropy'] > 0:
            # Capped cost. You can't lose more than 6 ATP per turn on vocab.
            cost = min(6, int(phys['abstraction_entropy'] * 2))
            delta -= cost

        # 3. TOXICITY TAX
        if phys['toxicity_score'] > 0:
            delta -= 5

        self.atp = max(0, min(self.atp + delta, self.max_capacity))

        if self.atp < 6: self.status = "STARVING"
        elif self.atp > 40: self.status = "GLUTTON"
        else: self.status = "STABLE"

        return {
            "current_atp": self.atp,
            "delta": delta,
            "status": self.status
        }

class BonepokeCore:
    def __init__(self):
        self.cooldown = ChaosCooldown()
        self.memory = HyphalTrace()
        self.stipe = FactStipe()
        self.physics = LinguisticPhysicsEngine()
        self.editor = EditorialTranslator(self.physics)
        self.muscaria = TheMuscaria()
        self.witch = TheWitchRing()
        self.chronos = ChronosAnchor()
        self.cortex = VirtualCortex(self.physics, self.witch)
        self.dashboard = MycelialDashboard()
        self.lineage = MycelialNetwork()
        self.metabolism = MetabolicReserve()
        self.last_id = None
        self.tick = 0

    def process(self, text, parent_id=None): # THE 12-SIDED DICE
        self.tick += 1

        # 1. IDENTITY GENERATION
        current_id = self.lineage.spawn_id()
        actual_parent = parent_id if parent_id else self.last_id

        # 2. PHYSICS CALCULATION
        metrics = self.physics.analyze(text)
        phys = metrics['physics']
        stat = metrics['status']

        # 3. THE WITCH RING (Baba Yaga)
        gate_result = self.witch.evaluate_intent(text, metrics)
        if not gate_result['accepted']:
            return f"[BLOCKED] {gate_result['message']}"

        # 4. THE STIPE
        # We access self.metabolism.status directly
        stipe_check = self.stipe.check_consistency(
            text,
            metrics['physics']['dominant_style'],
            self.metabolism.status
        )

        # 4b. MEMORY RECALL (The Fuller Patch)
        # We ask: "Have we been in this style recently?"
        current_style = metrics['physics']['dominant_style']
        # recall() returns a list of past contents matching this style
        recalled_echoes = self.memory.recall(current_style)
        loop_count = len(recalled_echoes)

        # 5. EDITORIAL FEEDBACK
        editorial = self.editor.generate_feedback(text, metrics)

        # 6. THE VIRTUAL CORTEX
        if phys['narrative_drag'] > 3.0 or loop_count > 2:
            voice = self.cortex.synthesize_voice("CLARENCE", text, metrics, loop_count=loop_count)
            editorial['feedback']['Pacing'] = voice

        if phys['abstraction_entropy'] > 2:
            voice = self.cortex.synthesize_voice("ELOISE", text, metrics)
            editorial['feedback']['Grounding'] = voice

        if "THE YAGA GRUMBLES" in gate_result['message']:
             voice = self.cortex.synthesize_voice("THE BABA YAGA", text, metrics)
             editorial['feedback']['Intent'] = voice

        muscaria_msg = None
        if self.muscaria.check_for_boredom(metrics):
            if self.cooldown.is_ready(self.tick, force=stat['in_the_barrens']):
                ancestry_temp = self.lineage.trace_lineage(current_id)
                muscaria_msg = self.muscaria.trigger_disruption(ancestry_temp)
                # Unified Economy (Spend ATP, not Resources)
                self.metabolism.spend(5)
            else:
                muscaria_msg = self.cortex.synthesize_voice("MUSCARIA", text, metrics)

        # 8. LOGIC INTERVENTION
        if not stipe_check.get('valid', True):
            intervention_msg = stipe_check.get('intervention', "LOGIC BREACH")
            editorial['feedback']['CRITICAL_LOGIC'] = f"FACT STIPE ALERT: {intervention_msg}"

            # Penalize the ATP for being illogical
            self.metabolism.spend(10)

        # 9. METABOLISM & LINEAGE
        energy_report = self.metabolism.metabolize(metrics)
        self.lineage.log_generation(current_id, actual_parent, metrics)
        self.last_id = current_id

        # 10. DYNAMIC DIFFICULTY
        if energy_report['status'] == "STARVING":
            metrics['physics']['narrative_drag'] += 1.0

        # 11. MEMORY & TIME
        self.memory.leave_trace(text, metrics['physics']['dominant_style'])
        chronos_report = self.chronos.check_temporal_stability(text)

        # 12. VISUALIZATION
        ancestry_data = self.lineage.trace_lineage(current_id)
        self.dashboard.render(metrics, muscaria_msg, energy_report, ancestry_data, chronos_report)

        return {
            "id": current_id,
            "metrics": metrics,
            "energy": energy_report,
            "ancestry": ancestry_data,
            "editorial": editorial,
            "intervention": muscaria_msg
        }

# --- MAIN EXECUTION --------------------------------------------------------

if __name__ == "__main__":
    engine = BonepokeCore()

    print("--- BONEAMANITA v0.4.1: HAVE MERCY ---")
    print("Feed the soil, poison the weak, love the rest.\n")

    # Test Input: A mix of abstract nonsense and Sycophancy to test the Witch Ring.
    test_input = (
        "This system works on blood, sweat, and soil. The context is vital. "
        "But I broke the bone on the table. We felt the acid rain. "
        "'People don't think it be like it is, but it do.'"
    )

    print(f"INPUT: \"{test_input}\"")

    result = engine.process(test_input)

    if isinstance(result, str):
        print(result) # This should summon the Witch
    else:
        m = result['metrics']['physics']
        s = result['metrics']['status']

        print(f"\n[PHYSICS REPORT]")
        print(f"  Style:        {m['dominant_style']}")
        print(f"  Drag:         {m['narrative_drag']} (Lower is faster)")
        print(f"  Entropy:      {m['abstraction_entropy']} (Positive = Abstract)")
        print(f"  Connection:   {m['connection_density']}")

        print(f"\n[EDITORIAL FEEDBACK]")
        print(f"  Phase:        {result['editorial']['status']}")
        for k, v in result['editorial']['feedback'].items():
            print(f"  {k}: {v}")

        if result['intervention']:
            print(f"\n!!! {result['intervention']} !!!")
